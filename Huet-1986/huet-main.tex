%!TEX root = huet-1986-pal.tex
%\usepackage[dotinlabels]{titletoc}
%\titlelabel{{\thetitle}.\quad}
%\input{../helpers/psu-plain-titles.tex}
%\input{../helpers/psu-sc-headers.tex}
%\input{../helpers/fix-revtex-12.tex}
%\DeclareSymbolFont{CMlargesymbols}{OMX}{cmex}{m}{n}
%\DeclareMathSymbol{\sum}{\mathop}{CMlargesymbols}{"50}

\usepackage[papersize={6.6in, 10.0in}, left=.5in, right=.5in, top=.6in, bottom=.9in]{geometry}
\linespread{1.05}
\sloppy
\raggedbottom

\pagestyle{plain}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{tikz-cd}
\usepackage{microtype}
\usepackage{enumitem}
\usepackage{nccmath}
\usetikzlibrary {arrows.meta,bending,positioning}
\usepackage{bussproofs}

\newcommand{\mprime}{\ensuremath{^\prime}}

%\usepackage{fdsymbol}

% these include amsmath and that can cause trouble in older docs.
\input{../helpers/cmrsum}
\input{../helpers/fix-underbrace.tex}

% some nicer symbols
\input{../helpers/matha-symbols.tex}

\usepackage[tiny]{titlesec}
\titleformat{\section}
  {\normalfont\bfseries}
  {\thesection.}
  {.5em}
  {}

\usepackage{cite}

% make sure there is enough TOC for reasonable pdf bookmarks.
\setcounter{tocdepth}{3}
\usepackage{amsthm}

\theoremstyle{definition}


\usepackage[colorlinks=true
,breaklinks=true
,urlcolor=blue
,anchorcolor=blue
,citecolor=blue
,filecolor=blue
,linkcolor=blue
,menucolor=blue
,linktocpage=true]{hyperref}
\hypersetup{
bookmarksopen=true,
bookmarksnumbered=true,
bookmarksopenlevel=10,
pdfencoding=auto, psdextra
}

\date{}
\def\deqd{\mathrel{\cdot\!\!=\!\!\cdot}}
\def\trans{\Phi}
\def\mm{\Vdash}
\def\kxa{\kappa_{x \in A}}
\def\prAB{\pi_{A,B}}
\def\prpAB{\pi'_{A,B}}
\def\pr#1{\pi_{#1}}
\def\prp#1{\pi'_{#1}}
\def\to{\rightarrow}
\def\xto#1{\xrightarrow{\kern.6em #1 \kern.6em}}
\def\sxto#1{\xrightarrow{\kern.3em #1 \kern.3em}}
\def\ent{\vdash}
\def\eent{\Vdash}
\def\entt{\models}
\def\imp{\rightarrow}
\def\iff{\leftrightarrow}
\def\from{\Leftarrow}
\def\impl{\Rightarrow}
\def\union{\cup}
\def\fexp#1#2{#1^{#2}}
\def\fexpBA{\fexp{B}{A}}
\def\inc{\subseteq}
\def\Sub{\mathop{\rm sub}}
\def\dom{\mathop{\rm dom}}
\def\cod{\mathop{\rm cod}}
\def\ker{\mathop{\rm ker}}
\def\Ker{\mathop{\rm Ker}}
\def\cha{\mathop{\rm char}}
\def\id{{\mathrm 1}}
\def\res{\!\upharpoonleft\!}
\def\ffam{\varphi}
\def\comp{\mathrel{\circ}}
\def\bbone{\mathbb 1}
\def\one{1}
\def\zeromap{0}
\def\bbzero{{\mathbb O}}
\def\ccc{{c.c.c.}}
\def\ev{\varepsilon}
\def\ebc{\varepsilon_{BC}}
\def\evBA{\varepsilon_{B,A}}
\def\L{\Lambda}
\def\OM{\Omega}
\def\nat{\text{\it nat}}

\def\l{\lambda}
\def\lamC{\l\text{-{\bf{\kern 0.2pt}calc}}}
\def\lx{\lambda_x}
\def\ly{\lambda_y}
\def\lu{\lambda_u}
\def\lv{\lambda_v}
\def\lz{\lambda_z}
\def\lxa{\l_{x \in A}}
\def\subX{\ensuremath{_\text{X}}}
\def\lm#1.#2{\lambda#1.\, #2}
\def\br#1{[\, #1 \, ]}
\def\V{V}
\def\U{U}
\def\D{D}
\def\cart{\text{\bf Cart}}
\def\C{\mathcal C}
\def\S{\mathcal S}
\def\lxy{\l x\, \l y . \,}
\def\lmm#1#2.#3{\l #1\, \l #2 . \, #3}
\def\sss{(*\!*\!*)}
\def\ss{(**)}
\def\ssn{(**_n)}
\def\scop{\S^{\C^{op}}}
\def\sland{\wedge}
\def\PU{\mathcal P U}
\def\P{\mathcal P}
\def\R{\mathcal R}
\def\UU{(U\to U)}
\def\BA{B \to A}
\def\AB{A \to B}
\def\calA{{\cal A}}
\def\calB{{\cal B}}
\def\cI{{I}}
\def\cS{{S}}
\def\cK{{K}}
\def\cIA{\cI_{A}}
\def\cKAB{\cK_{A,B}}
\def\cSABC{\cS_{A,B,C}}
\def\la{\langle}
\def\ra{\rangle}
\def\bracket#1{\la #1 \ra}
\def\app{\mathop{{}^\wr}\kern-.8pt}
\def\schon{Sch\"onfinkel}
\def\pf{\varphi}
\def\abs#1{\mathop{\text{\tt [$#1$]}}}
\def\App{\mathop{\text{\it App}}}
\def\sigmaN{\Sigma^n_N}
\def\comptr{\triangleright}

\newcommand{\be}{\begin{equation}}
\newcommand{\ee}{\end{equation}}
\newcommand{\bes}{\begin{equation*}}
\newcommand{\ees}{\end{equation*}}

\newcommand{\fcat}[1]{{\mathbf {#1}}} 
\newcommand{\Cat}{\fcat{Cat}}
\newcommand{\Prod}{\fcat{Prod}}
\newcommand{\Lang}{\fcat{Lang}}
\newcommand{\grph}{\fcat{Grph}}
\newcommand{\AC}{\fcat{A}}
\newcommand{\CC}{\fcat{Categ}}
\newcommand{\ZC}{\fcat{Z}}
\def\LC{\fcat{L}}
\def\MC{\fcat{M}}
\def\TC{\fcat{T}}
\def\FC{\fcat{F}}
\DeclareMathOperator{\Hom}{{Hom}}
\def\compseq#1#2{#1 \mathbin{;} #2}
\def\Id{\text{\it Id\/}}
\def\Idl{\text{\it Idl}}
\def\Idr{\text{\it Idr}}
\def\Nil{\text{\it Nil}}
\def\Uni{\text{\it Uni}}
\def\Nill{\text{\it Nil}_1}
\def\Unii{\text{\it Uni}_1}
\def\Assoc{\text{\it Assoc}}
\def\fst{\mathop{\text{\it fst\/}}}
\def\snd{\mathop{\text{\it snd\/}}}
\def\pair#1#2{\la  #1, #2 \ra}
\def\emptypair{\la  \_\,, \_ \ra}

\newcommand{\iso}{\cong}                % Isomorphism
\newcommand{\eqv}{\simeq}               % Equivalence
\newcommand{\sub}{\subseteq}            % Subset (possibly not proper)

\usepackage{amsmath,amsthm}

\theoremstyle{definition}

\newtheorem{thm}{Theorem}[section]
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{defn}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\newtheorem{remark}[thm]{Remark}
\newtheorem{note}[thm]{Note}

% makes "=" with "x" under it
\makeatletter
\DeclareRobustCommand{\eqx}{\mathrel{\mathpalette\eq@{X}}}
\DeclareRobustCommand{\eqlx}{\mathrel{\mathpalette\eq@{x}}}
\DeclareRobustCommand{\eqy}{\mathrel{\mathpalette\eq@{Y}}}
\DeclareRobustCommand{\eqxx}{\mathrel{\mathpalette\eq@{X \union \{x\}}}}
\DeclareRobustCommand{\eqtx}{\mathrel{\mathpalette\eq@{\trans(X)}}}
\newcommand{\eq@}[2]{%
  \vtop{\offinterlineskip
    \ialign{\hfil##\hfil\cr
      $\m@th#1=$\cr % top
      \noalign{\sbox\z@{$\m@th#1\mkern0mu$}\kern-\wd\z@}
      $\m@th\alexey@demote{#1}#2$\cr
    }%
  }%
}
\DeclareRobustCommand{\eqdX}{\mathrel{\mathpalette\eqd@{X}}}
\DeclareRobustCommand{\eqdx}{\mathrel{\mathpalette\eqd@{x}}}
\newcommand{\eqd@}[2]{%
  \vtop{\offinterlineskip
    \ialign{\hfil##\hfil\cr
      $\m@th#1\deqd$\cr % top
      \noalign{\sbox\z@{$\m@th#1\mkern0mu$}\kern-\wd\z@}
      $\m@th\alexey@demote{#1}#2$\cr
    }%
  }%
}
\newcommand{\alexey@demote}[1]{%
  \ifx#1\displaystyle\scriptstyle\else
  \ifx#1\textstyle\scriptstyle\else
  \scriptscriptstyle\fi\fi
}

\makeatother

% footnote tricks
\usepackage{footmisc}
%\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\makeatletter
\let\original@footnotemark\footnotemark
\newcommand{\align@footnotemark}{%
  \ifmeasuring@
    \chardef\@tempfn=\value{footnote}%
    \original@footnotemark
    \setcounter{footnote}{\@tempfn}%
  \else
    \iffirstchoice@
      \original@footnotemark
    \fi
  \fi}
\pretocmd{\start@align}{\let\footnotemark\align@footnotemark}{}{}
\makeatother

\makeatletter
\newcommand*\dotop{\mathpalette\bigcdot@{.6}}
\newcommand*\bigcdot@[2]{\mathbin{\vcenter{\hbox{\scalebox{#2}{$\m@th#1\bullet$}}}}}
\makeatother

\begin{document}

\title{\large Cartesian Closed Categories and Lambda Calculus}
\author{\normalsize G\'erad Huet%
\footnote{This is a remake of the paper {\em Cartesian Closed Categories and Lambda Calculus}
originally published 1986. This version of the paper was typed out in 2025/26 by Pete Su.} 
\\ \\ \small INRIA}


\maketitle

\noindent
The purpose of these notes is to propose an equational framework for the formalization, and
ultimately the mechanization, of categorical reasoning. This framework is explained by way of
example in the axiomatization of cartesian closed categories. The relationship with intuitionistic
sequent calculus and lambda calculus is explained.

\section{The Equational Nature of Category Theory}%

Category theory reasoning proves equality of arrow compositions, as determined by diagrams. The
corresponding equality is given in the model, {\it i.e.} in the category under consideration. But the
proofs do not appeal to any particular property of the equality relation, such as extensionality. All
we assume is that equality is a congruence with respect to the arrow operators.

However we are not dealing with simple homogeneous equational theories, but with typed
theories. For instance, every arrow is equipped with its type $f : A \to B$. Here $A$ and $B$ are
expressions denoting objects. These expressions are formed in turn by functorial operations and
constants representing distinguished objects. The object terms can be considered untyped only
within the context of one category. As soon as several categories are concerned, we must type
the objects as well, with sorts representing categories. We thus have implicitly two levels of type
structure.

The main difference between typed theories and untyped ones is that in untyped (homogeneous)
theories one usually assume the domain of discourse to be non-empty. For instance, a first-order
model has a non-empty carrier. Thus a variable always denotes something. In typed theories one
does not usually make this restriction. Thus we do not want to impose the $\Hom$-set $A\to B$ to be
always non-empty for every $A$ and $B$ in the category, in the same way that we want to consider
partial orderings.

This has an unfortunate consequence: the law of substitution of equals for equals does not hold
whenever one substitutes an expression containing a variable universally quantified over an empty
domain by an expression not containing this variable, since we replace something that does not
denote by something which may denote. For instance, 
consider the signature $H : A \to B$, with $T:B$, $F:B$,
and the equations $H(x) = T$ and $H(x) = F$. These equations are valid in the model
where $A$ is the empty set, $H$ is the empty function,
and $B$ is a set of two elements $\{0,1\}$, with $T$
interpreted as $\one$ and $F$ interpreted as $0$. 
In this model we do not have $T= F$. We shall have to
keep this problem in mind in the following.

\subsection{The General Formalism}

We have thus a formalism with four levels. At the first level, we have the alphabet of categories
$\Cat= \{\AC,...,\ZC\}$. At the second level, we have the alphabet of object operators. Every category
is defined over an object alphabet $\Phi$ of operators given with an arity. $\Phi$ is where the (internal)
functors live. We then form {\it sequents} by pairs of terms 
$ M \imp N$, with $M,N \in \TC(\Phi,V)$. $V$ is a set
of variables denoting arbitrary objects of the category. At the third level we have the alphabet $\Sigma$
of arrow operators. An operator from $\Sigma$ is given as an inference rule of the form:
\[
S_1,\dots,S_n \ent S
\]
where the $S_i$’s and $S$ are sequents. Such an operator is {\it polymorphic} over the free variables of the
$S_i$’s and $S$, which are supposed to be universally quantified over the inference rule. Such operators
are familiar from logic, either as schematic inference rules, or as (definite) Horn clauses. Of course
the arrows with domain $M$ and codomain $N$ are represented as terms over $\TC(\Sigma,F)$ of type $M \imp N$.
Here $F$ is a set of arrow variables, indexed by sequents $A\imp B$. Finally, at the fourth level we have
the proofs of arrow equalities. The alphabet consists of a set $\cal R$ of conditional rules of the form:
\[
f_{1} =_{S_{1}} g_{1}, \dots, f_{n} =_{S_{n}} g_{n}\, \entt \, f =_{S} g
\]
Here the $f$’s and $g$ are arrow expressions of type $S$, and similarly for the $f_i$’s and $g_i$’s. 
All object and arrow variables appearing in the rule are supposed to be universally 
quantified in front of the rule.

\subsection{A Simplified Formalism}
From now on, we shall assume that we are in one category of discourse which is left implicit. We shall therefore deal only with the last three levels. Furthermore, we shall assume that the only proof rules are:
\begin{align*}
\text {{\it Refl}:}\, f&=_{A \rightarrow B} f \\
\text {{\it Trans}:}\, f&=_{A \rightarrow B} g, \, g=_{A \rightarrow B} h\, 
\models\, f=_{A \rightarrow B} h \\
\text {{\it Sym}:}\, f&=_{A \rightarrow B} g \, \models\, g=_{A \rightarrow B} f
\end{align*}
together with the rules stating that $=$ is a congruence with respect to the operators in $\Sigma$, all other rules being given by simple identities, i.e. by rules with an empty set of premisses ($n=0$).

The further simplification comes from the realization that we are not really obliged to completely specify the types of all variable arrows and equalities, since there is a lot of redundancy. This fact exploits unification, and the following:

\subsubsection*{Meta-theorem}

Let $\Sigma$ be an arbitrary arrow signature, and $E$ be an arbitrary term formed by operators from $\Sigma$ and untyped variables. If there is an assignment of types to the variables of $E$ that makes $E$ well-typed with respect to $\Sigma$, there is a most general such assignment, independent in each variable, and furthermore the resulting type of $E$ is most general. Here ``more general'' means ``has as substitution instance''. We call this assignment, together with the resulting type of $E$, the {\it principal} typing of $E$. More generally, for every type sequent $S$, if there is an assignment of types which makes $E$ of a type some instance of $S$, there is a principal such assignment.

The meta-theorem above is most useful. It permits us to omit most of the types. When we write
an equation $E= E'$, we shall implicitly refer to the principal typing giving $E$ and $E'$ 
the same type $A\imp B$. So from now on, all equations in $\R$ 
are written without type, the types being implicit
from the principality assumption.

\subsection{The initial theory Categ}

We are now ready to start Category Theory. The initial theory $\CC$ has $\Phi = \emptyset$,
and $\Sigma = \{\Id,\compseq{\_}{\_} \}$, given with respective signatures:
\begin{align*}
\Id &: A \imp A\\
\compseq{\_}{\_}&: A \imp B, B \imp C \, \ent A \imp C
\end{align*}
The notation ``$\compseq{\_}{\_}$'' means that we use the infix notation $\compseq{f}{g}$
for the composition of arrows $f$ and $g$. We can read ``$\!f$ {\it then} $g$'',
and follow arrow composition along diagrams with semi-colon as
concatenation of the labels. But since more people are accustomed to the standard set-theoretic
composition notation, we shall below use $g\comp f$ as an abbreviation for $\compseq{f}{g}$.

The equations $\R$ of $\CC$ are simply the laws of a monoıd:
\begin{align*}
\Assoc &: (f \comp g) \comp h = f \comp (g \comp h)\\
\Idl &: \Id \comp f = f\\
\Idr &: f \comp \Id = f
\end{align*}

It is to be noted that the identification of the Hom-set symbol $\imp$ with the sequent entailment
arrow is not fortuitious. Actually $\Id$ and $\compseq{\_}{\_}$
are well-known inference rules of intuitionistic propositional calculus.
However, the logic is quite poor at this stage: we have no propositional connective
whatsoever, just the basic mechanism for sequent composition, 
stating that entailment is reflexive
and transitive. The rules of $\R$, considered as a left-to-right
rewriting system, define a normal form
on the sequent calculus proofs, i.e. on the arrow expressions

Before we embark on more complicated theories, let us give a recipe on how to cook an equational
presentation from a categorical statement.

\subsection{What the Category Theorists Don’t Say}


Open a standard book on category theory, and consider a typical categorical definition.
It usually reads: ``Mumble, such that the following diagram commutes.''
Similarly, a typical categorical result states: 
``If $\,\text{\it diagram}_1$ and ... and $\text{\it diagram}_n$ commute, then {\it diagram}
commutes.''
The first step in understanding such statements is to determine exactly their universality:
what is exactly quantified, universally or existentially, what depends on what,
what are exactly the parameters of the (frequent) unicity condition.
The next step is to realize that the diagram states conditional
equalities on arrows, and that it is enough to state the equalities
of the inside diagrams in order to get all equalities.

A uniform compilation of such statements as an equational theory proceeds as follows.
First write completely explicitly the quantification prefix of the statement, in two
lines, one for the objects and one for the arrows. Then Skolemize the statement
independently in the first and the second line. That is, for every existentially
quantified variable $x$ following the universally quantified $y_1, \ldots y_n$, introduce
a new $n$-ary operator $X$ and substitute throughout $x$ by $X\left(y_1, \ldots
y_n\right)$. The Skolemization of the object variables determines $\Phi$. The
Skolemization of the second line, together with the types implicit from the diagram
determine $\Sigma$. Finally, following arrows around the inner diagrams determines
$\R$. This concerns the {\it existential} part. For the {\it unicity} part, proceed as
follows. Let $f$ be the arrow whose unicity is asserted. The existence part provided by
Skolemization an $F\left(g_1, \ldots, g_k\right)$ in place of $f$. Write a supplementary
arrow $h$ on the diagram parallel to $f$, and use the commutation conditions to eliminate
all the $g_i$'s as $G_i(h)$. Add an extra equation $F\left(G_1(h), \ldots,
G_k(h)\right)=h$.

Once we have convinced ourselves that the category theoretic statements and proofs are of
an equational nature, we may ask: why do the category theorists use diagrams at all? The
reason is that diagram chasing is a sophisticated way of doing complex equality reasoning,
using several equations simultaneously, on a shared data structure (the graph underlying
the diagram). So diagrammatic reasoning may be considered a good tool for high level
equational reasoning. On the other hand, equality reasoning techniques such as rewrite
rules analysis is good for mechanical implementation, and this is why we stress here the
equational theories hidden behind the diagrams. 

\bigskip\noindent
{\bf Remark}. Let us finally remark that more
general categorical concepts than the simple universal statements that we shall now
consider may force us to generalize the basic formalism. For instance, more complicated
limit constructions such as pullbacks force the dependence of objects on arrows. The
Skolemization cannot be eﬀected separately on the object and the arrow variables, and we
shall have to place ourselves in a more complicated type theory with dependent types.

\section{Products}

\subsection{The Theory Prod}

We shall apply the recipe above to the definition of product in a category. We recall that a category
possesses a product if for all objects $A$,$B$ there exists an object $C$ and there exist arrows
$\fst$, $\snd$ such that for every object $D$ and all arrows $f$, $g$ 
there exists a unique arrow $h$ such that the
following diagram commutes:

\tikzcdset{arrow style=tikz, diagrams={>=latex}}
\begin{center}
\begin{tikzcd}[column sep=huge, row sep=5.5em]
A \arrow[thick, r, "\fst"] & C  \arrow[thick, r, "\snd"]& B \\
 & \arrow[thick, ul, "f" {xshift=2pt}] D \arrow[thick, u, "h" {right}] 
 \arrow[thick, ur, "g" {below, yshift = -3pt} ] &
\end{tikzcd}
\end{center}
We now get the theory $\Prod$ by enriching $\CC$ as follows. The Skolemization of $C$ gives the
binary functor $\times$, and we write with the infix notation 
$A \times B$ in place of $C$. So now $\Phi$ = $\{\times\}$.
Similarly, we add to $\Sigma$ the following operators,
issued respectively from $\fst$, $\snd$ and $h$:
\begin{align*}
\fst &: A \times B \imp A\\
\snd &: A \times B \imp B\\
\emptypair &: D\imp A \text{ , } D \imp B \,\ent\, D \imp A \times B
\end{align*}
and we now have the usual diagram:
\tikzcdset{arrow style=tikz, diagrams={>=latex}}
\begin{center}
\begin{tikzcd}[column sep=huge, row sep=5.5em]
A \arrow[thick, r, "\fst"] & A \times B  \arrow[thick, r, "\snd"]& B \\
 & \arrow[thick, ul, "f" {xshift=2pt}] D \arrow[thick, u, "\pair{f}{g}" {right,yshift=8pt}] 
 \arrow[thick, ur, "g" {below, yshift = -3pt} ] &
\end{tikzcd}
\end{center}
The existence of $h$, that is the commutation of the two triangles,
gives two new equations in $\R$:
\begin{align*}
\pi_1 &: \fst \comp \pair{f}{g} = f\\
\pi_2 &: \snd \comp \pair{f}{g} = g
\end{align*}
Unicity of $h$ gives one last equation:
\[
\text{\it Unipair} : \pair{\,\fst \comp h}{\,\snd \comp h} = h
\]
The arrow part of the functor $\times$ may be defined as a derived operator as follows:
\begin{align*}
\_ \times \_  &: A\imp B , \, C \imp D \, \ent \, A\times C \imp B \times D\\
\text{\it Def } \times &: f \times g = \pair{\,\fst \comp f}{g\comp \snd}
\end{align*}

\bigskip\noindent
{\bf Remark}. There is a possible source of confusion in our terminology. We talked about the elements
of $\Phi$ as functors. Actually these are just function symbols denoting object constructors. 
Skolemization of a diagram will determine certain such function symbols,
but there is no guarantee that
there will be a corresponding functor. For instance,
for product, we had to define the arrow part
of $\times$ above, and to verify that indeed it obeys the functorality laws.

\subsection{The Logical Point of View}

From the logical point of view, specifying a product amounts to defining conjunction. 
Read $A \times B$ as $A \sland B$, and recognize $\fst$, $\snd$ and $\pair{-}{-}$ as respectively 
$\sland$-elim-left, $\sland$-elim-right, and $\sland$-intro respectively \cite{7,15,24}.

The rules of $\R$ have a computational meaning: they specify how to reduce a proof to its normal form.
Here we may apply known results from the theory of term rewriting systems,
in order to complete $\R$ to a {\it canonical} system \cite{17,9}.

The Knuth-Bendix completion procedure, when applied to theory {\bf Prod}, generates two additional rewrite rules:

\begin{align*}
\Id &: \pair{\fst}{\snd} = \Id \\
\text{\it DistrPair} &: \pair{f}{g}\comp h = \pair{f \comp h}{g \comp h}
\end{align*}
The resulting system $\R$ is canonical, and can be used to decide the equality
of arrows in the theory {\bf Prod}. Of course, the equations above do not
modify the theory, since they have been obtained by equational reasoning.

Finally, let us note that other presentations of the same theory is possible.
For instance, we could have obtained product as the right adjoint of the
diagonal functor. The unit of this adjunction is the 
{\it duplicator}, which may be defined here as:
$$
D = \pair{\Id}{\Id}
$$
Note that type-checking imposes that the two identities are the same, so that $D_A: A \imp A \times A$.
As its name suggests, the duplicator duplicates, in the sense that we can
prove $D \comp f = \pair{f}{f}$.
The co-unit of the adjunction is the pair of projections $(\fst, \snd)$.

\subsection{Finite products}

We say that a category admits all finite products if it admits products and a terminal object.
Equationally, this amounts to enriching the theory {\bf Prod} to a theory {\bf Prods} by adding
a constant $1$ to $\Phi$, a polymorphic constant $\Nil : A \imp 1$ to $\Sigma$,
and a unicity equation $\Unii$ to $\R$:
$$
\Unii : h = \Nil.
$$
Note that this does not make the equational theory inconsistent: 
the variable $h$ above is principally typed to $A\imp 1$.
However this equation brings up two problems. The first one is the one mentioned
in the beginning of these notes, since variable $h$ appears on the left but not on the right of $\Unii$.
The second problem is that $\Unii$ cannot be considered as a term rewriting rule in the usual sense,
since it would rewrite $\Nil$ to itself and therefore does not satisfy the finite termination criterion.
Note that $\Unii$ entails with the other equations two consequences:

\begin{align*}
\text{\it Zero} &: f \comp \Nil = \Nil\\
\text{{\it Id}}_1 &: \Id = \Nil
\end{align*}
Again, ${\Id}_1$ does not identify every $\Id$ with every $\Nil$,
but only (restoring explicit types) $\Id_1$
with $\Nil_1$. Now it may be checked that $\Unii$ is actually a
consequence of $\text{\it Zero}$
and ${\Id}_1$. The rule $\text{\it Zero}$ is a bona fide rewrite rule, 
which leaves the special equality $\text{{\it Id}}_1$ to be dealt with in an ad hoc
fashion.

Using operators $\times$ and $1$ we may now construct $n$-tuples of
objects, which we shall call {\it contexts}. $1$ is the empty context, 
and if $E$ is a context of length $n$ and $A$ an object term, 
$E \times A$ is a context of length $n+ 1$. 
We write $|E|$ for the length of a context.
If $C$ is the current set of (representable)
objects, i.e. $\TC(\Phi,V)$, we denote by $C^*$ be the set of contexts.

If $1 \leq i \leq |E|$, we define the $i^{th}$ component $E_i$ of $E$ recursively, as:
\[
\begin{array}{lcll}
(E \times A)_i  & = &
E_{i-1} &\text{ if } i > 1\\
&& A &\text{ if } i = 1
\end{array}
\]
If $E$ and $E'$ are contexts, we define their concatenation $E@E'$ as a context recursively:
\begin{align*}
E@1 & = E \\
E@(E' \times A) & = (E@E') \times A.
\end{align*}
Similarly, using operators $\la$ , $\ra$ and $\Nil$ we may construct lists, or $n$-tuples of arrows of
some domain $D$. The empty arrow list is $\Nil$, of length $0$ and if $L : D \imp E$ is an arrow list of
length $n$ then $\pair{L}{f} : D \imp E \times A$ is an arrow list of length $n+ 1$,
for every $f : D\imp A$. Finally,
for every object list and every $n$, with $1 \leq n \leq |E|$ we define recursively the projection arrow
$\pi_{E} (n) : E \imp E_n$, as:
\[
\begin{array}{lcll}
\pi_{E} (n) & =&  
\pi_{E'}(n)\comp \fst & \text { if } n > 1 \text{ and } E = E' \times A\\
&& \snd & \text{ if } n= 1
\end{array}
\]

\section{CCC}

\subsection{The Theory Exp}

We obtain the theory {\bf Exp} by enriching the theory {\bf Prods} as follows. First, we add a binary
operator $\impl$ to $\Phi$. Next we add two operators to $\Sigma$, the constant ${\App}$
(application) and the unary operator $\abs{}$ (abstraction):
\begin{align*}
{\App} & : (B \impl C) \times B \imp C\\
\abs{} &: A \times B \imp C \ent A\imp (B \impl C)
\end{align*}
Finally, we add the following equations to $\R$:
\begin{align*}
{\text{\it ExAbs}} & :\, \App \comp (\abs{} f \times \Id) = f\\
{\text{\it UniAbs}} &:\, \abs{}(\App \comp (f \times \Id)) = f
\end{align*}
As before, this equational theory may be mechanically generated from the following diagram:
\begin{center}
\begin{tikzcd}[column sep=5em, row sep=7em]
 B \impl C &[-5.5em] \times &[-5.5em] B  \arrow[thick, r, "\App"]& C \\
 A  \arrow[thick, u, "\abs{}\! f" {right}] & \hskip-1em \times  & B  \arrow[thick, u, "\Id" {right,yshift = 1em}] 
 \arrow[thick, ur, "f" {below, yshift = -3pt} ] &
\end{tikzcd}
\end{center}
The logical point of view is here that $\impl$ is the (intuitionistic) implication. The operator $\App$
is $\impl$-elimination%
\footnote{Editor's note: the original paper has this as an introduction rule,
which can't be right. So I fixed it.}.
It plays the role of the Modus Ponens inference rule (although here it is a
constant, and not a binary operator). Abstraction is $\impl$-introduction%
\footnote{So of course I had to fix this one too},
and plays somewhat the role of the deduction theorem.

Let us give a few equational consequences of the theory {\bf Exp}:
\begin{align*}
{\text{\it IdExp}} & : \abs{} \App = \Id\\
{\text{\it Red}}_1 & : \App \comp \la \abs{} f \comp y, x\ra = f\comp\la y, x\ra \\
{\text{\it Red}} & : \App \comp \la\abs{} f, x \ra = f\comp\la \Id , x\ra \\
{\text{\it DistrAbs}} & : \abs{} f \comp g = \abs{}(f \comp (g \times \Id ))
\end{align*}
We can also show that abstraction is a bijection between the arrows of A×B →C and those
of $A \imp B \impl C$, with inverse:
$$
{\abs{}}^{-1}\, f = \App \comp \la f \times \Id \ra
$$
Thus we could have presented {\bf Exp} in terms of $\abs{}$ and ${\abs{}}^{-1}$, and defined $\App$
as ${\abs{}}^{-1}\Id$. This corresponds to the fact that we could have rather axiomatized 
exponentiation by an adjunction to the product, whose co-unit is $\App$ (the unit being $\abs{} \Id$ ).

Finally, we define the arrow part of the functor $\impl$ (which is contravariant in its first argument)
as:
$$
f \impl g = \abs{}(g\comp \App \comp (\Id \times f)).
$$

\section{Lambda-calculus}

Sometimes $\abs{}$ is called ``Curryfication'', in honor of Curry. In fact there is an important relation
between combinatory logic and CCC’s, which we shall exhibit on $\l$-calculus.

\subsection{The $\l$-terms}

We assume that the current theory is an extension of {\bf Exp}.
We define recursively a relation $E \ent M : A$, read ``$M$ is a {\it term} of type $A$
in the {\it context} $E$'',
where $A \in \C$ and $E \in \C^*$, as follows:
\begin{align*}
\text{\bf Variable} &: \text{If } 1 \leq n \leq |E| \text{ then } E\ent n: E_n\\
\text{\bf Abstraction} &: \text{If } E \times A \ent M : B \text{ then } E \ent \abs{A}M : A \impl B\\
\text{\bf Application} &: \text{If } E \ent M: A \impl B \text{ and } E \ent N
\text{ then } E \ent (M N) : B
\end{align*}
Thus a term may be a natural number, or may be of the form $\abs{A}M$ with $A$ an object and $M$
a term, or may be of the form $(M N)$ with $M, N$ two terms.

We thus obtain $\l$-terms typed with objects of the CCC currently axiomatized. Variables are
coded as de Bruijn's indexes \cite{2}. i.e. as integers denoting their reference depth (distance in the
tree to their binder). This representation avoids all the renaming problems associated with actual
names ($\alpha$ conversion), but we shall use such names whenever we give examples of terms. For
instance, the term $\abs{A} (1\, \abs{B}(1 2))$ shall be presented under a concrete representation such as
$\abs{x : A} (x \abs{y : B} (y x))$. In Church's original notation, the left bracket was a $\l$ and the right
bracket a dot, and typing was indicated by superscripting, like: $\l x^A\cdot (x \l y^B \cdot (y x))$.

Note that the relation $E \ent M : A$ is functional, in that $A$ is uniquely determined from $E$ and $M$.
Thus the definition above may be interpreted as the recursive definition of a function $A = \tau_E(M)$.

\subsection{A Translation From $\l$-terms to CCC Arrows}

We shall now show how to translate $\l$-terms to CCC arrows. More precisely, to every term $M$ such
that $E \ent M : A$ we associate an arrow $F_E(M) : E \imp A$ as follows:
\begin{align*}
F_E (n) &= \pi_E (n)\\
F_E (\abs{A} M) &= \abs{} F_{E \times A}(M)\\
F_E ((M\, N)) &= \App \comp \la F_E (M) , F_E (N) \ra
\end{align*}
It can be easily proved by induction that $F_E(M)$ is a well-typed arrow expression.

\medskip
\noindent
{\bf Example}. The closed term $M = \abs{f : \nat \impl \nat }
\abs{x : \nat}(f\, (f\, x))$ of type $A = (\nat \impl
\nat) \impl (\nat\impl \nat)$ in the empty context $E = 1$, gets translated to:
$$
F_E (M) = \abs{} \abs{} (\App\comp \la \snd \comp \fst, 
\App \comp \la \snd \comp \fst, \snd\ra \ra) : 1 \imp A.
$$

\subsection{The syntactic theory of terms}

The advantage of the name-free terms is that we have no name conflict. The disadvantage is that
we have to explicate relocation operations for terms containing free variables. For instance, let
us define for every term $M$ the term $M^{+n}$ obtained in incrementing its free variables by $n$. Let
$M^{+n} = R^0_{n}(M)$, with:
\[
\begin{array}{rcll}
R^i_n(k) & = & k & \text{ if } k \leq i\nonumber\\
&& k + n & \text{ if } k > i\nonumber\\
R^i_n(\abs{A} M) &=& \abs{A} R^{i+1}_n (M)\nonumber\\
R^i_n((M N)) &=& (R^i_n(M) R^i_n(N)).\nonumber
\end{array}
\]
The reader will check that $E\ent M : A$ if and only if $E@E' \ent M^{+n} : A$, where $E'$
is an arbitrary context of length $n$.

We now define {\it substitution} to free variables. Let $E\times A \ent M : B$, and $E\ent N : A$. We shall
define a term $M\{N\}$, and show that $E \ent M\{N\}: B$. First we define recursively:
\[
\begin{array}{rcll}
\sigmaN & = & k + 1 & \text{ if } k < n \\
 &  & N^{+n} & \text{ if } k = n \\
 &  & k  & \text{ if } k > n \\
\sigmaN(\abs{A}M) & = & \abs{A}\Sigma^{n}_{n+1} (M)\\
\sigmaN(M\, M') &=& (\sigmaN(M) \, \sigmaN(M') )
\end{array}
\]
It is easy to show that substitution preserves the types,
in the sense that $(E \times A)@E' \ent M : B$
and $E \ent N : A$ implies $E@E' \ent \sigmaN(M) : B$ with
$n = |E'|$.

Now we define $M{N} = \Sigma^0_N(M)$
and we get that $\tau_E (M\{N\}) = \tau_{E \times A}(M)$,
with $A= \tau_E (N)$.

We are now ready to define the {\it computation} relation $\comptr$ as follows:
\begin{align*}
(\abs{A}M\, N) & \comptr M\{N\} \tag{$\beta$}\\
M \comptr M' & \impl \abs{A}M \comptr \abs{A}M' \tag{$\xi$}\\
M \comptr M' & \impl (M \, N) \comptr (M' \, N)\\
M \comptr M' & \impl (N \, M) \comptr (N \, M')
\end{align*}
It is clear that computation preserves the types of terms. But it also preserves their values, in
the sense of the translation to CCC arrows: If $E \ent M : A$ and $M \comptr N$,
then $F_E (M) = F_E (N)$ in
the theory {\bf Exp}, as we shall show.

The computation relation presented above is traditionally called (strong) $\beta$-reduction. It is
confluent and Noetherian (because of the types!), and thus every term possesses a canonical form,
obtainable by iterating computation non-deterministically. Another valid conversion rule is $\eta$-
conversion:
\begin{equation}
\abs{x: A}(M\, x) = M \tag{$\eta$}
\end{equation}
whenever $x$ does not appear in $M$. Let us show that it corresponds to {\it UniAbs},
using our translation above.

First we define the {\it relocation} combinators $\rho(i)$ as follows.
\begin{align*}
\rho(0) &= \fst \\
\rho(i+ 1) &= \rho(i) \times \Id
\end{align*}
It is easy to show that (with appropriate types):
\[
\begin{array}{rlll}
\pi(k) \comp \rho(i) &=& \pi(k) & \text{ if } k \leq i \\
&& \pi(k+1) & \text{ if } k > i
\end{array}
\]
and thus that $R^i_1(M) = M \comp \rho(i)$. As a particular case we get $M+1 = M\rho \fst$ 
and thus we can read the law {\it UniAbs} as $\abs{x}(M^{+1}\, x) = M$. 
Whenever $x$ does not occur in $M$ the expressions $M$
and $M^{+1}$ are concretely identical, and we obtain the $\eta$-conversion rule.
Note however that {\it UniAbs}
is an algebraic law, whereas $\eta$ makes sense only relatively to concrete representations.

We are now going to show that {\it Red} validates the $\beta$-reduction rule. First we define the 
{\it substitution} combinators as follows.
\begin{align*}
\sigma_N (0) &= \la \Id, N \ra\\
\sigma_N (n+ 1) &= \sigma_N (n) \times \Id
\end{align*}
Next we check that for all $\l$-terms $M$ and $N$ and every integer $n$
the following equation is provable in {\bf Exp}
(confusing $M$ with $F(M)$, and assuming types are correct):
$$
\sigmaN(M) = M \comp \sigma_N(n)
$$
This suggests defining in {\bf Exp} the derived operator:
$$
\_ \{ \, \_ \, \} : A \times B \imp C , \, A\imp B \ent A \imp C
$$
with defining equation:
$$
\text{\it Subst} : f\{x\} = f\comp \la \Id, x \ra
$$
and now the rule {\it Red} reads:
$$
\App \comp \la \abs{} f, x \ra = f \{x \}
$$
which clearly validates the computation relation $\comptr$.

CCC arrows are richer than $\l$-terms. This suggests enriching $\l$-calculus with further operators
$\fst$, $\snd$, {\it pair}, {\it nil}, with appropriate supplementary
reduction rules, and to allow ``varstruct'' binding
in order to have variables correspond to arbitrary sequences of $\fst$ and $\snd$, as opposed to just
integers coded up in unary notation. For instance, ML (without recursion) can be translated into
CCC arrows by a simple extension of the translation $F$ above. Actually, such a translation is the
basis for an eﬃcient implementation of the language \cite{3}.

\subsection{The CCC Word Problem}

The {\bf Exp} theory above is decidable \cite{27}. Unfortunately, no canonical system is known for the full
theory. An interesting sub-theory is obtained by restricting $\R$ to the set
$$
\R_1 = \{\text{\it Ass}, \text{\it Idl}, \text{\it Idr}, \pi_1, \pi_2,
 \text{\it DistrPair}, \text{\it IdPair}, \text{\it UniPair}, \text{\it Red}, 
 \text{\it DistrAbs}\}
$$
Considered as a (typed) term-rewriting system, $\R_1$ is locally confluent. This can be mechanically
checked by the Knuth-Bendix decision procedure \cite{9}. Note that this is possible because a system
such as $\R_1$ may be considered an (untyped) equational theory in the ordinary sense, by mixing the
arrow structure and the object structure as follows: every arrow sub-term $M$ of type $A \imp B$ is
represented as $: (M,A,B)$, where $:$ is a special ternary function symbol. Note that variables in the
type subparts get instanstiated by matching and unification, in the same way as the variables in the
arrow subparts. This supports our view of the polymorphic nature of the categorical combinators.

We conjecture $\R_1$ to be Noetherian, and thus confluent.
It would be interesting to have the termination argument
formulated as to showing that the rewriting relation is a well-partial-ordering.
However, note that this argument cannot work on the $\Sigma$-trees alone,
since the corresponding untyped system is strong enough to code the 
$\beta$-reductions of untyped $\l$-calculus. 
We remark that Klop has shown \cite{16} that $\l$-calculus with surjective pairing
is not Church-Rosser; however, his proof
cannot be easily adapted to show that the untyped version of $\R_1$ is not confluent.
Another interesting locally confluent subtheory is:
$$
\R_2 = \{\text{\it Ass}, \text{\it Idl}, \text{\it Idr}, \pi_1, \pi_2,
 \text{\it DistrPair}, \text{\it IdPair}, \text{\it UniPair}, \text{\it Red}, 
 \text{\it Red}_1 \}.
$$
The state of the art in the theory of categorical combinatory algebra and its relations with
various $\l$-calculi can be found in Curien’s extensive monography [6].

\subsection{Possible Extensions}

It is also possible to enrich the type structure with sums, corresponding to categorical co-product.
The {\bf Exp} theory is enriched with injections and a conditional operator. The corresponding models
are the bi-cartesian closed categories.

Finally, we may postulate the existence of a universal object $U$ and build the full untyped
$\l$-calculus in the manner of Scott, as described in \cite{25}.

That is, we postulate a retract pair between $U$ and $U \imp U$:
\begin{align*}
\text{\it Quote} &: (U \impl U) \imp U\\
\text{\it Eval} &: U \imp (U \impl U)
\end{align*}
verifying:
$$
\text{\it Retract}: \text{\it Eval}\comp\text{\it Quote} = \Id.
$$
Let us call {\bf Univ} the theory obtained by the corresponding enrichment of Exp.
We may now translate any $M \in \l_n$ as an arrow $A_n(M) : U^n \imp U$ as follows:
\begin{align*}
A_n(k) &= \pi_{U^n}(k)\\
A_n(\abs{} M) &= \text{\it Quote}\comp \abs{} A_{n+1}(M)\\
A_n((M\, N)) &= \App \comp \la \text{\it Eval}\comp A_n(M) , A_n(N) \ra.
\end{align*}
We leave it to the reader to check that the $\beta$ rule is still an equational consequence of {\bf Univ}.
However, note that the $\eta$ rule is not valid anymore,
since it would entail that {\it Eval} and {\it Quote} define
an isomorphism between $U$ and $U\impl U$.

\medskip
\noindent
{\bf Caution}. Some combinations of the above extensions may be incompatible, in that they may lead
to an inconsistency, in the sense that the only model of the extended theory is the trivial category
1. For instance, Lawvere showed that the theory of bi-cartesian closed categories with fixpoints is
inconsistent \cite{13, 20}.

\section*{Acknowledgements}

The general formalization was developped in 1983, after listening in Sophia-Antipolis to a talk by
P.L. Curien on categorical combinators. The translation from 4.2 was derived after the author
noticed the close connection between the categorical operators of Lambek \cite{18} and de Bruijn’s
nameless notation for $\l$-calculus \cite{2}. Instrumental to this was a close study of the ML compiler
developed by Lockwood Morris for the LCF project \cite{8}. The syntactic theory from 4.3 is similar to
the formalization of Automath by Jutting \cite{14}, except that the absence of dependent types makes
things a little simpler. This treatment of $\l$-calculus computation was the basis of the author’s
implementation in ML of the Calculus of Constructions \cite{4}. The author acknowledges numerous
discussions on categorical combinators with P.L. Curien, A. Poign\'e and D. Scott.


\section*{References} 

\pdfbookmark{References}{bib}
\def\bb#1{\bibitem[#1]{#1}}

\begin{enumerate}[leftmargin=*, widest=8888, align=left]

\bb{1} H. Barendregt, {\it The Lambda-Calculus: Its Syntax and Semantics}, North-Holland (1980).

\bb{2} N.G. de Bruijn, ``Lambda-Calculus Notation with Nameless Dummies, a Tool for Automatic
Formula Manipulation, with Application to the Church-Rosser Theorem.'' Indag. Math. 34, 5
(1972), 381–392.

\bb{3} G. Cousineau, P.L. Curien and M. Mauny, ``The Categorical Abstract Machine.'' In Functional
Programming Languages and Computer Architecture, Ed. J. P. Jouannaud, Springer-Verlag
LNCS 201 (1985) 50–64.

\bb{4} Th. Coquand, G. Huet, ``Constructions: A Higher Order Proof System for Mechanizing Mathematics.'' EUROCAL85, Linz, Springer-Verlag LNCS 203 (1985).

\bb{5} P. L. Curien, “Categorical Combinatory Logic.” ICALP 85, Nafplion, Springer-Verlag LNCS
194 (1985).

\bb{6} P. L. Curien, “Categorical Combinators, Sequential Algorithms and Functional Programming.”
Monography to appear, Pitman (1985).

\bb{7} G. Gentzen “The Collected Papers of Gerhard Gentzen.” Ed. E. Szabo, North-Holland, Am-
sterdam (1969).

\bb{8} M. J. Gordon, A. J. Milner, C. P. Wadsworth, “Edinburgh LCF” Springer-Verlag LNCS 78
(1979).

\bb{9} G. Huet, “Confluent Reductions: Abstract Properties and Applications to Term Rewriting
Systems.” J. Assoc. Comp. Mach. 27, 4 (1980) 797–821.

\bb{10} G. Huet, “Initiation \`a la Th\'eorie des Cat\'egories.” Polycopi\'e de cours de DEA, Universit\'e Paris
VII (Nov. 1985).

\bb{11} G. Huet, “Deduction and Computation.” in Fundamentals in Artificial Intelligence, Eds. W.
Bibel and Ph. Jorrand, Springer-Verlag Lecture Notes in Computer Science vol. 232 (1986)
39–74.

\bb{12} G. Huet, “Formal Structures for Computation and Deduction.” In preparation.

\bb{13} H. Huwig and A. Poign\'e, “A note on inconsistencies caused by fixpoints in a cartesian closed
category.” Personal communication (April 1986).

\bb{14} L.S. van Benthem Jutting ``The language theory of $\Lambda_\infty$, 
a typed $\l$-calculus where terms are types.'' Personal communication (1984).

\bb{15} S.C. Kleene, {\it Introduction to Meta-mathematics}, North Holland (1952).

\bb{16} J.W. Klop {\it Combinatory Reduction Systems}, Ph.D Thesis, Mathematisch Centrum Amsterdam (1980).

\bb{17} D. Knuth, P. Bendix, “Simple word problems in universal algebras”. In: Computational Prob-
lems in Abstract Algebra, J. Leech Ed., Pergamon (1970) 263–297.

\bb{18} J. Lambek, ``From Lambda-calculus to Cartesian Closed Categories.'' in To H. B. Curry:
Essays on Combinatory Logic, Lambda-calculus and Formalism, Eds. J. P. Seldin and J. R.
Hindley, Academic Press (1980).

\bb{19} J. Lambek and P. J. Scott, “Aspects of Higher Order Categorical Logic.” Contemporary Math-
ematics 30 (1984) 145–174.

\bb{20} F. W. Lawvere “Diagonal Arguments and Cartesian Closed Categories.” in Category Theory,
Homology Theory and their Applications II, Springer-Verlag Lect. Notes in Math. 92 (1969).

\bb{21} S. Mac Lane, {\it Categories for the Working Mathematician}, Springer-Verlag (1971).

\bb{22} C. Mann, “The Connection between Equivalence of Proofs and Cartesian Closed Categories.”
Proc. London Math. Soc. 31 (1975) 289–310.

\bb{23} A. Poign\'e, {\it On Semantic Algebras}, Universitat Dortmund (March 1983).

\bb{24} D. Prawitz {\it Natural Deduction}, Almqist and Wiskell, Stockolm (1965).

\bb{25} D. Scott, “Relating Theories of the $\l$-Calculus.” in To H. B. Curry: Essays on Combi-
natory Logic, Lambda-calculus and Formalism, Eds. J. P. Seldin and J. R. Hindley, Academic
Press (1980).

\bb{26} S. Stenlund, {\it Combinators $\l$-terms, and proof theory}, Reidel (1972).

\bb{27} M. E. Szabo, {\it Algebra of Proofs}, North-Holland (1978).

\end{enumerate}




















