% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[11pt,
  american,
  DIV13]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
  \setmainfont[]{Palatino}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}

\usepackage[papersize={7.5in, 10.0in}, left=.5in, right=.5in, top=1in, bottom=.9in]{geometry}
\linespread{1.05}

\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Haskell for Readers},
  pdfauthor={Joachim Breitner, DFINITY Foundation},
  pdflang={en-US},
  colorlinks=true,
  ,breaklinks=true
,urlcolor=blue
,anchorcolor=blue
,citecolor=blue
,filecolor=blue
,linkcolor=blue
,menucolor=blue
,linktocpage=true,
  pdfcreator={LaTeX via pandoc}}
\hypersetup{
bookmarksopen=true,
bookmarksnumbered=true,
bookmarksopenlevel=10
}

\usepackage[small]{titlesec}
\usepackage{cite}

% make sure there is enough TOC for reasonable pdf bookmarks.
\setcounter{tocdepth}{3}

\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
% Make links footnotes instead of hotlinks:
\DeclareRobustCommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}

\usepackage{fontspec}
\usepackage{MnSymbol}
\usepackage[verbose]{newunicodechar}
\newunicodechar{☆}{$\smallstar$}
\newunicodechar{λ}{$\lambda$}
\newunicodechar{∘}{$\circ$}
\newunicodechar{█}{$\blacksquare$}
\newunicodechar{⟹}{$\Longrightarrow$}

\usepackage{newunicodechar}
\newfontfamily{\fallbackfont}{Klee}[Scale=MatchLowercase]
\DeclareTextFontCommand{\textfallback}{\fallbackfont}
\newunicodechar{☃}{{\textfallback{☃}}}
\newunicodechar{ツ}{{\textfallback{ツ}}}

\ifXeTeX
  % Load polyglossia as late as possible: uses bidi with RTL langages (e.g. Hebrew, Arabic)
  \usepackage{polyglossia}
  \setmainlanguage[variant=american]{english}
\else
  \usepackage[main=american]{babel}
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\fi
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Haskell for Readers}
\author{\href{http://www.joachim-breitner.de/}{Joachim Breitner},
\href{https://dfinity.org/}{DFINITY Foundation}}
\date{}

\begin{document}
\maketitle

\newpage
{
\setcounter{tocdepth}{2}
\tableofcontents
}
\newpage

\phantomsection

\section*{Preface}\label{preface}
\addcontentsline{toc}{section}{Preface}

Welcome to the lecture series ``Haskell for Readers''. This workshop is
uniquely tailored to those who need to \emph{read}, rather than
\emph{write} Haskell code: auditors, scientists, managers, testers etc.

\hypertarget{scope}{%
\subsubsection*{Scope}\label{scope}}
\addcontentsline{toc}{subsubsection}{Scope}

This goal implies a higher focus on syntax (because you can \emph{write}
programs ignoring most syntactic gadgets available to you, but if you
read code, you have to deal with them), types and type signatures
(because they are the key to understanding Haskell code) and abstraction
patterns (because it is key to understanding well-written code, and
Haskell excels at abstraction).

On the other hand, less words will be spent on how to approach writing
the program, e.g.~how to set up your tooling, how to please Haskell's
layout rules, how to design your data type, which libraries to pick, how
to read error messages. That said, we hope that even Haskell programmers
will gain useful insight from this tutorial.

Nevertheless it is hard to understand a programming paradigm without
writing any code, so there will some amount of hands-on work to be done,
especially early on, when we start with an introduction to basic
functional programming.

\hypertarget{form}{%
\subsubsection*{Form}\label{form}}
\addcontentsline{toc}{subsubsection}{Form}

This document is not (necessarily) a self-contained tutorial; it is
rather the base for an interactive lecture, given by a real instructor.
In such a lecture, some holes will be filled as we go, and the questions
from the audience form a crucial part of the learning experience.

This document is also meant to be more on the concise side, assuming the
audience is shorter on time than on wits, and in a small, live workshop,
the lecturer can add details, come up with more examples and slow down
as needed.

This makes these notes less ideal for independent study, but that said,
it should be possible to work attentively through them and still learn a
lot.

There is a printable version of
\href{http://haskell-for-readers.nomeata.de/haskell-for-readers.pdf}{the
whole document} (with solutions at the end), of
\href{http://haskell-for-readers.nomeata.de/haskell-for-readers-exercises.pdf}{just
the exercises} and of
\href{http://haskell-for-readers.nomeata.de/haskell-for-readers-solutions.pdf}{just
the solutions}.

\hypertarget{audience}{%
\subsubsection*{Audience}\label{audience}}
\addcontentsline{toc}{subsubsection}{Audience}

I expect the audience to be familiar with programming and computer
science in general, but do not assume prior knowledge of functional
programming (or, in case you are worried about this, category theory).

The exercises are all very small, in the order of minutes, and are meant
to be done along the way, especially as later material may refer to
their results. If you are reading this on your own and you really do not
feel like doing them, you can click on the blurred solutions to at least
read them. The exercises are not sufficient in number and depth to
provide the reader with the experience needed to really learn Haskell.

Some sections are marked with a ``☆''. These are optional in the sense
that the following material does not rely heavily on them. If time is
short, e.g.~during a workshop, they can be skipped, and the participants
can be invited to come back to them on their own.

\hypertarget{acknowledgments-and-license}{%
\subsubsection*{Acknowledgments and
license}\label{acknowledgments-and-license}}
\addcontentsline{toc}{subsubsection}{Acknowledgments and license}

The creation of this material was sponsored by the
\href{http://dfinity.org/}{DFINITY Foundation}, and is shared with the
public under the terms of the
\href{https://creativecommons.org/licenses/by/4.0/}{Creative Commons
Attribution 4.0 International License}. You can view
\href{https://github.com/nomeata/haskell-for-readers/}{the source on
GitHub} of this document, and submit improvements there.

\newpage

\hypertarget{the-basics-of-functional-programming}{%
\section{The basics of functional
programming}\label{the-basics-of-functional-programming}}

Functional programming is the the art of thinking about \emph{data} and
how the new data is calculated from old data, rather than thinking about
how to \emph{modify} data.

\hypertarget{numbers-and-arithmetic-operators}{%
\subsection{Numbers and arithmetic
operators}\label{numbers-and-arithmetic-operators}}

The simplest form of data is numbers, and basic arithmetic is one way of
creating new numbers from old numbers.

To play around with this, start the Haskell REPL
(``read-eval-print-loop'') by running \texttt{ghci} (or maybe on
\href{https://tryhaskell.org/}{tryhaskell.org}), and enter some numbers,
and some of the usual arithmetic operations:

\begin{verbatim}
$ ghci
GHCi, version 8.4.4: http://www.haskell.org/ghc/  :? for help
Prelude> 1
1
Prelude> 1 + 1
2
Prelude> 2 + 3 * 4
14
Prelude> (2 + 3) * 4
20
\end{verbatim}

At this point we can tell that the usual precedence rules apply
(i.e.~the
\href{https://en.wikipedia.org/wiki/Order_of_operations\#Mnemonics}{PEMDAS
rule}).

\begin{verbatim}
Prelude> 0 - 1
-1
\end{verbatim}

Numbers can be negative\ldots{}

\begin{verbatim}
Prelude> 2^10
1024
Prelude> 2^2^10
17976931348623159077293051907890247336179769789423065727343008115773267580550096
31327084773224075360211201138798713933576587897688144166224928474306394741243777
67893424865485276302219601246094119453082952085005768838150682342462881473913110
540827237163350510684586298239947245938479716304835356329624224137216
Prelude> (2^2)^10
1048576
\end{verbatim}

\ldots and also very large. By default, Haskell uses arbitrary precision
integer arithmetic. Note that for this lecture, we will completely avoid
and ignore floating point arithmetic.

In the last example we can see that Haskell interprets
\texttt{a\^{}b\^{}c} as \texttt{a\^{}(b\^{}c)}, i.e.~the power operator
is \emph{right associative}. It is worth noting that this information is
not hard-coded in the compiler. Instead, when the operator is defined
somewhere in a library, its associativity and precedence can be
declared. We can ask the compiler about this information:

\begin{verbatim}
Prelude> :info (^)
(^) :: (Num a, Integral b) => a -> b -> a   -- Defined in ‘GHC.Real’
infixr 8 ^
\end{verbatim}

Let us ignore the first line (which is the type signature): The
\texttt{r} in \texttt{infixr} tells us that the \texttt{(\^{})} operator
is right-associative. And the number is the precedence; a higher number
means that this operator binds more tightly.

\textbf{Exercise 1}

What associativity do you expect for \texttt{(+)} and \texttt{(-)}?
Verify your expectation.

\textbf{Exercise 2}

Look up the precedences of the other arithmetic operations, and see how
that corresponds to the PEMDAS rule.

\hypertarget{applying-functions}{%
\subsection{Applying Functions}\label{applying-functions}}

So far we have a calculator (which is not useless, I sometimes use
\texttt{ghci} as a calculator). But to get closer to functional
programming, let us look at some functions that are already available to
use.

To stay within the realm of arithmetic (if only to have something to
talk about), let us play with the \texttt{div} and \texttt{mod}
functions. These do what you would expect from them:

\begin{verbatim}
Prelude> div 123 100
1
Prelude> mod 123 100
23
\end{verbatim}

We observe that to apply a function, we just write the function,
followed by the arguments; no parentheses or commas needed. This not
only makes for more elegant and less noisy code; but there is also a
very deep and beautiful reason for this, which we will come to later.

At this point, surely someone wants to know what happens when we divide
by 0:

\begin{verbatim}
Prelude> div 123 0
*** Exception: divide by zero
\end{verbatim}

Haskell has exceptions, they can even be caught etc., but we will not
talk about that for now.

Of course, if the argument is not just a single number, we somehow have
to make clear where the argument begins and ends:

\begin{verbatim}
Prelude> div (120 + 3) (10 ^ 2)
1
\end{verbatim}

(If you leave out the parentheses, you get a horrible error message.) In
technical terms, we can say that function application behaves like a
left-associative operator of highest precedence. But it is easier to
just remember \textbf{function application binds most tightly}.
(Exception: Record construction and update binds even more tightly,
although some consider that a design flaw.)

Just to have more examples, here are two other functions that we can
play around with:

\begin{verbatim}
Prelude> id 42
42
Prelude> const 23 42
23
\end{verbatim}

\textbf{Exercise 3}

Can you predict the result of the following?

\begin{verbatim}
Prelude> 1 + const 2 3 + 4
\end{verbatim}

\textbf{A note on syntactic sugar:} Haskell is a high-calorie language:
There is lots of syntactic sugar. Syntactic sugar refers to when there
are alternative ways of writing something that \emph{looks} different,
but \emph{behaves} the same. The goal is to allow the programmer to
write the code in a way that best suits the reader, which is good, but
it also means that a reader needs to know about the sugar.

\textbf{Infix operator application (syntactic sugar)}: Functions that
take two arguments can be written infix, as if they were an operator, by
putting backticks around the name:

\begin{verbatim}
Prelude> 123 `div` 10
12
Prelude> 123 `mod` 10
3
Prelude> (120 + 3) `div` (10 ^ 2)
1
Prelude> (120 + 3) `div` 10 ^ 2
1
Prelude> ((120 + 3) `div` 10) ^ 2
144
\end{verbatim}

We see that written as operators, even functions have an associativity
and precedence:

\begin{verbatim}
Prelude> :info div
class (Real a, Enum a) => Integral a where
  ...
  div :: a -> a -> a
  ...
    -- Defined in ‘GHC.Real’
infixl 7 `div`
\end{verbatim}

\textbf{Prefix operator application (syntactic sugar) ☆}: We can also go
the other way, and use any operator as if it were a function, by
wrapping it in parentheses:

\begin{verbatim}
Prelude> 1 + 1
2
Prelude> (+) 1 1
2
\end{verbatim}

\textbf{The dollar operator (non-syntactic sugar) ☆}: Consider an
expression that takes a number, and applies a number of functions, maybe
with arguments, to it, such as:

\begin{verbatim}
f5 (f4 (f3 (f2 (f1 42))))
\end{verbatim}

Passing a piece of data through a number of functions is very common,
and some (including me) greatly dislike the accumulation of parentheses
there. Therefore, it is idiomatic to use the \texttt{(\$)} operator:

\begin{verbatim}
f5 $ f4 $ f3 $ f2 $ f1 42
\end{verbatim}

This operator takes a function as the first argument, an argument as the
second argument, and applies the function to the argument. In that way,
it is exactly the same as function application. But it is
\emph{right-associative} (instead of left-associative) and has the
\emph{lowest precedence} (instead of the highest precedence). An easier
way of reading such code is to read \texttt{(\$)} as ``the same as
parentheses around the rest of the line''.

I call this non-syntactic sugar, because the dollar operator is not part
of the built-in language, but can be defined by anyone.

\textbf{Exercise 4}

What is the result of

\begin{verbatim}
Prelude> (-) 5 $ div 16 $ (-) 10 $ 4 `div` 2
\end{verbatim}

\hypertarget{booleans-and-branching}{%
\subsection{Booleans and branching}\label{booleans-and-branching}}

Some cryptographers might be happy to only write code that always does
the same thing (yay, no side effects), but most of us pretty quickly
want to write branching code.

As you would expect, Haskell has the usual operators to compare numbers:

\begin{verbatim}
Prelude> 1 + 1 == 2
True
Prelude> 4 < 5
True
Prelude> 4 >= 5
False
Prelude> 23 /= 42
True
\end{verbatim}

We see that there are values \texttt{True} and \texttt{False}. We can
combine them using the usual Boolean operators:

\begin{verbatim}
Prelude> 1 + 1 == 2 && 5 < 4
False
Prelude> 1 + 1 == 2 || 5 < 4
True
\end{verbatim}

And finally, we can use
\texttt{if\ \ldots{}\ then\ \ldots{}\ else\ \ldots{}} to branch based on
such a Boolean expression:

\begin{verbatim}
Prelude> if 5 < 0 then 0 else 1
1
Prelude> if -5 < 0 then 0 else 1
0
\end{verbatim}

The use of \texttt{if\ \ldots{}\ then\ \ldots{}\ else\ \ldots{}} is
actually not the most idiomatic way to code decisions in Haskell, and we
will come back to that point later, but for now it is good enough.

\hypertarget{function-abstraction}{%
\subsection{Function abstraction}\label{function-abstraction}}

Assume you want to check a bunch of numbers as to whether they are
multiples of 10 (so called ``round numbers'' in German). You can do that
using \texttt{mod} and \texttt{(==)}:

\begin{verbatim}
Prelude> 5 `mod` 10 == 0
False
Prelude> 10 `mod` 10 == 0
True
Prelude> 11 `mod` 10 == 0
False
Prelude> 20 `mod` 10 == 0
True
Prelude> -20 `mod` 10 == 0
True
Prelude> 123 `mod` 10 == 0
False
\end{verbatim}

But this gets repetitive quickly. And whenever we program something in a
repetitive way, we try to recognize the \emph{pattern} and abstract over
the changing \emph{parameter}, leaving only the common parts

Here, the common pattern is
\texttt{x\ \textasciigrave{}mod\textasciigrave{}\ 10\ ==\ 0}, with a
parameter named \texttt{x}. We can give this pattern a name, and use it
instead:

\begin{verbatim}
Prelude> isRound x = x `mod` 10 == 0
Prelude> isRound 5
False
Prelude> isRound 10
True
Prelude> isRound 11
False
Prelude> isRound 20
True
Prelude> isRound (-20)
True
Prelude> isRound 123
False
\end{verbatim}

And now we are squarely in the realm of functional programming, as we
have just defined out first function, \texttt{isRound}!

Note that we defined \texttt{isRound} by way of an equation. And it
really is an equation: Wherever we see \texttt{isRound\ something}, we
can obtain its meaning by replacing it with
\texttt{something\ \textasciigrave{}mod\textasciigrave{}\ 10\ ==\ 0}.
This \emph{equational reasoning}, where you replace equals by equals, is
one key technique to make sense of Haskell programs.

\textbf{Exercise 5}

Discuss: Think of other programming language that have concepts called
functions. Can you always replace a function call with the function
definition? Does it change the meaning of the program?

\textbf{Exercise 6}

Write a function \texttt{absoluteValue} with one parameter. If the
parameter is negative, returns its opposite number, otherwise the number
itself.

\textbf{Exercise 7}

Write a function \texttt{isHalfRound} that checks if a number is
divisible by 5, by checking whether the last digit is 0 or 5.

\textbf{Exercise 8}

Write a function \texttt{isEven} that checks if a number is divisible by
2, by checking whether the last digit is 0, 2, 4, 6, 8.

Of course, you can abstract over more than one parameter. In the last
exercise, you had to write something like
\texttt{x\ \textasciigrave{}mod\textasciigrave{}\ 10\ ==\ y} a lot. So
it makes sense to abstract over that:

\begin{verbatim}
Prelude> hasLastDigit x y = x `mod` 10 == y
\end{verbatim}

This allows us to define \texttt{isHalfRound} as follows:

\begin{verbatim}
Prelude> isHalfRound x = x `hasLastDigit` 0 || x `hasLastDigit` 5
\end{verbatim}

which, if you read it out, is almost a transliteration of the
specification! Here we see how abstraction, together with good naming
and syntax, can produce very clear and readable code.

\textbf{Infix operator application again (syntactic sugar)}: By the way,
you can use infix operator syntax already when defining a function:

\begin{verbatim}
x `divides` y = x `div` y == 0
\end{verbatim}

\hypertarget{recursion}{%
\subsection{Recursion}\label{recursion}}

We already saw that one function that we defined could call another. But
the real power of general computation comes when a function can call
itself, i.e.~when we employ recursion. Recursion is a very fundamental
technique in functional programming, much more so than loops or
iterators or such.

Let us come up with a function that determines the number of digits in a
given number. We first check if the number is already just one digit:

\begin{verbatim}
Prelude> countDigits n = if n < 10 then 1 else █
\end{verbatim}

At this point, we know that the number is larger than 10. So to count
the digits, we would like to cut off one digit:

\begin{verbatim}
Prelude> countDigits n = if n < 10 then 1 else (n `div` 10)█
\end{verbatim}

and count the number of digits of \emph{that} number

\begin{verbatim}
Prelude> countDigits n = if n < 10 then 1 else countDigits (n `div` 10)█
\end{verbatim}

and, of course, add one to that number:

\begin{verbatim}
Prelude> countDigits n = if n < 10 then 1 else countDigits (n `div` 10) + 1
Prelude> countDigits 0
1
Prelude> countDigits 5
1
Prelude> countDigits 10
2
Prelude> countDigits 11
2
Prelude> countDigits 99
2
Prelude> countDigits 100
3
Prelude> countDigits 1000
4
Prelude> countDigits (10^12345)
12346
\end{verbatim}

The fact that we can replace equals with equals does not change just
because we use recursion. For example, we can figure out what
\texttt{countDigits\ 789} does by replacing equals with equals:

\begin{verbatim}
  countDigits 789
= if 789 < 10 then 1 else countDigits (789 `div` 10) + 1
= if False then 1 else countDigits (789 `div` 10) + 1
= countDigits (789 `div` 10) + 1
= countDigits 78 + 1
= (if 78 < 10 then 1 else countDigits (78 `div` 10) + 1) + 1
= (if False then 1 else countDigits (78 `div` 10) + 1) + 1
= (countDigits (78 `div` 10) + 1) + 1
= (countDigits 7 + 1) + 1
= ((if 7 < 10 then 1 else countDigits (7 `div` 10) + 1) + 1) + 1
= ((if True then 1 else countDigits (7 `div` 10) + 1) + 1) + 1
= (1 + 1) + 1
= 2 + 1
= 3
\end{verbatim}

\textbf{Exercise 9}

Write the function \texttt{sumDigits} that sums up the digits of a
natural number.

\hypertarget{higher-order-functions}{%
\subsection{Higher-order functions}\label{higher-order-functions}}

We created functions when we took expressions that followed a certain
pattern, and abstracted over a number that occurred therein. But the
thing we can abstract over does not have to be just a simple number. It
could also be a function!

Consider the task of calculating the number of digits in the number of
digits of a number:

\begin{verbatim}
Prelude> countDigits (countDigits 5)
1
Prelude> countDigits (countDigits 10)
1
Prelude> countDigits (countDigits (10^10))
2
Prelude> countDigits (countDigits (10^123))
3
Prelude> countDigits (countDigits (15^15))
2
\end{verbatim}

Clearly, we can abstract over the argument here:

\begin{verbatim}
Prelude> countCountDigits n = countDigits (countDigits n)
Prelude> countCountDigits (10^123)
3
\end{verbatim}

But now consider we also want \texttt{sumSumDigits}:

\begin{verbatim}
Prelude> sumSumDigits n = sumDigits (sumDigits n)
Prelude> sumSumDigits (9^9)
9
Prelude> sumSumDigits (7^7)
7
Prelude> sumSumDigits (13^13)
13
Prelude> sumSumDigits (15^15)
18
\end{verbatim}

There is clearly a pattern that is shared by both
\texttt{countCountDigits} and \texttt{sumSumDigits}: They both apply a
function twice. And indeed, we can abstract over that pattern:

\begin{verbatim}
Prelude> twice f x = f (f x)
Prelude> twice countDigits (15^15)
2
Prelude> twice sumDigits (15^15)
18
\end{verbatim}

This is our first \emph{higher order function}, and it is called so
because it is a function that takes another function as an argument.
More precisely, it is called a second-order function, because it takes a
normal, i.e.~first-order function, as an argument. Abstracting over a
second order function yields a third order function, and so on. Up to
\href{https://doi.org/10.1017/S0956796898003001}{sixth-order functions}
are seen in the wild.

If you look at the last two lines, we again see a common pattern. And
abstracting over that, we recover very nice and declarative definitions
for \texttt{countCountDigits} and \texttt{sumSumDigits}:

\begin{verbatim}
Prelude> countCountDigits x = twice countDigits x
Prelude> sumSumDigits x = twice sumDigits x
\end{verbatim}

The ability to abstract very easily over functions is an important
ingredient in making Haskell so excellent at abstraction: It allows to
abstract over \emph{behavior}, instead merely over \emph{value}. To
demonstrate that, let us recall the definitions of \texttt{countDigits}
and \texttt{sumDigits}:

\begin{verbatim}
Prelude> countDigits n = if n < 10 then 1 
             else countDigits (n `div` 10) + 1
Prelude> sumDigits n = if n < 10 then n 
             else sumDigits (n `div` 10) + (n `mod` 10)
\end{verbatim}

These two functions share something: They share a behavior! Both iterate
over the digits of the function, do something at each digit, and sum
something up. And this common functionality is not trivial! So it is
very unsatisfying to copy'n'paste it, like we did. So how can we
abstract over the parts that differ? It is not obvious on first glance,
so go through it step by step, lets give the parts that differ names.
For \texttt{countDigits}, we \emph{ignore} the digit, and just sum up
ones:

\begin{verbatim}
Prelude> always1 n = 1
Prelude> countDigits n = if n < 10 then always1 n 
             else countDigits (n `div` 10) + always1 (n `mod` 10)
\end{verbatim}

And for \texttt{sumDigits}, we use the digit as is. And we have already
seen a function that just returns its argument, the identity function:

\begin{verbatim}
Prelude> sumDigits n = if n < 10 then id n 
             else sumDigits (n `div` 10) + id (n `mod` 10)
\end{verbatim}

Now the common pattern is clear, and we can abstract over the different
parts:

\begin{verbatim}
Prelude> sumDigitsWith f n = if n < 10 then f n 
              else sumDigitsWith f (n `div` 10) + f (n `mod` 10)
Prelude> countDigits n = sumDigitsWith always1 n
Prelude> sumDigits n = sumDigitsWith id n
\end{verbatim}

To recapitulate: We took two functions that were doing somehow related
things, and we rewrote them to clearly separate the common parts from
the differing parts, and then we could extract the shared essence into
its own, higher-order function.

This single mechanism -- abstracting over functions -- can
\href{https://www.voxxed.com/2016/04/gang-four-patterns-functional-light-part-1/}{replace
thick volumes full of design patterns} in non-functional programming
paradigms.

Note that if one would have to abstract \texttt{countDigits} and
\texttt{sumDigits} to \texttt{sumDigitsWith} in practice, one would
probably not rewrite them first with \texttt{id} etc., but just look at
them and come up with \texttt{sumDigitsWith} directly.

\textbf{Exercise 10}

Write a (recursive) function \texttt{fixEq} so that \texttt{fixEq\ f\ x}
repeatedly applies \texttt{f} to \texttt{x} until the result of
\texttt{f} is the same as its argument.

\textbf{Exercise 11}

Use this function and \texttt{sumDigits} to write a function
\texttt{isMultipleOf3} so that \texttt{isMultipleOf3\ x} is true if
repeatedly applying \texttt{sumDigits} to \texttt{x} results in 3, 6 or
9.

\hypertarget{anonymous-functions}{%
\subsection{Anonymous functions}\label{anonymous-functions}}

We defined a function \texttt{always1}, but it seems a bit silly to give
a name to such a specialized and small concept. Therefore, Haskell
allows us to define \emph{anonymous functions} on the fly. The syntax is
a backslash, followed by the parameter (or parameters), followed by the
body of the function. So we can define \texttt{countDigits} and
\texttt{sumDigits} without any helper functions like this:

\begin{verbatim}
Prelude> countDigits n = sumDigitsWith (\d -> 1) n
Prelude> sumDigits n = sumDigitsWith (\d -> d) n
\end{verbatim}

These are also called \emph{lambda abstractions}, because they are
derived from the Lambda calculus, and the backslash is a poor imitation
of the Greek letter lambda (λ).

\hypertarget{higher-order-function-definition}{%
\subsection{Higher-order function
definition}\label{higher-order-function-definition}}

Let's look at the previous two definitions, and remember that when we
define a function this way, we define what to replace the left-hand side
with. But notice that the argument \texttt{n} is not touched at all by
this definition! So we should get the same result if we simply omit it
from the equation, right? And indeed, we can just as well write

\begin{verbatim}
Prelude> countDigits = sumDigitsWith (\d -> 1)
Prelude> sumDigits = sumDigitsWith (\d -> d)
\end{verbatim}

It looks as if we just saved two characters. But what really just
happened is that we shifted our perspective, and raised the level of
abstraction by one layer. Instead of defining a \texttt{countDigits} as
a function that takes a number and produces another number, we have
defined \texttt{countDigits} as the result of instantiating the pattern
\texttt{sumDigitsWith} with the function
\texttt{(\textbackslash{}d\ -\textgreater{}\ 1)}. At this level of
thought, we do not care about the argument to \texttt{countDigits},
i.e.~what it is called or so.

\textbf{Exercise 12}

Which other recent definitions can be changed accordingly?

\hypertarget{currying}{%
\subsection{Currying}\label{currying}}

We have already seen functions that \emph{receive} a function as an
argument. The way we use \texttt{twice} or \texttt{sumDigitsWith} here,
we can think of them as functions that \emph{return} functions. And this
brings us to the deep and beautiful explanation why we write multiple
arguments to functions the way we do: Because really, every function
only ever has one argument.

We can \emph{think} of \texttt{twice} has having two arguments (the
function \texttt{f}, and the value \texttt{x}), but really,
\texttt{twice} is a function that takes one argument (the function
\texttt{f}), and returns another function, which then takes the value
\texttt{x}. This ``other'' function is what we named in the above
definition of \texttt{sumSumDigits}.

\hypertarget{the-composition-operator}{%
\subsection{The composition operator ☆}\label{the-composition-operator}}

Because writing code that passes functions around and modifies them
(like in \texttt{twice} or \texttt{sumDigitsWith}) is so important in
this style of programming, I should at this point introduce the
composition operator. It is already pre-defined, but we can define it
ourselves:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(f }\OperatorTok{.}\NormalTok{ g) x }\OtherTok{=}\NormalTok{ f (g x)}
\end{Highlighting}
\end{Shaded}

The dot is a poor approximation of the mathematical symbol for function
composition, ``∘'', and can be read as ``\texttt{f} after \texttt{g}''.
Note \texttt{x} is passed to \texttt{g} first, and then the result to
\texttt{f}.

It looks like a pretty vacuous definition, but it is very useful in
writing high-level code. For example, it allows us the following, nicely
abstract definition of \texttt{twice}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{twice f }\OtherTok{=}\NormalTok{ f }\OperatorTok{.}\NormalTok{ f}
\end{Highlighting}
\end{Shaded}

Do you remember the example we used when introducing the dollar
operator? We started with

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f5 (f4 (f3 (f2 (f1 }\DecValTok{42}\NormalTok{))))}
\end{Highlighting}
\end{Shaded}

and rewrote it to

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f5 }\OperatorTok{$}\NormalTok{ f4 }\OperatorTok{$}\NormalTok{ f3 }\OperatorTok{$}\NormalTok{ f2 }\OperatorTok{$}\NormalTok{ f1 }\DecValTok{42}
\end{Highlighting}
\end{Shaded}

Now imagine we want to abstract over 42:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{many\_fs x }\OtherTok{=}\NormalTok{ f5 (f4 (f3 (f2 (f1 x))))}
\end{Highlighting}
\end{Shaded}

This function really is just the composition of a bunch of functions. So
an idiomatic way of writing it would be

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{many\_fs  }\OtherTok{=}\NormalTok{ f5 }\OperatorTok{.}\NormalTok{ f4 }\OperatorTok{.}\NormalTok{ f3 }\OperatorTok{.}\NormalTok{ f2 }\OperatorTok{.}\NormalTok{ f1}
\end{Highlighting}
\end{Shaded}

where again, the actual value is no longer the emphasis, but rather the
functions.

The value \texttt{x} is sometimes called the point (as in geometry), and
this style of programming is called \emph{point-free} (or sometimes
\emph{pointless}).

\hypertarget{pure}{%
\subsection{Purity}\label{pure}}

We have seen most important fundamental concepts of functional
programming here. So let me point out a few things that we have not
seen, and not due to lack of time, because they are not there:

We have not seen variables that you declare to hold one value, and later
you update them to another value. We have not seen how to get a variable
that has a random value, or one that the user has input. We have not
seen ways of deleting files or launching missiles.

This is because, fundamentally, those things do not exist in Haskell. A
Haskell expression simply denotes a value -- e.g.~a number, a Boolean,
maybe a function. And it always denotes the same value. Evaluating the
same expression a second time will not give different results, nor will
it delete your backups. We say that Haskell is a \emph{pure} language,
and it has no \emph{side-effects}.

Granted, there are some Haskell expressions do not denote a value: Some
go into an infinite loop, or raise an exception (e.g.~division by zero).
But there are still no side-effects here.

Because functions are simply abstracted expressions, they are also pure:
The return value depends \emph{only} on the value of the arguments to
the function; not on the time of day, the user's mood or the system's
random number generator. In that sense they behave just like
mathematical functions.

But if expressions and functions can't \emph{do} anything, how can we
write useful programs? Programs that respond to network requests, or do
an in-place array sort, or use concurrency? Can we do that, and still
have a pure language? Yes, we can, and Haskell's solution to this
dilemma are monads. We will handle that topic in a quick-and-dirty way
in \protect\hyperlink{io}{the chapter on imperative code} and more
properly \protect\hyperlink{monads}{the chapter on monads}.

\hypertarget{laziness}{%
\subsection{Laziness ☆}\label{laziness}}

As a final bit in this section, let's talk about laziness. Most often
this can be ignored when reading Haskell code, and in general laziness
is not as important (or as bad) as some people say it is. But it plays
an important role in Haskell's support for abstraction, so let's briefly
look at it.

Laziness means that an expression is evaluated as late as possible,
i.e.~when it is needed to make a branching decision, or when it is to be
printed on the screen. We can only observe when things are being
evaluated when we have side-effects, and the only side effects we can
produce so far are non-termination and exceptions. So let us use
division by zero to observe that the first argument to \texttt{const} is
used, but the second one is not:

\begin{verbatim}
Prelude> 0 `div` 0
*** Exception: divide by zero
Prelude> const (0 `div` 0) 1
*** Exception: divide by zero
Prelude> const 1 (0 `div` 0)
1
\end{verbatim}

To see why this is so crucial for abstraction, consider the following
two functions that implement a safe version of \texttt{div} and
\texttt{mod} that just returns 0 if the user tries to divide by 0:

\begin{verbatim}
Prelude> x `safeDiv` y = if y == 0 then 0 else x `div` y
Prelude> x `safeMod` y = if y == 0 then 0 else x `mod` y
Prelude> 10 `safeDiv` 5
2
Prelude> 10 `safeDiv` 0
0
\end{verbatim}

Clearly, the definitions of \texttt{safeDiv} and \texttt{safeMod} share
a pattern. So let us extract the pattern ``if y is zero then return zero
else do something else'':

\begin{verbatim}
Prelude> unlessZero y z = if y == 0 then 0 else z
Prelude> x `safeDiv` y = unlessZero y (x `div` y)
Prelude> x `safeMod` y = unlessZero y (x `mod` y)
Prelude> 10 `safeDiv` 5
2
Prelude> 10 `safeDiv` 0
0
\end{verbatim}

So that works. But it only works because Haskell is lazy. Consider what
would happen in a strict language, where expressions are evaluated
before passed to a function:

\begin{verbatim}
  10 `safeDiv` 0
= unlessZero 0 (10 `div` 0)
= unlessZero 0 (*** Exception: divide by zero
\end{verbatim}

Only with laziness can we easily abstract not only over computations,
but even over control flow, and create our own control flow constructs
-- simply as higher-order functions!

In fact, even \texttt{if\ \ldots{}\ then\ \ldots{}\ else} could just be
a normal function with three parameters, defined somewhere in the
standard library. The fact that there is special syntax for it is pure
convenience -- which, again, is not the case in strict languages.

\hypertarget{types}{%
\section{Types}\label{types}}

In the first chapter, we have seen how functional programming opens the
way to abstraction, and to condense independent concerns into separate
pieces of code. This is a very powerful tool for modularity, and helps
to focus on the relevant part of a problem while keeping the bookkeeping
out of sight. But powerful is also dangerous -- using a higher order
function correctly without any aid can be mind-bending.

Whenever we write functions like in the previous section, we have an
idea in our head about what their arguments are -- are they just
numbers, or are they functions, and what kind of functions -- and what
do they expect and what do they return. It is obvious to us that writing
\texttt{twice\ isEven} does not make sense, because \texttt{isEven}
returns \texttt{True} or \texttt{False}, but expects a number, so it
cannot be applied twice in a row.

This is all simple and obvious, but it is a lot to keep in your head as
the code grows larger, and even more so once the code is changing and
there are more people working on it. So to keep this power and
complexity manageable, Haskell has a strong static type system, which is
essentially a way for you to communicate with the compiler about these
ideas you have in your head. You can ask the compiler ``what do you know
about this function? what can it take, what kind of things does it
return?''. And you can tell the compiler ``this function ought to take
this and return that (and please tell me if you disagree)''.

In fact, many Haskellers prefer to do type-driven development: First
think about and write down the type of the function they need to create,
and \emph{then} think about implementing them.

Besides communicating with the compiler, types are also crucial in
communicating with your fellow developers and/or users of your API. For
many functions, the type alone, or the type and the name, is sufficient
to tell you what it does.

\hypertarget{tooling-interlude-editing-files}{%
\subsection{Tooling interlude: Editing files
☆}\label{tooling-interlude-editing-files}}

At this point, we should switch from working exclusively in the REPL to
writing an actual Haskell file. We can start by creating a file
\href{https://haskell-for-readers.nomeata.de/files/types.hs}{\texttt{types.hs}},
and putting in the code from the first chapter:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{isRound x }\OtherTok{=}\NormalTok{ x }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10} \OperatorTok{==} \DecValTok{0}
\NormalTok{hasLastDigit x y }\OtherTok{=}\NormalTok{ x }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10} \OperatorTok{==}\NormalTok{ y}
\NormalTok{isHalfRound x }\OtherTok{=}\NormalTok{ x }\OtherTok{\textasciigrave{}hasLastDigit\textasciigrave{}} \DecValTok{0} \OperatorTok{||}\NormalTok{ x }\OtherTok{\textasciigrave{}hasLastDigit\textasciigrave{}} \DecValTok{5}
\NormalTok{    x }\OtherTok{\textasciigrave{}divides\textasciigrave{}}\NormalTok{ y }\OtherTok{=}\NormalTok{ x }\OtherTok{\textasciigrave{}div\textasciigrave{}}\NormalTok{ y }\OperatorTok{==} \DecValTok{0}
\NormalTok{twice f x }\OtherTok{=}\NormalTok{ f (f x)}
\NormalTok{countCountDigits x }\OtherTok{=}\NormalTok{ twice countDigits x}
\NormalTok{sumSumDigits x }\OtherTok{=}\NormalTok{ twice sumDigits x}
\NormalTok{sumDigitsWith f n }\OtherTok{=} \KeywordTok{if}\NormalTok{ n }\OperatorTok{\textless{}} \DecValTok{10} \KeywordTok{then}\NormalTok{ f n }
\KeywordTok{    else}\NormalTok{ sumDigitsWith f (n }\OtherTok{\textasciigrave{}div\textasciigrave{}} \DecValTok{10}\NormalTok{) }\OperatorTok{+}\NormalTok{ f (n }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10}\NormalTok{)}
\NormalTok{countDigits }\OtherTok{=}\NormalTok{ sumDigitsWith (\textbackslash{}d }\OtherTok{{-}\textgreater{}} \DecValTok{1}\NormalTok{)}
\NormalTok{sumDigits }\OtherTok{=}\NormalTok{ sumDigitsWith (\textbackslash{}d }\OtherTok{{-}\textgreater{}}\NormalTok{ d)}
\NormalTok{fixEq f x }\OtherTok{=} \KeywordTok{if}\NormalTok{ x }\OperatorTok{==}\NormalTok{ f x }\KeywordTok{then}\NormalTok{ x }\KeywordTok{else}\NormalTok{ fixEq f (f x)}
\NormalTok{isMultipleOf3 x }\OtherTok{=}\NormalTok{ fixEq sumDigits x }\OperatorTok{==} \DecValTok{3} \OperatorTok{||}
\NormalTok{   fixEq sumDigits x }\OperatorTok{==} \DecValTok{6} \OperatorTok{||}\NormalTok{ fixEq sumDigits x }\OperatorTok{==} \DecValTok{9}
\end{Highlighting}
\end{Shaded}

We can load this file into \texttt{ghci} by either starting it with
\texttt{ghci\ types.hs} or by typing \texttt{:load\ types.hs} within
\texttt{ghci}. After you change and save the file, you can reload with
\texttt{:reload} (or simply \texttt{:r}).

\hypertarget{basic-types}{%
\subsection{Basic types}\label{basic-types}}

As I mentioned before, you can chat with the compiler about the types of
things, and ask what it thinks they are. We can do that with the
\texttt{:type} (or \texttt{:t}) command:

\begin{verbatim}
*Main> :t sumDigits
sumDigits :: Integer -> Integer
\end{verbatim}

Here, GHC tells us the type of \texttt{sumDigits}, in the form of a
\emph{type annotation}, i.e.~a term (\texttt{sumDigits}) followed by two
colons, followed by its type. The type itself tells us that
\texttt{sumDigits} is a function (as indicated by the arrow) that takes
an \texttt{Integer} as an argument and returns an \texttt{Integer} as a
result. Which greatly matches our expectation!

Instead of asking GHC for the type, we can also specify it, simply by
adding the line

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{sumDigits ::} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Integer}
\end{Highlighting}
\end{Shaded}

to the file (commonly directly above the function definition, rarely all
bundled up in the beginning).

If we insert a type annotation that does not match what we wrote in the
code, for example, if we added

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{isRound ::} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Integer}
\end{Highlighting}
\end{Shaded}

we would get an error message like

\begin{verbatim}
types.hs:2:13: error:
    • Couldn't match expected type ‘Integer’ with actual type ‘Bool’
    • In the expression: x `mod` 10 == 0
      In an equation for ‘isRound’: isRound x = x `mod` 10 == 0
  |
2 | isRound x = x `mod` 10 == 0
  |             ^^^^^^^^^^^^^^^
\end{verbatim}

Note that the compiler believes the type signature, and complains about
the code, not the other way around.

The error message mentions a type \texttt{Bool} which, as you can guess,
is the type of Boolean expressions, e.g.~\texttt{True} and
\texttt{False}. With this knowledge, we can write the correct type
signature for \texttt{isRound}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{isRound ::} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\end{Highlighting}
\end{Shaded}

\hypertarget{polymorphism}{%
\subsection{Polymorphism}\label{polymorphism}}

Let us consider \texttt{twice} for a moment, and think about what to
expect from its type. It is a function that takes two arguments, and the
first argument ought to be a function itself\ldots{} and here is how GHC
writes this:

\begin{verbatim}
*Main> :t twice
twice :: (t -> t) -> t -> t
\end{verbatim}

From this example, we learn that

\begin{itemize}
\tightlist
\item
  the type of functions with multiple arguments is written using
  multiple arrows,
\item
  the function arrow can just as well occur inside an argument, namely
  when an argument itself is a function.
\end{itemize}

But what is this type \texttt{t}? There is not, actually, a type called
\texttt{t}. Instead, this is a \emph{type variable}, meaning that the
function \texttt{twice} can be used with any type. Any identifier in a
type that starts with a lower-case letter is a type variable (not just
\texttt{t}), and concrete types always start with an upper-case letter.

Here we can see that we can use \texttt{twice} with numbers, Booleans,
and even with functions:

\begin{verbatim}
*Main> twice countDigits (99^99)
3
*Main> twice not True
True
*Main> twice twice countDigits (99^99)
1
\end{verbatim}

What does not work is passing a function to \texttt{twice} that works on
numbers, but then pass a \texttt{Bool}:

\begin{verbatim}
*Main> twice countDigits True

<interactive>:12:19: error:
    • Couldn't match expected type ‘Integer’ with actual type ‘Bool’
    • In the second argument of ‘twice’, namely ‘True’
      In the expression: twice countDigits True
      In an equation for ‘it’: it = twice countDigits True
\end{verbatim}

In other words: The \texttt{t}s in the type of \texttt{twice} can become
\emph{any} type, but it has to be the same type everywhere.

\textbf{Exercise 13}

What do you think is the type of \texttt{id}?

If we ask for the type of the function \texttt{const}, we see two
different type variables:

\begin{verbatim}
*Main> :t const
const :: a -> b -> a
\end{verbatim}

And here we can indeed instantiate them at different types:

\begin{verbatim}
*Main> :t const True 1
const True 1 :: Bool
\end{verbatim}

\hypertarget{constrained-types-a-first-glimpse}{%
\subsection{Constrained types (a first
glimpse)}\label{constrained-types-a-first-glimpse}}

There are more polymorphic functions in our initial set, for example
\texttt{fixEq}:

\begin{verbatim}
*Main> :t fixEq
fixEq :: Eq t => (t -> t) -> t -> t
\end{verbatim}

The part after the \texttt{=\textgreater{}} is what we expect: two
arguments, the first a function, all the same types, just like with
\texttt{twice}. The part before the \texttt{=\textgreater{}} is new: It
is a \emph{constraint}, and it limits which types \texttt{t} can be
instantiated with. Remember that \texttt{fixEq} uses \texttt{(==)} to
check if the value has stabilized. But not all values can be compared
for equality! (In particular, functions cannot). So \texttt{fixEq} does
not work with any type, but only those that support equality. This is
what \texttt{Eq\ t} indicates, and indeed we get an error message when
we try to do it wrongly:

\begin{verbatim}
*Main> fixEq twice not True

<interactive>:27:1: error:
    • No instance for (Eq (Bool -> Bool)) arising from a use of ‘fixEq’
        (maybe you haven't applied a function to enough arguments?)
    • In the expression: fixEq twice not True
      In an equation for ‘it’: it = fixEq twice not True
\end{verbatim}

This \texttt{Eq} thing is not some built-in magic, but rather a
\emph{type class}, another very powerful and important feature of
Haskell, which we will dive into separately later.

Other functions in our list are polymorphic where we may not have
expected it:

\begin{verbatim}
*Main> :t sumDigitsWith
sumDigitsWith :: (Integral a1, Num a2) => (a1 -> a2) -> a1 -> a2
\end{verbatim}

This is not the type we might have expected! This is because Haskell
supports different numeric types, and uses type classes to overload the
numeric operations. But remember that typing is a conversation: We can
simply tell GHC that we want a different (more specific) type for
\texttt{sumDigitsWith}, by adding

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{sumDigitsWith ::}\NormalTok{ (}\DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Integer}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Integer}
\end{Highlighting}
\end{Shaded}

to our file. In fact, in practice one \emph{always} writes full type
signatures for all top-level definitions, so this should be less of a
problem for Haskell readers.

\hypertarget{parametricity}{%
\subsection{Parametricity}\label{parametricity}}

One obvious use for such polymorphism is to write code once, and use it
at different types. But there is another great advantage of polymorphic
functions, even if we only ever intend to instantiate the type variables
with the same type, and that is reasoning by \emph{parametricity}.

In a function with a polymorphic type like \texttt{twice} there is not a
lot we can do with the parameters. Sure, we can apply \texttt{f} to
\texttt{x}, and maybe apply \texttt{f} more than once. But that is just
about all we can do: Because \texttt{x} can have an arbitrary type, we
cannot do arithmetic with it, we cannot print it, we cannot even compare
it to other values of type \texttt{x}.

This severely restricts what \texttt{twice} can do at all \ldots{} but
on the other hand means that just from looking at the type signature of
\texttt{twice} we already know a lot about what it does.

A very simple example for that is the function \texttt{id}, with type
\texttt{a\ -\textgreater{}\ a}. \emph{Any} function of this type will
either

\begin{itemize}
\tightlist
\item
  return its argument (i.e.~be the identity function),
\item
  return never (i.e.~go into an infinite loop), or
\item
  raise an exception.
\end{itemize}

\textbf{Exercise 14}

A great example for the power of polymorphism is the following type
signature:

\begin{verbatim}
(a -> b -> c) -> b -> a -> c
\end{verbatim}

There is a function of that type in the standard library. Can you tell
what it does? Can you guess its name? You can use a type-based search
engine like
\href{https://www.haskell.org/hoogle/?hoogle=\%28a+-\%3E+b+-\%3E+c\%29+-\%3E+b+-\%3E+a+-\%3E+c}{Hoogle}
or
\href{http://hayoo.fh-wedel.de/?query=\%28a+-\%3E+b+-\%3E+c\%29+-\%3E+b+-\%3E+a+-\%3E+c}{Hayoo}
to find the function.

\hypertarget{algebraic-data-types}{%
\subsection{Algebraic data types}\label{algebraic-data-types}}

The function type is very expressive, and one can model many data
structures purely with functions. But of course it is more convenient to
use dedicated data structures. There are a number of data structure
types that come with the standard library, in particular tuples, lists,
the \texttt{Maybe} type. But it is more instructive to first look at how
we can define our own.

We can declare new data types using the \texttt{data} keyword, the name
of the type, the \texttt{=} sign, and then a list of
\emph{constructors}, separated by pipes (\texttt{\textbar{}}). These
declarations are a bit odd, since they use \texttt{=} although it is not
really an equality, but let us look at it step by step.

\hypertarget{enumerations}{%
\subsubsection{Enumerations}\label{enumerations}}

In the simplest case, we can use this to declare an enumeration type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Suit} \OtherTok{=} \DataTypeTok{Diamonds} \OperatorTok{|} \DataTypeTok{Clubs} \OperatorTok{|} \DataTypeTok{Hearts} \OperatorTok{|} \DataTypeTok{Spades}
\end{Highlighting}
\end{Shaded}

From now on, we can use the constructors, e.g.~\texttt{Diamonds} as
values of type \texttt{Suit}. This is how we \emph{create} values of
type \texttt{Suit} -- and it is the only way, so we know that every
value of type \texttt{Suit} is, indeed, one of these four constructors.

Note that \texttt{Suit} is a \emph{type}, i.e.~something you can use in
type signatures, while \texttt{Diamonds} and the other constructors are
\emph{values}, i.e.~something you can use in your function definitions.

When we have a value of type \texttt{Suit} then the only thing we can
really do with it is to find out which of these four constructors it
actually is. The way to do that is using \emph{pattern matching}, for
example using the \texttt{case\ \ldots{}\ of\ \ldots{}} syntax:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{isRed ::} \DataTypeTok{Suit} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{isRed s }\OtherTok{=} \KeywordTok{case}\NormalTok{ s }\KeywordTok{of}
  \DataTypeTok{Diamonds} \OtherTok{{-}\textgreater{}} \DataTypeTok{True}
  \DataTypeTok{Hearts} \OtherTok{{-}\textgreater{}} \DataTypeTok{True}
\NormalTok{  \_ }\OtherTok{{-}\textgreater{}} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

The expression \texttt{case\ e\ of\ \ldots{}} evaluates the
\emph{scrutinee} \texttt{e}, and then sequentially goes through the list
of cases. If the value of the scrutinee matches the \emph{pattern} left
of the arrow, the whole expression evaluates to the right-hand side. We
see two kinds of patterns here: Constructor patterns like
\texttt{Diamonds}, which match simply when the value is, indeed, the
constructor, and the \emph{wildcard pattern}, written as an underscore,
which matches any value.

It is common to immediately pattern match on the parameter of a
function, so Haskell supports pattern-matching directly in the function
definition:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{isRed ::} \DataTypeTok{Suit} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{isRed }\DataTypeTok{Diamonds} \OtherTok{=} \DataTypeTok{True}
\NormalTok{isRed }\DataTypeTok{Hearts} \OtherTok{=} \DataTypeTok{True}
\NormalTok{isRed \_ }\OtherTok{=} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

The type \texttt{Bool} that we have already used before is merely one of
these enumeration types, defined as

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Bool} \OtherTok{=} \DataTypeTok{False} \OperatorTok{|} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

and we could do without
\texttt{if\ \ldots{}\ then\ \ldots{}\ else\ \ldots{}} by
pattern-matching on \texttt{Bool}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{ifThenElse ::} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\NormalTok{ifThenElse }\DataTypeTok{True}\NormalTok{ x y }\OtherTok{=}\NormalTok{ x}
\NormalTok{ifThenElse }\DataTypeTok{False}\NormalTok{ x y }\OtherTok{=}\NormalTok{ y}
\end{Highlighting}
\end{Shaded}

The only reason to have
\texttt{if\ \ldots{}\ then\ \ldots{}\ else\ \ldots{}} is that it is a
bit more readable.

\hypertarget{product-types}{%
\subsubsection{Product types}\label{product-types}}

So far, the constructors were just plain values. But we can also turn
them into ``containers'' of sort, where we can store other values. As a
basic example, maybe we want to introduce a type for complex numbers:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Complex} \OtherTok{=} \DataTypeTok{C} \DataTypeTok{Integer} \DataTypeTok{Integer}
\end{Highlighting}
\end{Shaded}

(Mathematically educated readers please excuse the use of
\texttt{Integers} here.)

This creates a new type \texttt{Complex}, with a constructor \texttt{C}.
But \texttt{C} itself is not a value of type \texttt{Complex}, but
rather it is a function that creates values of type \texttt{Complex}
and, crucially, it is the only way of creating values of type
\texttt{Complex}. We can ask for the type of \texttt{C} and see that it
is indeed just a function:

\begin{verbatim}
Prelude> :t C
C :: Integer -> Integer -> Complex
\end{verbatim}

so it should be clear how to use it:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{origin ::} \DataTypeTok{Complex}
\NormalTok{origin }\OtherTok{=} \DataTypeTok{C} \DecValTok{0} \DecValTok{0}
\end{Highlighting}
\end{Shaded}

Note that in the above data type declaration, \texttt{Complex} is a
type, \texttt{C} is a term, but \texttt{Integer} is again a type.

Again the way to use a complex number is by pattern matching. This time
we use pattern matching not to distinguish different cases --
\emph{every} \texttt{Complex} is a \texttt{C} -- but to extract the
parameters of the constructor:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{addC ::} \DataTypeTok{Complex} \OtherTok{{-}\textgreater{}} \DataTypeTok{Complex} \OtherTok{{-}\textgreater{}} \DataTypeTok{Complex}
\NormalTok{addC (}\DataTypeTok{C}\NormalTok{ x1 y1) (}\DataTypeTok{C}\NormalTok{ x2 y2) }\OtherTok{=} \DataTypeTok{C}\NormalTok{ (x1 }\OperatorTok{+}\NormalTok{ x2) (y1 }\OperatorTok{+}\NormalTok{ y2)}
\end{Highlighting}
\end{Shaded}

The parameter in a pattern -- the \texttt{x1} here -- can itself be a
pattern, for example \texttt{0} (which matches only the number 0), or
underscore:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{isReal ::} \DataTypeTok{Complex} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{isReal (}\DataTypeTok{C}\NormalTok{ \_ }\DecValTok{0}\NormalTok{) }\OtherTok{=} \DataTypeTok{True}
\NormalTok{isReal \_ }\OtherTok{=} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

\hypertarget{sum-types}{%
\subsubsection{Sum types}\label{sum-types}}

A type like \texttt{Complex}, with exactly one constructor, is called a
\emph{product type}. But we can of course have types with more than one
constructor and constructor arguments:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Riemann} \OtherTok{=} \DataTypeTok{Complex} \DataTypeTok{Complex} \OperatorTok{|} \DataTypeTok{Infinity}
\end{Highlighting}
\end{Shaded}

This declares a new type \texttt{Riemann} that can be built using one of
these two constructors:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The constructor \texttt{Complex}, which takes one argument, of type
  \texttt{Complex}. Types and terms (including constructors) have
  different namespaces, so we can have a type called \texttt{Complex},
  and a constructor called \texttt{Complex}, and they can be completely
  unrelated. This can be confusing, but is rather idiomatic.

  The type of \texttt{Complex} shows that we can use it as a function,
  to create a point of the \texttt{Riemann} sphere from a complex
  number:

\begin{verbatim}
Prelude> :t Complex
Complex :: Complex -> Riemann
\end{verbatim}
\item
  The constructor \texttt{Infinity} takes no arguments, and simply is a
  value of type \texttt{Riemann} itself.
\end{enumerate}

When we pattern match on a value of type \texttt{Riemann}, we learn
whether it was created using \texttt{Complex} or \texttt{Infinity}, and
in the former case, we also get the complex number passed to it:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{addR ::} \DataTypeTok{Riemann} \OtherTok{{-}\textgreater{}} \DataTypeTok{Riemann} \OtherTok{{-}\textgreater{}} \DataTypeTok{Riemann}
\NormalTok{addR (}\DataTypeTok{Complex}\NormalTok{ c1) (}\DataTypeTok{Complex}\NormalTok{ c2) }\OtherTok{=} \DataTypeTok{Complex}\NormalTok{ (c1 }\OtherTok{\textasciigrave{}add\textasciigrave{}}\NormalTok{ c2)}
\NormalTok{addR }\DataTypeTok{Infinity}\NormalTok{ \_  }\OtherTok{=} \DataTypeTok{Infinity}
\NormalTok{addR \_ }\DataTypeTok{Infinity}  \OtherTok{=} \DataTypeTok{Infinity}
\end{Highlighting}
\end{Shaded}

A data type that has more than one constructor is commonly called a
\emph{sum type}. Because \texttt{data} allows you to build types from
sums and products, these types are called \emph{algebraic data types}
(ADTs).

\hypertarget{recursive-data-types}{%
\subsubsection{Recursive data types}\label{recursive-data-types}}

It is worth pointing out that it is completely fine to have a
constructor argument of the type that we are currently defining. This
way, we obtain a \emph{recursive data type}, and this is the foundation
for many important data structures, in particular lists and trees of
various sorts. Here is a simple example, a binary tree with numbers on
all internal nodes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Tree} \OtherTok{=} \DataTypeTok{Leaf} \OperatorTok{|} \DataTypeTok{Node} \DataTypeTok{Integer} \DataTypeTok{Tree} \DataTypeTok{Tree}
\end{Highlighting}
\end{Shaded}

Again, this can be read as ``a value of type \texttt{Tree} is either a
\texttt{Leaf}, or it is a \texttt{Node} that contains a value of type
\texttt{Integer} and references to two subtrees.''

There is nothing particularly interesting about constructing such a tree
(use \texttt{Leaf} and \texttt{Node}) and traversing it (use pattern
matching). Here is a piece of idiomatic code that inserts a new number
into a tree:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{insert ::} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Tree} \OtherTok{{-}\textgreater{}} \DataTypeTok{Tree}
\NormalTok{insert x }\DataTypeTok{Leaf} \OtherTok{=} \DataTypeTok{Node}\NormalTok{ x }\DataTypeTok{Leaf} \DataTypeTok{Leaf}
\NormalTok{insert x (}\DataTypeTok{Node}\NormalTok{ y t1 t2)}
    \OperatorTok{|}\NormalTok{ y }\OperatorTok{\textless{}}\NormalTok{ x     }\OtherTok{=} \DataTypeTok{Node}\NormalTok{ y t1 (insert x t2)}
    \OperatorTok{|} \FunctionTok{otherwise} \OtherTok{=} \DataTypeTok{Node}\NormalTok{ y (insert x t1) t2}
\end{Highlighting}
\end{Shaded}

This code shows a new, syntactic feature: Pattern guards! These are
Boolean expressions that you can use to further restrict when a case is
taken. The third case in this function definition is only used if
\texttt{y\ \textless{}\ x}, otherwise the following cases are tried. Of
course this could be written using
\texttt{if\ \ldots{}\ then\ \ldots{}\ else\ \ldots{}}, but the
readability and aesthetics are better with pattern guards. The value
\texttt{otherwise} is simply \texttt{True}, but this reads better.

\textbf{Exercise 15}

Consider the following definition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Wat} \OtherTok{=} \DataTypeTok{Wat} \DataTypeTok{Wat}
\end{Highlighting}
\end{Shaded}

Is this legal? What does it mean? Which occurrences of \texttt{Wat} are
terms, and which are types? Can you define a value of type \texttt{Wat}?

\hypertarget{polymorphic-data-types}{%
\subsubsection{Polymorphic data types}\label{polymorphic-data-types}}

The tree data type declared in the previous section ought to be useful
not just for integers, but maybe for any type. But it would be seriously
annoying to have to create a new tree data type for each type we want to
store in the tree. Therefore, we have \emph{polymorphic data types}. In
the example of the tree, we can write:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Tree}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Leaf} \OperatorTok{|} \DataTypeTok{Node}\NormalTok{ a (}\DataTypeTok{Tree}\NormalTok{ a) (}\DataTypeTok{Tree}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

You may remember that the \texttt{a} here ought to be a type variable,
because it occurs in the place of a type, but is lower-case. When we
want to use this tree data type at a concrete type, say
\texttt{Integer}, we simply write \texttt{Tree\ Integer}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{insert ::} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Tree} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Tree} \DataTypeTok{Integer}
\end{Highlighting}
\end{Shaded}

The actual code of the function does not change.

We can also write functions that work on polymorphic trees, i.e.~which
we can use on \emph{any} \texttt{Tree}, no matter what type the values
in the nodes are. A good example is:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{size ::} \DataTypeTok{Tree}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Integer}
\NormalTok{size }\DataTypeTok{Leaf} \OtherTok{=} \DecValTok{0}
\NormalTok{size (}\DataTypeTok{Node}\NormalTok{ \_ t1 t2) }\OtherTok{=} \DecValTok{1} \OperatorTok{+}\NormalTok{ size t1 }\OperatorTok{+}\NormalTok{ size t2}
\end{Highlighting}
\end{Shaded}

Again, parametricity makes the type signature of such a function more
useful than it seems at first: Just from looking at the type signature
of \texttt{size} we \emph{know} that this function does not look at the
values stored in the nodes. Together with the name, that is really all
the documentation we might need. Compare this to
\texttt{size\ ::\ Tree\ Integer\ -\textgreater{}\ Integer} -- now it
could just as well be that this function includes the number stored in
the node in the result somehow.

\hypertarget{functions-in-data-types}{%
\subsubsection{Functions in data types
☆}\label{functions-in-data-types}}

Maybe this is obvious to you, after the emphasis on functions in the
first chapter, but it is still worth pointing out that data types can
also store functions. This blurs the distinction between data and code
some more, as this nice example shows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Stream}\NormalTok{ a b}
    \OtherTok{=} \DataTypeTok{NeedInput}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Stream}\NormalTok{ a b)}
    \OperatorTok{|} \DataTypeTok{HasOutput}\NormalTok{ b (}\DataTypeTok{Stream}\NormalTok{ a b)}
    \OperatorTok{|} \DataTypeTok{Done}
\end{Highlighting}
\end{Shaded}

The type \texttt{Stream\ a\ b} models a state machine that consumes
values of type \texttt{a}, produces values of type \texttt{b}, and maybe
eventually stops. Such a machine is in one of three states:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Waiting for input. This uses the \texttt{NeedInput} constructor, which
  carries a \emph{function} that consumes a type of value \texttt{a} and
  returns the new state of the machine.
\item
  Producing output. This uses the \texttt{HasOutput} constructor, which
  stores the output value of type \texttt{b}, and the subsequent state
  of the machine.
\item
  \texttt{Done}.
\end{enumerate}

We can create a state machine that does run-length encoding this way.
This one does not ever stop, but that's fine:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{rle ::} \DataTypeTok{Eq}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Stream}\NormalTok{ a (}\DataTypeTok{Integer}\NormalTok{,a)}
\NormalTok{rle }\OtherTok{=} \DataTypeTok{NeedInput}\NormalTok{ rle\_start}

\OtherTok{rle\_start ::} \DataTypeTok{Eq}\NormalTok{ a }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Stream}\NormalTok{ a (}\DataTypeTok{Integer}\NormalTok{, a)}
\NormalTok{rle\_start x }\OtherTok{=} \DataTypeTok{NeedInput}\NormalTok{ (rle\_count x }\DecValTok{1}\NormalTok{)}

\OtherTok{rle\_count ::} \DataTypeTok{Eq}\NormalTok{ a }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Stream}\NormalTok{ a (}\DataTypeTok{Integer}\NormalTok{, a)}
\NormalTok{rle\_count x n x\textquotesingle{} }\OperatorTok{|}\NormalTok{ x }\OperatorTok{==}\NormalTok{ x\textquotesingle{} }\OtherTok{=} \DataTypeTok{NeedInput}\NormalTok{ (rle\_count x (n }\OperatorTok{+} \DecValTok{1}\NormalTok{))}
                 \OperatorTok{|} \FunctionTok{otherwise} \OtherTok{=} \DataTypeTok{HasOutput}\NormalTok{ (n, x) (rle\_start x\textquotesingle{})}
\end{Highlighting}
\end{Shaded}

\hypertarget{predefined-data-types}{%
\subsection{Predefined data types}\label{predefined-data-types}}

We intentionally discussed the mechanisms of algebraic data types first,
so that we can explain the most common data types in the standard
library easily.

\hypertarget{booleans}{%
\subsubsection{Booleans ☆}\label{booleans}}

As mentioned before, the values \texttt{True} and \texttt{False} are
simply the constructors of a data type defined as

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Bool} \OtherTok{=} \DataTypeTok{False} \OperatorTok{|} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

There is nothing magic about the definition of \texttt{Bool}. But this
type plays a special role because of pattern guards and the
\texttt{if\ \ldots{}\ then\ \ldots{}\ else\ \ldots{}} construct.

\hypertarget{maybe}{%
\subsubsection{\texorpdfstring{\texttt{Maybe}}{Maybe}}\label{maybe}}

A very common use case for algebraic data types is to capture the idea
of a type whose values ``maybe contain nothing, or just a value of type
\texttt{a}''. Because this is so common, such a data type is predefined:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Maybe}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Nothing} \OperatorTok{|} \DataTypeTok{Just}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

You might see \texttt{Maybe}, for example, in the return type of a
function that deserializes a binary or textual representation of a type,
for example:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{parseFoo ::} \DataTypeTok{String} \OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe} \DataTypeTok{Foo}
\end{Highlighting}
\end{Shaded}

Such an operation can fail, and if the input is invalid, it would return
\texttt{Nothing}. As a user of such a function, the only way to get to
the value of type \texttt{a} therein is to pattern-match on the result,
which forces you to think about and handle the case where the result is
\texttt{Nothing}.

This is much more robust than the common idiom in C, where you have to
remember to check for particular error values (-1, or \texttt{NULL}), or
Go, where you get both a result and a separate error code, but you can
still be lazy and use the result without checking the error code.

A big part of Haskell's reputation as a language that makes it easier to
write correct code relies on the use of data types to precisely describe
the values you are dealing with.

\textbf{Exercise 16}

How many values are there of type \texttt{Maybe\ (Maybe\ Bool)}. When
can it be useful to nest \texttt{Maybe} in that way?

\hypertarget{either}{%
\subsubsection{\texorpdfstring{\texttt{Either}
☆}{Either ☆}}\label{either}}

With \texttt{Maybe} we can express ``one or none''. Sometimes we want
``one or another'' type. For this, the standard library provides

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Either}\NormalTok{ a b }\OtherTok{=} \DataTypeTok{Left}\NormalTok{ a }\OperatorTok{|} \DataTypeTok{Right}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

Commonly, this type is used for computations that can fail, but that
provide some useful error messages when they fail:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{parseFoo ::} \DataTypeTok{String} \OtherTok{{-}\textgreater{}} \DataTypeTok{Either} \DataTypeTok{ParseError} \DataTypeTok{Foo}
\end{Highlighting}
\end{Shaded}

This gives us the same robustness benefits of \texttt{Maybe}, but also a
more helpful error message. If used in this way, then the \texttt{Left}
value is always used for the error or failure case, and the
\texttt{Right} value for when everything went all right.

\hypertarget{tuples}{%
\subsubsection{Tuples}\label{tuples}}

Imagine you are writing a function that wants to return two numbers --
say, the last digit and the rest of the number. The way to do that that
you know so far would require defining a data type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{TwoIntegers} \OtherTok{=} \DataTypeTok{TwoIntegers} \DataTypeTok{Integer} \DataTypeTok{Integer}
\OtherTok{splitLastDigit ::} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{TwoIntegers}
\NormalTok{splitLastDigit n }\OtherTok{=} \DataTypeTok{TwoIntegers}\NormalTok{ (n }\OtherTok{\textasciigrave{}div\textasciigrave{}} \DecValTok{10}\NormalTok{) (n }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Clearly, the concept of ``passing around two values together`` is not
particularly tied to \texttt{Integer}, and we can use polymorphism to
generalize this definition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Two}\NormalTok{ a b }\OtherTok{=} \DataTypeTok{Two}\NormalTok{ a b}
\OtherTok{splitLastDigit ::} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Two} \DataTypeTok{Integer} \DataTypeTok{Integer}
\NormalTok{splitLastDigit n }\OtherTok{=} \DataTypeTok{Two}\NormalTok{ (n }\OtherTok{\textasciigrave{}div\textasciigrave{}} \DecValTok{10}\NormalTok{) (n }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

And because this is so useful, Haskell comes with built-in support for
such pairs, including a nice and slim syntax:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{ (a,b) }\OtherTok{=}\NormalTok{ (a,b)}
\OtherTok{splitLastDigit ::} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}}\NormalTok{ (}\DataTypeTok{Integer}\NormalTok{, }\DataTypeTok{Integer}\NormalTok{)}
\NormalTok{splitLastDigit n }\OtherTok{=}\NormalTok{ (n }\OtherTok{\textasciigrave{}div\textasciigrave{}} \DecValTok{10}\NormalTok{, n }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Besides tuples, which store two values, there are triples, quadruples
and, in general, n-tuples of any size you might encounter. But really,
if these tuples get larger than two or three, the code starts to smell.

Their size is always fixed and statically known at compile time, and you
can have values of different types as components of the tuple. This
distinguishes them from the lists we will see shortly.

\textbf{Exercise 17}

How could you represent the Riemann numbers from the previous section
using only these predefined data types?

Useful predefined functions related to tuples are

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{fst}\OtherTok{ ::}\NormalTok{ (a,b) }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\FunctionTok{snd}\OtherTok{ ::}\NormalTok{ (a,b) }\OtherTok{{-}\textgreater{}}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

and because of their type I do not have to tell you what they do.

\hypertarget{the-unit-type}{%
\subsubsection{The unit type}\label{the-unit-type}}

There is also a zero-tuple, so to say: The unit type written \texttt{()}
with only the value \texttt{()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{ () }\OtherTok{=}\NormalTok{ ()}
\end{Highlighting}
\end{Shaded}

While this does not look very useful yet, we will see that it plays a
crucial role later. Until then, you can think of it as a good choice
when we have something polymorphic, but we do not actually need an
``interesting'' type there.

\textbf{Exercise 18}

Write functions

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{fromEitherUnit ::} \DataTypeTok{Either}\NormalTok{ () a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

and

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{toEitherUnit ::} \DataTypeTok{Maybe}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Either}\NormalTok{ () a}
\end{Highlighting}
\end{Shaded}

that are inverses to each other.

In only one of these type signatures you can replace \texttt{()} with a
new type variable \texttt{b}, and still implement the function. In which
one? Why?

\hypertarget{lists}{%
\subsubsection{Lists}\label{lists}}

In the previous section we defined trees using a recursive data type. It
should be obvious that we can define lists in a very analogous way:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{List}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Empty} \OperatorTok{|} \DataTypeTok{Link}\NormalTok{ a (}\DataTypeTok{List}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

This data structure is so ubiquitous in functional programming that it
not only comes with the standard library, it also has very special,
magic syntax:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{ [a] }\OtherTok{=}\NormalTok{ [] }\OperatorTok{|}\NormalTok{ a }\OperatorTok{:}\NormalTok{ [a]}
\end{Highlighting}
\end{Shaded}

In words: The type \texttt{{[}a{]}} is the type of lists with values of
type \texttt{a}. Such a list is either the empty list, written as
\texttt{{[}{]}}, or it is a non-empty list consisting of a head
\texttt{x} of type \texttt{a}, and a tail \texttt{xs}, and is written as
\texttt{x:xs}. Note that the constructor \texttt{(:)}, called ``cons'',
is using operator syntax.

There is even more special syntax for lists:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Finite lists can be written as \texttt{{[}1,\ 2,\ 3{]}} instead of
  \texttt{1\ :\ 2\ :\ 3\ :\ {[}{]}}.
\item
  Lists of numbers can be enumerated, e.g.~\texttt{{[}1..10{]}}, or
  \texttt{{[}0,2..10{]}}, or even (due to laziness) \texttt{{[}1..{]}}.
\item
  List comprehensions look like
  \texttt{{[}\ (x,y)\ \textbar{}\ x\ \textless{}-\ xs,\ y\ \textless{}-\ ys,\ x\ \textless{}\ y\ {]}},
  reminiscent of the set comprehension syntax from mathematics. We will
  not discuss them now, I just wanted to show them and give you terms to
  search for.
\end{enumerate}

Common operations on lists worth knowing are \texttt{(++)} to
concatenate two lists, and \texttt{map} to apply a function to each
element of a list:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{(++) ::}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ [a]}
\FunctionTok{map}\OtherTok{ ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ [b]}
\end{Highlighting}
\end{Shaded}

Lists are very useful for many applications, but they are not a
particularly high-performance data structure -- random access and
concatenation is expensive, and they use quite a bit of memory.
Depending on the application, other types like arrays/vectors, finger
trees, difference lists, maps or sets might be more suitable.

\hypertarget{characters-and-strings}{%
\subsubsection{Characters and strings ☆}\label{characters-and-strings}}

Unexpectedly, Haskell has built-in support for characters and text. A
single character has type \texttt{Char}, and is written in single
quotes, e.g.~\texttt{\textquotesingle{}a\textquotesingle{}},
\texttt{\textquotesingle{}☃\textquotesingle{}},
\texttt{\textquotesingle{}\textbackslash{}\textquotesingle{}\textquotesingle{}},
\texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}},
\texttt{\textquotesingle{}\textbackslash{}xcafe\textquotesingle{}}.
These characters are Unicode code points, and not just 7 or 8 bit
characters.

The built-in type \texttt{String} is just an alias for
\texttt{{[}Char{]}}, i.e.~a list of characters. Haskell supports special
built-in syntax for strings, using double quotes, but this is just
syntactic sugar to the list syntax:

\begin{verbatim}
Prelude> "hello"
"hello"
Prelude> ['h','e','l','l','o']
"hello"
Prelude> 'h':'e':'l':'l':'o':[]
"hello"
\end{verbatim}

Because \texttt{String} is built on the list type, all the usual list
operations, in particular \texttt{(++)} for concatenation, work on
strings as well.

But \texttt{String} also has the same performance issues as lists: While
it is fine to use them in non-critical parts of the code (diagnostic and
error messages, command line and configuration file parsing, filenames),
\texttt{String} is usually the wrong choice if large amounts of strings
need to be processed, e.g.~in a templating library. Additional libraries
provide more suitable data structures, in particular \texttt{ByteString}
for binary data and \texttt{Text} for human-readable text.

\hypertarget{records}{%
\subsection{Records ☆}\label{records}}

Assume you want to create a type that represents an employee in an HR
database. There are a fair number of fields to store -- name, date of
birth, employee number, room, login handle, public key etc. You could
use a tuple with many fields, or create your own data type with a
constructor with many fields, but either way you will have to address
the various fields by their position, which is verbose, easy to get
wrong, and hard to extend.

In such a case, you can use records. These allow you to give names to
the \emph{field} of a constructor, and get some convenience functions
along the way. Here we see how to declare and use them

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Employee} \OtherTok{=} \DataTypeTok{Employee}
\NormalTok{    \{}\OtherTok{ name ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ room ::} \DataTypeTok{Integer}
\NormalTok{    ,}\OtherTok{ pubkey ::} \DataTypeTok{ByteString}
\NormalTok{    \}}

\OtherTok{theBoss ::} \DataTypeTok{Employee}
\NormalTok{theBoss }\OtherTok{=} \DataTypeTok{Employee}\NormalTok{ \{ name }\OtherTok{=} \StringTok{"Don Vito Corleone"}\NormalTok{, room }\OtherTok{=} \DecValTok{101}\NormalTok{, pubkey }\OtherTok{=} \StringTok{"0xAD…"}\NormalTok{ \}}

\OtherTok{willDrownWhenTheFloodComes ::} \DataTypeTok{Employee} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{willDrownWhenTheFloodComes }\DataTypeTok{Employee}\NormalTok{ \{ room }\OtherTok{=}\NormalTok{ r \} }\OtherTok{=}\NormalTok{ r }\OperatorTok{\textless{}} \DecValTok{200}

\OtherTok{moveOneLevelUp ::} \DataTypeTok{Employee} \OtherTok{{-}\textgreater{}} \DataTypeTok{Employee}
\NormalTok{moveOneLevelUp e }\OtherTok{=}\NormalTok{ e \{ room }\OtherTok{=}\NormalTok{ new\_room \}}
  \KeywordTok{where}\NormalTok{ new\_room }\OtherTok{=}\NormalTok{ room e }\OperatorTok{+} \DecValTok{100}
\end{Highlighting}
\end{Shaded}

Record syntax has five aspects:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The declaration has special syntax. In terms of the constructor
  \texttt{Employee}, the declaration is equivalent to

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Employee} \OtherTok{=} \DataTypeTok{Employee} \DataTypeTok{String} \DataTypeTok{Integer} \DataTypeTok{ByteString}
\end{Highlighting}
\end{Shaded}

  and it is always possible to use \texttt{Employee} as a normal prefix
  function in terms and patterns. But the record syntax declaration
  enables the following nice syntactic devices:
\item
  Record creation: Instead of \texttt{Employee\ n\ r\ p} you can write
  \texttt{Employee\ \{\ name\ =\ n;\ pubkey\ =\ p;\ room\ =\ r\ \}}, and
  the order of the fields becomes conveniently irrelevant.
\item
  Record pattern matching. You can also write
  \texttt{Employee\ \{\ name\ =\ n;\ room\ =\ r;\ pubkey\ =\ p\ \}} in a
  pattern, to match on \texttt{Employee} and get \texttt{n}, \texttt{r}
  and \texttt{p} into scope.
\item
  Record update syntax: If we have \texttt{e\ ::\ Employee}, then
  \texttt{e\ \{\ room\ =\ r\textquotesingle{}\ \}} is like an
  \texttt{Employee} and all fields are the same as \texttt{e} with the
  exception of \texttt{room}.
\item
  The names of the fields are available as getters, i.e.~after the above
  definition of \texttt{Employee}, there is a function
  \texttt{room\ ::\ Employee\ -\textgreater{}\ Integer} etc.
\end{enumerate}

Curiously, the record creation or update syntax binds closer than
function applications: \texttt{g\ x\ \{\ f\ =\ y\ \}} is
\texttt{g\ (x\ \{\ f\ =\ y\ \})}, and \emph{not}
\texttt{(g\ x)\ \{\ f\ =\ y\ \}}.

With the language extension \texttt{RecordWildCards} enabled, it is even
possible to write \texttt{Employee\{..\}} in a pattern, and get
\emph{all} fields of the employee record into scope, as variables, as if
one had written
\texttt{Employee\ \{\ name\ =\ name;\ room\ =\ room;\ pubkey\ =\ pubkey\ \}}
(although some say that's bad style, because it is too implicit).

\hypertarget{newtypes}{%
\subsection{Newtypes ☆}\label{newtypes}}

Sometimes you will see a type declaration that uses \texttt{newtype}
instead of \texttt{data}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{Riemann} \OtherTok{=} \DataTypeTok{Riemann}\NormalTok{ (}\DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{Integer}\NormalTok{, }\DataTypeTok{Integer}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

For all purposes relevant to us so far you can mentally replace
\texttt{newtype} with \texttt{data}. There are difference in memory
representation (a \texttt{newtype} is ``free'' in some sense), but that
is, at this level, irrelevant for us.

\hypertarget{type-synonyms}{%
\subsection{Type synonyms ☆}\label{type-synonyms}}

Haskell allows you to introduce new names for existing types. One
example is the type \texttt{String}, which is defined as

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{String} \OtherTok{=}\NormalTok{ [}\DataTypeTok{Char}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

With this declaration, you can use \texttt{String} instead of
\texttt{{[}Char{]}} in your type signatures. They are completely
interchangeable, and a value of type \texttt{String} is still just a
list of characters.

So type synonyms do not introduce any kind of type safety, they merely
make types more readable.

\hypertarget{haddock}{%
\subsection{Haddock ☆}\label{haddock}}

Because knowing the type of a function is already a big step towards
understanding what it does, the usual way of documenting a Haskell API
is very much centered around types. The tool \texttt{haddock} creates
HTML pages from Haskell source files that list all functions with their
type, and -- if present -- the documentation that is attached to it via
a comment.

For Haskell libraries hosted in the central package repository
\emph{Hackage}, this documentation is also provided. For example, you
can learn all about the types and functions that are available by
default by reading the
\href{https://hackage.haskell.org/package/base/docs/Prelude.html}{haddock
page for the prelude}. (There is a bunch of noise there that might not
be relevant to you, like long lists of ``Instances''. You can skip over
them.)

From this documentation you will also find links labeled ``Source'' that
take you to the definition of a type or function in the source code, in
a syntax-highlighted and crosslinked presentation of the source.

Relatedly, you can also effectively search for functions with a certain
type, using a type-based search engine like
\href{https://www.haskell.org/hoogle/}{Hoogle} or
\href{http://hayoo.fh-wedel.de/}{Hayoo}. These can also be set-up
in-house to index your private code base.

\hypertarget{code-structure-small-and-large}{%
\section{Code structure small and
large}\label{code-structure-small-and-large}}

The next big topic we need to learn is how programmers structure their
code. This happens on multiple levels

\begin{itemize}
\tightlist
\item
  in a function: intermediate results are named, local helper functions
  are defined.
\item
  within a file: functions, type signatures, and documentation fragments
  are arranged.
\item
  within a project (library, package): code is spread out in different
  files, and imported from other files.
\item
  between projects: packages are versioned, equipped with meta-data, and
  depend on each other.
\end{itemize}

\hypertarget{let-expressions}{%
\subsection{\texorpdfstring{\texttt{let}-expressions}{let-expressions}}\label{let-expressions}}

The most basic way of adding some structure within an expression is to
give a name to a subexpression, and possibly use it later. So instead of

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{isMultipleOf3 x }\OtherTok{=}\NormalTok{ fixEq sumDigits x }\OperatorTok{==} \DecValTok{3} \OperatorTok{||}\NormalTok{ fixEq sumDigits x }\OperatorTok{==} \DecValTok{6} \OperatorTok{||}
\NormalTok{ fixEq sumDigits x }\OperatorTok{==} \DecValTok{9}
\end{Highlighting}
\end{Shaded}

one could write

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{isMultipleOf3 x }\OtherTok{=}
  \KeywordTok{let}\NormalTok{ y }\OtherTok{=}\NormalTok{ fixEq sumDigits x}
  \KeywordTok{in}\NormalTok{ y }\OperatorTok{==} \DecValTok{3} \OperatorTok{||}\NormalTok{ y }\OperatorTok{==} \DecValTok{6} \OperatorTok{||}\NormalTok{ y }\OperatorTok{==} \DecValTok{9}
\end{Highlighting}
\end{Shaded}

which is arguably easier to read.

Be careful: A \texttt{let} expression in Haskell can always be
recursive, so

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{isMultipleOf3 x }\OtherTok{=}
  \KeywordTok{let}\NormalTok{ x }\OtherTok{=}\NormalTok{ fixEq sumDigits x}
  \KeywordTok{in}\NormalTok{ x }\OperatorTok{==} \DecValTok{3} \OperatorTok{||}\NormalTok{ x }\OperatorTok{==} \DecValTok{6} \OperatorTok{||}\NormalTok{ x }\OperatorTok{==} \DecValTok{9}
\end{Highlighting}
\end{Shaded}

might not do what you expect.

In such a \texttt{let} expression, you can also do pattern-matching,
e.g.~to unpack a tuple:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{sumDigitsWith ::}\NormalTok{ (}\DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Integer}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Integer}
\NormalTok{sumDigitsWith f n}
  \OperatorTok{|}\NormalTok{ n }\OperatorTok{\textless{}} \DecValTok{10} \OtherTok{=}\NormalTok{ f n}
  \OperatorTok{|} \FunctionTok{otherwise} \OtherTok{=}
    \KeywordTok{let}\NormalTok{ (r,d) }\OtherTok{=}\NormalTok{ splitLastDigit n}
    \KeywordTok{in}\NormalTok{ sumDigitsWith f r }\OperatorTok{+}\NormalTok{ f d}
\end{Highlighting}
\end{Shaded}

This is a fine and innocent thing to do if the pattern is
\emph{irrefutable}, i.e.~always succeeds, but is a code smell if it is a
pattern that can fail,
e.g.~\texttt{let\ Just\ x\ =\ something\ in\ \ldots{}}. In the latter
case, a \texttt{case} statement might be more appropriate.

We can also define whole functions in a \texttt{let}-expression, just
like on the top level. This might improve the code of our
run-length-encoding automaton:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{rle ::} \DataTypeTok{Eq}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Stream}\NormalTok{ a (}\DataTypeTok{Integer}\NormalTok{,a)}
\NormalTok{rle }\OtherTok{=}
  \KeywordTok{let}\NormalTok{ start x }\OtherTok{=} \DataTypeTok{NeedInput}\NormalTok{ (count x }\DecValTok{1}\NormalTok{)}
\NormalTok{      count x n x\textquotesingle{} }\OperatorTok{|}\NormalTok{ x }\OperatorTok{==}\NormalTok{ x\textquotesingle{} }\OtherTok{=} \DataTypeTok{NeedInput}\NormalTok{ (count x (n }\OperatorTok{+} \DecValTok{1}\NormalTok{))}
                   \OperatorTok{|} \FunctionTok{otherwise} \OtherTok{=} \DataTypeTok{HasOutput}\NormalTok{ (n, x) (start x\textquotesingle{})}
  \KeywordTok{in} \DataTypeTok{NeedInput}\NormalTok{ start}
\end{Highlighting}
\end{Shaded}

One advantage of this is that the ``internal'' functions \texttt{start}
and \texttt{count} are now no longer available from the outside, and so
a reader of this code knows for sure that these are purely internal. We
can also drop the \texttt{rle\_} prefix.

Another important advantage is that such local functions have access to
the parameters of the enclosing function. To see this in action, let us
extend \texttt{rle} with a parameter that indicates an element of the
stream that should make the automaton stop:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{rle ::} \DataTypeTok{Eq}\NormalTok{ a }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Stream}\NormalTok{ a (}\DataTypeTok{Integer}\NormalTok{,a)}
\NormalTok{rle stop }\OtherTok{=}
  \KeywordTok{let}\NormalTok{ start x }\OperatorTok{|}\NormalTok{ x }\OperatorTok{==}\NormalTok{ stop }\OtherTok{=} \DataTypeTok{Done}
              \OperatorTok{|} \FunctionTok{otherwise} \OtherTok{=} \DataTypeTok{NeedInput}\NormalTok{ (count x }\DecValTok{1}\NormalTok{)}
\NormalTok{      count x n x\textquotesingle{} }\OperatorTok{|}\NormalTok{ x }\OperatorTok{==}\NormalTok{ x\textquotesingle{} }\OtherTok{=} \DataTypeTok{NeedInput}\NormalTok{ (count x (n }\OperatorTok{+} \DecValTok{1}\NormalTok{))}
                   \OperatorTok{|} \FunctionTok{otherwise} \OtherTok{=} \DataTypeTok{HasOutput}\NormalTok{ (n, x) (start x\textquotesingle{})}
  \KeywordTok{in} \DataTypeTok{NeedInput}\NormalTok{ start}
\end{Highlighting}
\end{Shaded}

In \texttt{start} we can now access \texttt{stop} just fine. If
\texttt{start} and \texttt{count} were not local functions, then we
would have to add \texttt{stop} as an explicit parameter to \emph{both}
local functions, significantly cluttering the code with administrative
details.

\hypertarget{where-clauses}{%
\subsection{\texorpdfstring{\texttt{where}-clauses
☆}{where-clauses ☆}}\label{where-clauses}}

I think few syntactic features show that Haskell's syntax is designed
with readability in mind, valuing that higher than syntactic minimalism,
as well as the \texttt{where} clauses.

Looking the previous version of the \texttt{rle} program, a very picky
reader might complain that it is annoying to have to first read past
\texttt{start} and \texttt{count} to see the last line, when the last
line is logically the first to be executed.

Therefore, the programmer has the option to use a \texttt{where}-clause
instead of a \texttt{let} expression here. A \texttt{where}-clause is
attached to a function equation (or, more rarely, to a match in a
\texttt{case} expression), has access to its parameters and -- most
crucially -- is written after or below the right-hand side of the
equation:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{rle ::} \DataTypeTok{Eq}\NormalTok{ a }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Stream}\NormalTok{ a (}\DataTypeTok{Integer}\NormalTok{,a)}
\NormalTok{rle stop }\OtherTok{=} \DataTypeTok{NeedInput}\NormalTok{ start}
  \KeywordTok{where}
\NormalTok{    start x }\OperatorTok{|}\NormalTok{ x }\OperatorTok{==}\NormalTok{ stop }\OtherTok{=} \DataTypeTok{Done}
            \OperatorTok{|} \FunctionTok{otherwise} \OtherTok{=} \DataTypeTok{NeedInput}\NormalTok{ (count x }\DecValTok{1}\NormalTok{)}

\NormalTok{    count x n x\textquotesingle{} }\OperatorTok{|}\NormalTok{ x }\OperatorTok{==}\NormalTok{ x\textquotesingle{} }\OtherTok{=} \DataTypeTok{NeedInput}\NormalTok{ (count x (n }\OperatorTok{+} \DecValTok{1}\NormalTok{))}
                 \OperatorTok{|} \FunctionTok{otherwise} \OtherTok{=} \DataTypeTok{HasOutput}\NormalTok{ (n, x) (start x\textquotesingle{})}
\end{Highlighting}
\end{Shaded}

It is not a huge change, but one that -- in my humble opinion --
improves readability by a small but noticeable bit.

If you have a function with multiple guards on one equation, such as
\texttt{start}, then a \texttt{where} clause scopes over all such
guards. So we could write

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{sumDigitsWith ::}\NormalTok{ (}\DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Integer}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{Integer}
\NormalTok{sumDigitsWith f n}
  \OperatorTok{|}\NormalTok{ n }\OperatorTok{\textless{}} \DecValTok{10} \OtherTok{=}\NormalTok{ f d}
  \OperatorTok{|} \FunctionTok{otherwise} \OtherTok{=}\NormalTok{ sumDigitsWith f r }\OperatorTok{+}\NormalTok{ f d}
  \KeywordTok{where}\NormalTok{ (r,d) }\OtherTok{=}\NormalTok{ splitLastDigit n}
\end{Highlighting}
\end{Shaded}

(note that \texttt{d} is used in both right-hand sides) if we wanted.

\hypertarget{comments}{%
\subsection{Comments ☆}\label{comments}}

Of course, Haskell supports comments. There are line comments and
multi-line comments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{answer }\OtherTok{=} \DecValTok{42} \CommentTok{{-}{-} but what is the question?}

\CommentTok{\{{-}}
\CommentTok{In the following code, we write a function that correctly tells}
\CommentTok{us whether a Turing machine halts:}
\CommentTok{{-}\}}
\OtherTok{halts ::} \DataTypeTok{TuringMachine} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{halts turing\_machine }\OtherTok{=}\NormalTok{ halts turing\_machine}
\end{Highlighting}
\end{Shaded}

The \texttt{haddock} Haskell documentation tool uses specially marked
comments for documentation, so the above could better be written as
(note the vertical bar):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\{{-} |}
\CommentTok{In the following code, we write a function that correctly tells}
\CommentTok{us whether a turing machine halts:}
\CommentTok{{-}\}}
\OtherTok{halts ::} \DataTypeTok{TuringMachine} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{halts turing\_machine }\OtherTok{=}\NormalTok{ halts turing\_machine}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-structure-of-a-module}{%
\subsection{The structure of a module}\label{the-structure-of-a-module}}

As we zoom out one step, we get to look at a Haskell file as a whole. In
Haskell, every file is also a Haskell \emph{module}, and modules are
used to organize namespaces.

Normally, a Haskell module named \texttt{Foo.Bar.Baz} lives in a file
\texttt{Foo/Bar/Baz.hs}, and begins with

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} in file Foo/Bar/Baz.hs}
\KeywordTok{module} \DataTypeTok{Foo.Bar.Baz} \KeywordTok{where}
\end{Highlighting}
\end{Shaded}

Haskell module names are always capitalized.

If a file does not have such a header (which is usually only the case
for experiments and the entry point of a Haskell program), then it is
implicitly called \texttt{Main}. This is why the GHCi prompt says
\texttt{Main\textgreater{}} after loading such a file.

The rest of the module are declarations: Values, functions, types, type
synonyms etc. The important bit to know here is that the order of
declarations is completely irrelevant: You can use functions that are
defined further down, you can mix type and function declarations, you
can even separate the type signature of a function from its definition
(but you have to keep multiple equations of one function together). This
allows the author to sort functions by topic, or by relevance, rather
than by dependency, and it is not uncommon to first show the main
entry-point of a module, and put all the helper functions it uses below.

\hypertarget{importing-other-modules}{%
\subsection{Importing other modules}\label{importing-other-modules}}

Obviously, the point of having multiple files of Haskell code is to use
the code from one in the other. This is achieved using \texttt{import}
statements, which \emph{must} come right after the \texttt{module}
header, and before any declarations.

So if we have a file \texttt{Target.hs} with content

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} file Target.hs}
\KeywordTok{module} \DataTypeTok{Target} \KeywordTok{where}
\OtherTok{who ::} \DataTypeTok{String}
\NormalTok{who }\OtherTok{=} \StringTok{"world"}
\end{Highlighting}
\end{Shaded}

and another file \texttt{Tropes.hs} with content

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} file Tropes.hs}
\KeywordTok{module} \DataTypeTok{Tropes} \KeywordTok{where}

\KeywordTok{import} \DataTypeTok{Target}

\OtherTok{greeting ::} \DataTypeTok{String}
\NormalTok{greeting }\OtherTok{=} \StringTok{"Hello "} \OperatorTok{++}\NormalTok{ who }\OperatorTok{++} \StringTok{"!"}
\end{Highlighting}
\end{Shaded}

then the use of \texttt{who} in \texttt{greeting} refers to the
definition in the file \texttt{Target.hs}.

We could also write

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{greeting ::} \DataTypeTok{String}
\NormalTok{greeting }\OtherTok{=} \StringTok{"Hello "} \OperatorTok{++}\NormalTok{ Target.who }\OperatorTok{++} \StringTok{"!"}
\end{Highlighting}
\end{Shaded}

and use the \emph{fully qualified} name of \texttt{who}. This can be
useful for disambiguation, or simply for clarity. There must not be
spaces around the period, or else it would refer to the composition
operator.

If we only ever intend to refer to the things we import from a module by
their qualified names, then we can use a \emph{qualified} import:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import} \KeywordTok{qualified} \DataTypeTok{Target}
\end{Highlighting}
\end{Shaded}

This does not bring any unqualified names into scope.

And if the module has a long name, we can shorten it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import} \KeywordTok{qualified} \DataTypeTok{Target} \KeywordTok{as} \DataTypeTok{T}
\end{Highlighting}
\end{Shaded}

and write \texttt{T.who}. This is a common idiom for modules like
\texttt{Data.Text} that export many names that would otherwise clash
with names from the prelude.

The standard library, called \texttt{base}, comes with
\href{http://hackage.haskell.org/package/base}{many modules you can
import} in addition to the \texttt{Prelude} module, which is always
imported implicitly.

\hypertarget{import-lists}{%
\subsection{Import lists ☆}\label{import-lists}}

If we do not want to import \emph{all} names of another module, we can
import just a specific selection, e.g.:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import} \DataTypeTok{Data.Maybe}\NormalTok{ (mapMaybe)}
\end{Highlighting}
\end{Shaded}

This makes it easier for someone reading the code to locate where a
certain function is from, and it makes the code more robust against
breakage when a new version of the other module starts exporting
additional names. These would not silently override other names, but
cause compiler errors about ambiguous names.

When including an operator in this list, include it in parentheses:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import} \DataTypeTok{Data.Function}\NormalTok{ ((\&), on)}
\end{Highlighting}
\end{Shaded}

You can import types just as well, just include them in the list. To
import \emph{constructors} (which look like types), you have to list
them after the type they belong to. So if we put our definitions of
\texttt{Complex} and \texttt{Riemann} into a file \texttt{Riemann.hs},
namely

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} file Riemann.hs}
\KeywordTok{module} \DataTypeTok{Riemann} \KeywordTok{where}
\KeywordTok{data} \DataTypeTok{Complex} \OtherTok{=} \DataTypeTok{C} \DataTypeTok{Integer} \DataTypeTok{Integer}
\KeywordTok{data} \DataTypeTok{Riemann} \OtherTok{=} \DataTypeTok{Complex} \DataTypeTok{Complex} \OperatorTok{|} \DataTypeTok{Infinity}
\end{Highlighting}
\end{Shaded}

then you can import everything using

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import} \DataTypeTok{Riemann}\NormalTok{ (}\DataTypeTok{Complex}\NormalTok{(}\DataTypeTok{C}\NormalTok{), }\DataTypeTok{Riemann}\NormalTok{(}\DataTypeTok{Complex}\NormalTok{, }\DataTypeTok{Infinity}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

or, shorter,

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import} \DataTypeTok{Riemann}\NormalTok{ (}\DataTypeTok{Complex}\NormalTok{(..), }\DataTypeTok{Riemann}\NormalTok{(..))}
\end{Highlighting}
\end{Shaded}

\hypertarget{export-lists-and-abstract-types}{%
\subsection{Export lists and abstract types
☆}\label{export-lists-and-abstract-types}}

You can not only restrict what you import, but also what you export. To
do so, you list the names of functions, types, etc. that you want to
export after the module name:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{module} \DataTypeTok{Riemann}\NormalTok{ (}\DataTypeTok{Complex}\NormalTok{, }\DataTypeTok{Riemann}\NormalTok{(}\OperatorTok{..}\NormalTok{)) }\KeywordTok{where}
\NormalTok{…}
\end{Highlighting}
\end{Shaded}

A short export list is a great help when trying to understand the role
and purpose of a module: If it only exports one or a small number of
functions, it is clear that these are the (only) entry points to the
code, and that all other declarations are purely internal, and may be
refactored without affecting anything else.

By excluding the constructors of a data type from the export list, as we
did in this example with the \texttt{Complex} type, we can make this
type \emph{abstract}: Users of our module now have no knowledge of the
internal structure of \texttt{Complex}, and they are unable to create or
arbitrarily inspect values of type \texttt{Complex}. Instead, they are
only able to do so using the \emph{other} functions that we export along
with \texttt{Complex}. This way we can ensure certain invariants in our
types -- think of a search tree with the invariant that it is sorted --
or reserve the ability to change the shape of the type without breaking
depending code.

Proper user of abstract types greatly helps to make code more readable,
more maintainable and more robust, quite similar to how polymorphism
does it on a smaller scale.

\hypertarget{language-extensions}{%
\subsection{Language extensions}\label{language-extensions}}

Haskell is a language with a reasonably precise specification, the
\emph{Haskell Report}. When someone mentions Haskell 98, they refer to
Haskell as specified in the
\href{https://www.haskell.org/onlinereport/}{Haskell Report from 1998}.
There was one revision, the
\href{https://www.haskell.org/onlinereport/haskell2010/}{Haskell Report
from 2010}, with only rather small changes.

Since 1998, Haskell developers and implementors wanted to add more and
more features to the language. But the report was written, and the
compiler writers wanted to support Haskell, as specified, by default.
Therefore, the system of \emph{language extensions} was introduced.

A language extension is a feature that extends Haskell98 in some way. It
could add more syntactic sugar, additional features of the type system
or enable whole meta-programming facilities. A Haskell source file needs
to explicitly declare the extensions they are using, right at the top
before the \texttt{module} header, and a typical Haskell file these days
might start with a number of them, and look like this:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{\{{-}\# LANGUAGE ApplicativeDo \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE CPP \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE DataKinds \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE FlexibleContexts \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE MonoLocalBinds \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE OverloadedStrings \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE PartialTypeSignatures \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE RecordWildCards \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE ScopedTypeVariables \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE TypeFamilies \#{-}\}}
\KeywordTok{module} \DataTypeTok{Foo} \KeywordTok{where}
\end{Highlighting}
\end{Shaded}

These language extensions (and there are many of them) are
\href{https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html\#language-options}{documented
in the GHC user's guide}.

You can also enable language extensions on the GHCi prompt, e.g.~using
\texttt{:set\ -XRecordWildCards}.

\hypertarget{haskell-packages}{%
\subsection{Haskell packages ☆}\label{haskell-packages}}

Zooming out some more, we come across packages: A \emph{package} is a
collection of modules that are bundled under a single package name. A
package contains meta-data (name, version number, author,
license\ldots). Packages declare which other packages they depend upon,
together with version ranges. All this meta-data can be found in the
\emph{Cabal file} called \texttt{foo.cabal} in the root directory of the
project.

Almost all publicly available Haskell packages are hosted centrally on
\href{http://hackage.haskell.org/packages/}{Hackage}, including the
haddock-generated documentation and cross-linked source code. They can
be easily installed using the
\href{https://www.haskell.org/cabal/}{\texttt{cabal} tool}, or
alternative systems like
\href{https://www.haskellstack.org/}{\texttt{stack}} or
\href{https://nixos.org/nixpkgs/manual/\#users-guide-to-the-haskell-infrastructure}{\texttt{nix}}.
The packages on Hackage cover many common needs and it is expected that
a serious Haskell project depends on dozen of Haskell packages from
Hackage.

\hypertarget{io}{%
\section{Imperative (looking) Haskell ☆}\label{io}}

In the first chapter I explained that \protect\hyperlink{pure}{Haskell
is pure}; its expressions simply denote values, but they do not
\emph{do} anything. Yet people out there write useful programs with
Haskell. How is that possible?

The real reason is a beautiful and elegant concept called a monad, and
we have a \protect\hyperlink{monads}{whole chapter dedicated to monads}.
If you plan to read that, you can skip the present chapter. But if you
are eager to see how Haskell code can read user input and write to
files, then this chapter provides a quick introduction to reading such
imperative code.

\textbf{Beware:} This chapter is full of half-truths and glossing over
technical details. Imagine plenty of ``it looks as if'' and ``one can
think of this as'' sprinkled throughout it. Nevertheless, it is useful
to get you started.

\hypertarget{io-functions}{%
\subsection{\texorpdfstring{\texttt{IO}-functions}{IO-functions}}\label{io-functions}}

Previously we said that Haskell functions are pure functions in the
mathematical sense: Given some input, they calculate some output, but
nothing else can happen, and nothing besides the arguments can influence
the result. This is great, but how can Haskell programs then write to
files, or respond to network requests, or come up with random numbers?

The solution are \texttt{IO}-functions. These functions can be
\emph{executed}, and when such a function is executed, it can do all
these nasty things, before returning a value. Here is a selection of
\texttt{IO}-functions available by default:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getLine}\OtherTok{ ::} \DataTypeTok{IO} \DataTypeTok{String}
\FunctionTok{putStrLn}\OtherTok{ ::} \DataTypeTok{String} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}

\FunctionTok{readFile}\OtherTok{ ::} \DataTypeTok{FilePath} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO} \DataTypeTok{String}
\FunctionTok{writeFile}\OtherTok{ ::} \DataTypeTok{FilePath} \OtherTok{{-}\textgreater{}} \DataTypeTok{String} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\end{Highlighting}
\end{Shaded}

You can see that these functions may have arguments, just as normal
functions. The important bit is the return type, which is
\texttt{IO\ Something}. This indicates that these functions can be
executed, and that they have to be executed before we get our hands on
the result.

Not all functions have an interesting result (e.g.~\texttt{putStrLn}
does not); this is where the unit type comes in handy.

\hypertarget{the-main-function-and-do-notation}{%
\subsection{\texorpdfstring{The \texttt{main} function and \texttt{do}
notation}{The main function and do notation}}\label{the-main-function-and-do-notation}}

To execute these functions, we have to use a special syntax, called
\texttt{do}-notation, that allows us to write code in an imperative
style. Here is an example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{main }\OtherTok{=} \KeywordTok{do}
    \FunctionTok{putStrLn} \StringTok{"Which file do you want to copy?"}
\NormalTok{    from }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
    \FunctionTok{putStrLn} \StringTok{"Where do you want to copy it to?"}
\NormalTok{    to }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
\NormalTok{    content }\OtherTok{\textless{}{-}} \FunctionTok{readFile}\NormalTok{ from}
    \FunctionTok{putStrLn}\NormalTok{ (}\StringTok{"Read "} \OperatorTok{++} \FunctionTok{show}\NormalTok{ (}\FunctionTok{length}\NormalTok{ content) }\OperatorTok{++} \StringTok{" bytes."}\NormalTok{)}
    \FunctionTok{writeFile}\NormalTok{ to content}
    \FunctionTok{putStrLn} \StringTok{"Done copying."}
\end{Highlighting}
\end{Shaded}

we can compile and run this program, and it indeed copies a file:

\begin{verbatim}
$ ghc --make copy.hs
[1 of 1] Compiling Main             ( copy.hs, copy.o )
Linking copy ...
$ ./copy
Which file do you want to copy?
copy.hs
Where do you want to copy it to?
copy2.hs
Read 287 bytes.
Done copying.
$ diff copy.hs copy2.hs
\end{verbatim}

Looking at the code, it doesn't look much different than the equivalent
in a language like C or Python. Things to notice:

\begin{itemize}
\tightlist
\item
  The \texttt{main} function of the module is special. Just like in C,
  it is the entry point for a compiled Haskell program. When we run the
  program, then the \texttt{main} function is executed. This is the only
  way to start executing \texttt{IO}-functions -- we cannot do that just
  nilly-willy within other code.
\item
  The body of the \texttt{main} function is written as a \texttt{do}
  block, which clearly signposts the imperative nature of this code: It
  is a sequence of things to \texttt{do}.
\item
  Every line below the \texttt{do} block is one execution of an
  \texttt{IO}-function. The first one, for example, prints a question on
  the terminal.
\item
  Some of these \texttt{IO}-functions return values that we want to use
  later on. These we \emph{bind} to variables, using the
  \texttt{\textless{}-} syntax. (The last line of a \texttt{do} block is
  never such a binding, can you imagine why?)
\item
  The \texttt{main} function has type \texttt{IO\ ()}. So it is one of
  these \texttt{IO}-functions as well.
\end{itemize}

\hypertarget{writing-io-functions}{%
\subsection{\texorpdfstring{Writing \texttt{IO}
functions}{Writing IO functions}}\label{writing-io-functions}}

We do not only want to execute \texttt{IO} functions, but also define
our own. This is not hard, and we have actually seen that before -- the
\texttt{main} function is one. We can add parameters without further
problems:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{copyFile ::} \DataTypeTok{FilePath} \OtherTok{{-}\textgreater{}} \DataTypeTok{FilePath} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{copyFile from to }\OtherTok{=} \KeywordTok{do}
\NormalTok{    content }\OtherTok{\textless{}{-}} \FunctionTok{readFile}\NormalTok{ from}
    \FunctionTok{putStrLn}\NormalTok{ (}\StringTok{"Read "} \OperatorTok{++} \FunctionTok{show}\NormalTok{ (}\FunctionTok{length}\NormalTok{ content) }\OperatorTok{++} \StringTok{" bytes."}\NormalTok{)}
    \FunctionTok{writeFile}\NormalTok{ to content}

\OtherTok{main ::} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{main }\OtherTok{=} \KeywordTok{do}
    \FunctionTok{putStrLn} \StringTok{"Which file do you want to copy?"}
\NormalTok{    from }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
    \FunctionTok{putStrLn} \StringTok{"Where do you want to copy it to?"}
\NormalTok{    to }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
\NormalTok{    copyFile from to}
    \FunctionTok{putStrLn} \StringTok{"Done copying."}
\end{Highlighting}
\end{Shaded}

All our knowledge about defining functions -- parameters, pattern
matching, recursion -- applies here as well.

\hypertarget{the-return-function}{%
\subsection{\texorpdfstring{The \texttt{return}
function}{The return function}}\label{the-return-function}}

The last \texttt{IO} function executed in a \texttt{do} block of an
\texttt{IO} function also determines its return value. Therefore we need
the little function

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{return}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

if, at the end of an \texttt{IO} function, we \emph{only} want to return
something:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{fileSize ::} \DataTypeTok{FilePath} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO} \DataTypeTok{Integer}
\NormalTok{fileSize path }\OtherTok{=} \KeywordTok{do}
\NormalTok{  content }\OtherTok{\textless{}{-}} \FunctionTok{readFile}\NormalTok{ path}
  \FunctionTok{return}\NormalTok{ (}\FunctionTok{length}\NormalTok{ content)}
\end{Highlighting}
\end{Shaded}

\textbf{Important:} Note that \texttt{return} does \emph{not} alter the
control flow. It does not make the function return. It merely specifies
the return values of the current \emph{line}.

\textbf{Exercise 19}

What does this program print?

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{theAnswer ::} \DataTypeTok{IO} \DataTypeTok{Integer}
\NormalTok{theAnswer }\OtherTok{=} \KeywordTok{do}
  \FunctionTok{putStrLn} \StringTok{"Pondering the question..."}
  \FunctionTok{return} \DecValTok{23}
  \FunctionTok{return} \DecValTok{42}

\OtherTok{main ::} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{main }\OtherTok{=} \KeywordTok{do}
\NormalTok{  a }\OtherTok{\textless{}{-}}\NormalTok{ theAnswer}
  \FunctionTok{putStrLn}\NormalTok{ (}\FunctionTok{show}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

\hypertarget{passing-io-functions-around}{%
\subsection{\texorpdfstring{Passing \texttt{IO} functions
around}{Passing IO functions around}}\label{passing-io-functions-around}}

Just passing arguments to \texttt{copyFile} does not actually do
anything: we really have to execute it, and execution happens when a
function is executed from \texttt{main} (directly or indirectly). Let me
demonstrate this point:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{copyFile ::} \DataTypeTok{FilePath} \OtherTok{{-}\textgreater{}} \DataTypeTok{FilePath} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{copyFile from to }\OtherTok{=} \KeywordTok{do}
\NormalTok{    content }\OtherTok{\textless{}{-}} \FunctionTok{readFile}\NormalTok{ from}
    \FunctionTok{putStrLn}\NormalTok{ (}\StringTok{"Read "} \OperatorTok{++} \FunctionTok{show}\NormalTok{ (}\FunctionTok{length}\NormalTok{ content) }\OperatorTok{++} \StringTok{" bytes."}\NormalTok{)}
    \FunctionTok{writeFile}\NormalTok{ to content}

\OtherTok{ignore ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{ignore unused }\OtherTok{=} \FunctionTok{putStrLn} \StringTok{"I ignore my argument!"}

\OtherTok{main ::} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{main }\OtherTok{=} \KeywordTok{do}
    \FunctionTok{putStrLn} \StringTok{"Which file do you want to copy?"}
\NormalTok{    from }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
    \FunctionTok{putStrLn} \StringTok{"Where do you want to copy it to?"}
\NormalTok{    to }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
\NormalTok{    ignore (copyFile from to)}
    \FunctionTok{putStrLn} \StringTok{"Done copying."}
\end{Highlighting}
\end{Shaded}

Executing this program will ask for the filenames, but it will not
actually copy anything. This is because, although we passed all the
required arguments to \texttt{copyFile}, we did not actually execute it.

That said, the problem was not that we passed
\texttt{copyFile\ from\ to} as an argument to a function. Rather, the
problem was that \texttt{ignore} did not do anything with it. We can fix
that easily (and rename the function to
\texttt{don\textquotesingle{}tignore} along the way):

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{copyFile ::} \DataTypeTok{FilePath} \OtherTok{{-}\textgreater{}} \DataTypeTok{FilePath} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{copyFile from to }\OtherTok{=} \KeywordTok{do}
\NormalTok{    content }\OtherTok{\textless{}{-}} \FunctionTok{readFile}\NormalTok{ from}
    \FunctionTok{putStrLn}\NormalTok{ (}\StringTok{"Read "} \OperatorTok{++} \FunctionTok{show}\NormalTok{ (}\FunctionTok{length}\NormalTok{ content) }\OperatorTok{++} \StringTok{" bytes."}\NormalTok{)}
    \FunctionTok{writeFile}\NormalTok{ to content}

\OtherTok{don\textquotesingle{}tignore ::} \DataTypeTok{IO}\NormalTok{ () }\OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{don\textquotesingle{}tignore action }\OtherTok{=} \KeywordTok{do}
    \FunctionTok{putStrLn} \StringTok{"About to execute the action."}
\NormalTok{    action}
    \FunctionTok{putStrLn} \StringTok{"I executed the action."}

\OtherTok{main ::} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{main }\OtherTok{=} \KeywordTok{do}
    \FunctionTok{putStrLn} \StringTok{"Which file do you want to copy?"}
\NormalTok{    from }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
    \FunctionTok{putStrLn} \StringTok{"Where do you want to copy it to?"}
\NormalTok{    to }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
\NormalTok{    don\textquotesingle{}tignore (copyFile from to)}
    \FunctionTok{putStrLn} \StringTok{"Done copying."}
\end{Highlighting}
\end{Shaded}

This way, the \texttt{copyFile\ from\ to} function receives its
parameters in the \texttt{main} function, but \emph{is not yet
executed}. It is then passed to \texttt{don\textquotesingle{}tignore},
which does something else first (it prints
\texttt{"About\ to\ execute\ the\ action."}), and \emph{then} executes
the action.

\begin{verbatim}
$ ./copy
Which file do you want to copy?
copy.hs
Where do you want to copy it to?
copy2.hs
About to execute the action.
Read 549 bytes.
I executed the action.
Done copying.
\end{verbatim}

Being able to abstract over \texttt{IO}-functions just like over
anything else, and having precise control when they are \emph{executed}
(rather than just passed around), is a very powerful tool.

\textbf{Exercise 20}

What does this program do?

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{foo ::} \DataTypeTok{Integer} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ () }\OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{foo }\DecValTok{0}\NormalTok{ a }\OtherTok{=} \FunctionTok{putStrLn} \StringTok{"Done"}
\NormalTok{foo n a }\OtherTok{=} \KeywordTok{do}
   \KeywordTok{if}\NormalTok{ n }\OperatorTok{==} \DecValTok{1} \KeywordTok{then} \FunctionTok{putStrLn} \StringTok{"Almost done"}
             \KeywordTok{else} \FunctionTok{return}\NormalTok{ ()}
\NormalTok{   a}
\NormalTok{   foo (n}\OperatorTok{{-}}\DecValTok{1}\NormalTok{) a}

\OtherTok{main ::} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{main }\OtherTok{=} \KeywordTok{do}
\NormalTok{   foo }\DecValTok{4}\NormalTok{ (}\FunctionTok{putStrLn} \StringTok{"Hooray!"}\NormalTok{)}
\NormalTok{   foo }\DecValTok{0}\NormalTok{ (}\FunctionTok{putStrLn} \StringTok{"And up she rises."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{let-in-do}{%
\subsection{\texorpdfstring{\texttt{let} in \texttt{do}
☆}{let in do ☆}}\label{let-in-do}}

You can use \texttt{let} expressions in \texttt{do} blocks, omitting the
\texttt{in}. These work like normal \texttt{let} expressions,
i.e.~simply give a name to an expression:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{main ::} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{main }\OtherTok{=} \KeywordTok{do}
    \FunctionTok{putStrLn} \StringTok{"Which file do you want to copy?"}
\NormalTok{    from }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
    \KeywordTok{let}\NormalTok{ to }\OtherTok{=}\NormalTok{ from }\OperatorTok{++} \StringTok{".bak"}
\NormalTok{    copyFile from to}
    \FunctionTok{putStrLn}\NormalTok{ (}\StringTok{"Created backup at "} \OperatorTok{++}\NormalTok{ to)}
\end{Highlighting}
\end{Shaded}

Note that it does \emph{not} execute anything, as this example shows:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{main ::} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{main }\OtherTok{=} \KeywordTok{do}
    \FunctionTok{putStrLn} \StringTok{"Please press enter."}
\NormalTok{    input1 }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
    \FunctionTok{putStrLn} \StringTok{"Enter pressed."}

    \FunctionTok{putStrLn} \StringTok{"Please press enter."}
    \KeywordTok{let}\NormalTok{ input2 }\OtherTok{=} \FunctionTok{getLine}
    \FunctionTok{putStrLn} \StringTok{"Enter pressed."}
\end{Highlighting}
\end{Shaded}

If we run this only the first occurrence to \texttt{getLine} actually
does something:

\begin{verbatim}
$ ghc --make let-do.hs
[1 of 1] Compiling Main             ( let-do.hs, let-do.o )
Linking let-do ...
$ ./let-do
Please press enter.

Enter pressed.
Please press enter.
Enter pressed.
\end{verbatim}

The variable \texttt{input2} is named misleadingly: It does not name any
user input, the way it is define it is merely an alternative name for
the \texttt{IO} function \texttt{getLine}.

\hypertarget{the-operator}{%
\subsection{\texorpdfstring{The \texttt{\textless{}\$\textgreater{}}
operator
☆}{The \textless\$\textgreater{} operator ☆}}\label{the-operator}}

You will come across code that wants to execute an \texttt{IO} function
\emph{and} apply some normal (pure) function to its result in one go,
like the \texttt{fileSize} function above. We can use the
\texttt{\textless{}\$\textgreater{}} operator to write that in one line,
without giving a name to the intermediate value:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{fileSize ::} \DataTypeTok{FilePath} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO} \DataTypeTok{Integer}
\NormalTok{fileSize path }\OtherTok{=} \FunctionTok{length} \OperatorTok{\textless{}$\textgreater{}} \FunctionTok{readFile}\NormalTok{ path}
\end{Highlighting}
\end{Shaded}

When reading such code, you can think of
\texttt{\textless{}\$\textgreater{}} as a variant of \texttt{\$}, with
the difference that the \emph{return value} of the expression on the
right hand side is passed to the function on the left, and not the
\texttt{IO} function as a whole.

\hypertarget{type-classes}{%
\section{Type classes}\label{type-classes}}

The language features we have seen so far can be found, with slight
variations, in most functional programming languages. In this chapter,
we will look at a feature that Haskell is particularly renowned for:
\emph{Type classes}.

Let me start by pointing out what type classes are not: They are not
classes as we know them from object oriented programming, so please do
not try to attempt to understand them by analogy to that.

Instead, type classes are a language feature that provides, in sequence
of sophistication,

\begin{itemize}
\tightlist
\item
  overloading of operators and function,
\item
  implicit dependency injection,
\item
  polymorphism over types with structure, and
\item
  type-driven code synthesis.
\end{itemize}

We have actually seen most of these applications already:

\hypertarget{overloading}{%
\subsection{Overloading}\label{overloading}}

Assume, for a moment, that \texttt{(==)} operator we have seen already
only works on \texttt{Integer}. Surely, it is no problem to define
equality on, say, \texttt{Complex} and \texttt{Riemann}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{eqComplex ::} \DataTypeTok{Complex} \OtherTok{{-}\textgreater{}} \DataTypeTok{Complex} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{eqComplex (}\DataTypeTok{C}\NormalTok{ x1 y1) (}\DataTypeTok{C}\NormalTok{ x2 y2) }\OtherTok{=}\NormalTok{ x1 }\OperatorTok{==}\NormalTok{ x2 }\OperatorTok{\&\&}\NormalTok{ y1 }\OperatorTok{==}\NormalTok{ y2}

\OtherTok{eqRiemann ::} \DataTypeTok{Riemann} \OtherTok{{-}\textgreater{}} \DataTypeTok{Riemann} \OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{eqRiemann (}\DataTypeTok{Complex}\NormalTok{ c1) (}\DataTypeTok{Complex}\NormalTok{ c2) }\OtherTok{=}\NormalTok{ c1 }\OtherTok{\textasciigrave{}eqComplex\textasciigrave{}}\NormalTok{ c2}
\NormalTok{eqRiemann }\DataTypeTok{Infinity} \DataTypeTok{Infinity} \OtherTok{=} \DataTypeTok{True}
\NormalTok{eqRiemann \_ \_ }\OtherTok{=} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

Similarly, we can define comparisons, numeric operators etc. This is
good enough to express most of the code that we want to write, but it is
terribly verbose and annoying to remember the name of the right equality
function, and have the type (in the name) be repeated all over the code.

What we really want is to use the nice \texttt{(==)} syntax, but we want
it to mean \emph{different things at different types} -- overloading!

In order to do that, we first have to declare that \texttt{(==)} is an
operator name that can be overloaded, by declaring a class with it as a
method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Eq}\NormalTok{ a }\KeywordTok{where}
\OtherTok{    (==) ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\end{Highlighting}
\end{Shaded}

Of course, the \texttt{Eq} class is already defined. From now on, I can
use \texttt{(==)} with every type that is an \emph{instance} of
\texttt{Eq}. We can declare instances for \texttt{Complex} and
\texttt{Riemann}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Eq} \DataTypeTok{Complex} \KeywordTok{where}
    \DataTypeTok{C}\NormalTok{ x1 y1 }\OperatorTok{==} \DataTypeTok{C}\NormalTok{ x2 y2 }\OtherTok{=}\NormalTok{ x1 }\OperatorTok{==}\NormalTok{ x2 }\OperatorTok{\&\&}\NormalTok{ y1 }\OperatorTok{==}\NormalTok{ y2}
\KeywordTok{instance} \DataTypeTok{Eq} \DataTypeTok{Riemann} \KeywordTok{where}
\NormalTok{    (}\OperatorTok{==}\NormalTok{) }\OtherTok{=}\NormalTok{ eqRiemann}
\end{Highlighting}
\end{Shaded}

and with this in place, we can use \texttt{(==)} not only for
\texttt{Integer}, but also \texttt{Complex} and \texttt{Riemann}. In
fact, we can use \texttt{(==)} instead of \texttt{eqComplex} in the
definition of \texttt{eqRiemann} -- remember that the order of
declarations is irrelevant in a Haskell module.

Now we can hopefully better understand the type signature of
\texttt{(==)}:

\begin{verbatim}
Prelude> :t (==)
(==) :: Eq a => a -> a -> Bool
\end{verbatim}

The part after the \texttt{=\textgreater{}} indicates the argument and
return types of \texttt{(==)}. But the type variable \texttt{a} cannot
just be any type (as was the case with fully polymorphic functions like
\texttt{const}): It has to be a type that is an instance of the
\texttt{Eq} class. This is expressed by the \emph{constraint} on the
left of the \texttt{=\textgreater{}}.

\textbf{Exercise 21}

Write an \texttt{Eq} instance for \texttt{Employee}, using record
accessors. Is there a problem with this code?

\hypertarget{implicit-dependency-injection}{%
\subsection{Implicit dependency
injection}\label{implicit-dependency-injection}}

Sometimes type classes are used for implicit dependency injection. Which
is just a fancy way of saying ``I don't want to pass an extra argument
and instead want the compiler do that implicitly for me, based on the
types''.

Recall our definition of \texttt{fixEq}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{fixEq ::} \DataTypeTok{Eq}\NormalTok{ a }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ a) }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\NormalTok{fixEq f x }\OtherTok{=} \KeywordTok{if}\NormalTok{ x }\OperatorTok{==}\NormalTok{ f x }\KeywordTok{then}\NormalTok{ x }\KeywordTok{else}\NormalTok{ fixEq f (f x)}
\end{Highlighting}
\end{Shaded}

which ``iterates \texttt{f} on \texttt{x} until the value is equal to
the one before.''. Compare this to the following version:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{fixBy ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}\NormalTok{) }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ a) }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\NormalTok{fixBy p f x }\OtherTok{=} \KeywordTok{if}\NormalTok{ x }\OtherTok{\textasciigrave{}p\textasciigrave{}}\NormalTok{ f x }\KeywordTok{then}\NormalTok{ x }\KeywordTok{else}\NormalTok{ fixBy p f (f x)}
\end{Highlighting}
\end{Shaded}

This function iterates until a user-specified function tells it to stop.
This might be useful for some iterative approximation algorithm, where
we stop once the difference between subsequent approximations is smaller
than some epsilon.

Note that this is a form of dependency injection: The caller of
\texttt{fixBy} passes along the dependency ``stopping function''. In
general, this can be of course much more complex, e.g.~a storage
backend.

The function \texttt{fixBy} is clearly more general than \texttt{fixEq},
as we can implement \texttt{fixEq} using \texttt{fixBy}, by specifying
\texttt{p} to be equality:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{fixEq ::} \DataTypeTok{Eq}\NormalTok{ a }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ a) }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\NormalTok{fixEq }\OtherTok{=}\NormalTok{ fixBy (}\OperatorTok{==}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

So whenever a parameter to a polymorphic function is, for the given
concrete type, the same, one can use type classes and overloading to
make this parameter selection implicit.

Note that just because one \emph{can} do that, one does not have to.
Often explicit arguments are easier to understand and maintain and more
flexible (e.g.~if you might want different arguments that have the same
types). I consider this application of type classes less relevant than
the other application presented here.

\hypertarget{polymorphism-over-types-with-structure}{%
\subsection{Polymorphism over types with
structure}\label{polymorphism-over-types-with-structure}}

Similar to the \texttt{Eq} type class, there is an \texttt{Ord} type
class that overloads the comparisons operators \texttt{(\textless{})}
\texttt{(\textless{}=)}, \texttt{(\textgreater{})} and
\texttt{(\textgreater{}=)}.

Using them, we can define a predicate on polymorphic trees that checks
whether the tree is sorted, i.e.~every value is less than or equal to
every value further right. One way of implementing this is:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{isSorted ::} \DataTypeTok{Ord}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Tree}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{isSorted }\OtherTok{=}\NormalTok{ everyNode }\OperatorTok{$}\NormalTok{ \textbackslash{}y t1 t2 }\OtherTok{{-}\textgreater{}}
\NormalTok{    everyValue (\textbackslash{}x }\OtherTok{{-}\textgreater{}}\NormalTok{ x }\OperatorTok{\textless{}=}\NormalTok{ y) t1 }\OperatorTok{\&\&}
\NormalTok{    everyValue (\textbackslash{}z }\OtherTok{{-}\textgreater{}}\NormalTok{ y }\OperatorTok{\textless{}=}\NormalTok{ z) t2}

\OtherTok{everyValue ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Tree}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{everyValue p }\OtherTok{=}\NormalTok{ everyNode (\textbackslash{}x \_ \_ }\OtherTok{{-}\textgreater{}}\NormalTok{ p x)}

\OtherTok{everyNode ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Tree}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Tree}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}\NormalTok{) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Tree}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Bool}
\NormalTok{everyNode p (}\DataTypeTok{Node}\NormalTok{ x t1 t2) }\OtherTok{=}\NormalTok{ p x t1 t2 }\OperatorTok{\&\&}\NormalTok{ everyNode p t1 }\OperatorTok{\&\&}\NormalTok{ everyNode p t2}
\NormalTok{everyNode \_ }\DataTypeTok{Leaf} \OtherTok{=} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

(Can you make sense of this code? It is a good exercise to make sure you
can read this code. If you think this code to be inefficient, then you
are right: It is algorithmically bad, but serves nicely as a high-level
specification.)

Does this correctly implement the specification? Yes and no! If we have
a tree of \texttt{Integer}, then \texttt{isSorted} will indeed return
\texttt{True} if every element is smaller or equal to every element
further on the right. But here is a counter example, involving a
three-valued type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{ABC} \OtherTok{=} \DataTypeTok{A} \OperatorTok{|} \DataTypeTok{B} \OperatorTok{|} \DataTypeTok{C} \KeywordTok{deriving} \DataTypeTok{Eq}
\KeywordTok{instance} \DataTypeTok{Ord} \DataTypeTok{ABC} \KeywordTok{where}
\NormalTok{  x }\OperatorTok{\textless{}=}\NormalTok{ y }\OperatorTok{|}\NormalTok{ x }\OperatorTok{==}\NormalTok{ y }\OtherTok{=} \DataTypeTok{True}
  \DataTypeTok{A} \OperatorTok{\textless{}=} \DataTypeTok{B} \OtherTok{=} \DataTypeTok{True}
  \DataTypeTok{B} \OperatorTok{\textless{}=} \DataTypeTok{C} \OtherTok{=} \DataTypeTok{True}
\NormalTok{  \_ }\OperatorTok{\textless{}=}\NormalTok{ \_ }\OtherTok{=} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

(You can ignore the \texttt{deriving\ Eq} for a moment). Now we can have
a tree that is claimed to be sorted, but it is not!

\begin{verbatim}
*Main> isSorted (Node B (Node A Leaf Leaf) (Node C Leaf Leaf))
True
*Main> A <= C
False
\end{verbatim}

What is the problem here? The problem is not (really) with the code
\texttt{isSorted}, but rather with the \texttt{Ord} instance for
\texttt{ABC}: It does not behave as we would expect it to, in
particular, it is not transitive:

\begin{verbatim}
*Main> (A <= B && B <= C, A <= C)
(True,False)
\end{verbatim}

If we look at the
\href{http://hackage.haskell.org/package/base/docs/Prelude.html\#t:Ord}{documentation
of the \texttt{Ord}} type class, we see that any instance of
\texttt{Ord} is expected to be, among other things, transitive. Indeed,
most type classes come with additional requirements, or \emph{laws},
that should hold for its instances.

In this sense, the constraint in the type signature of \texttt{isSorted}
should not be read as ``for any type \texttt{a} that implements the
signature of the \texttt{Ord} type class\ldots{}'', but rather as ``for
any type \texttt{a} that is ordered\ldots{}''. Not the \emph{interface}
matters, but rather the \emph{semantic meaning} behind it.

Conversely, if you come across a type class without any semantic
meaning, i.e.~one that just overloads a name, then that is clearly
fishy. Nothing good will come out of a type class like, say

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{IntAble}\NormalTok{ a }\KeywordTok{where}\OtherTok{ toInteger ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Integer}
\end{Highlighting}
\end{Shaded}

if it does not also come with an abstract meaning that should be shared
by all instances.

By the way, did you notice the \texttt{Eq} constraint in the head of the
declaration of the \texttt{Ord} type class:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Eq}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Ord}\NormalTok{ a }\KeywordTok{where}
\end{Highlighting}
\end{Shaded}

This means that only types that are an instance of \texttt{Eq} may have
an instance of \texttt{Ord}. The upshot is that a function with a
\texttt{Ord\ a} constraint may also use \texttt{(==)}, without
explicitly listing the \texttt{Eq} constraint.

\textbf{Exercise 22}

Look up the \texttt{Semigroup} type class, and find its laws.

\textbf{Exercise 23}

Can you think of a \texttt{Semigroup\ (Tree\ a)} instance? Or maybe even
more than one? How can you be sure it is a lawful instance?

\textbf{Exercise 24}

The
\href{http://hackage.haskell.org/package/base/docs/Prelude.html\#t:Monoid}{\texttt{Monoid}
class} extends the \texttt{Semigroup} class with an operation
\texttt{mempty\ ::\ Monoid\ a\ =\textgreater{}\ a} that is supposed to
be a neutral element of \texttt{(\textless{}\textgreater{})}.

Given a function signature
\texttt{summarize\ ::\ Monoid\ a\ =\textgreater{}\ Tree\ a\ -\textgreater{}\ a},
can you guess what it does? What would be the implementation you expect?

With that implementation, can you use \texttt{summarize} to distinguish
trees that differ in shape, but have the same elements in the same
order? What does this imply for search trees?

\hypertarget{type-driven-code-synthesis}{%
\subsection{Type-driven code
synthesis}\label{type-driven-code-synthesis}}

Let us turn to the most sophisticated use of type classes (within this
lecture): Type-driven code synthesis! Again, this is a fancy word for
something rather simple, but it is very powerful, and a driving idiom
for many problems in the Haskell space.

In the previous chapter we have seen a number of common types that can
be combined to build larger types -- \texttt{Maybe}, tuples,
\texttt{Either}, list, etc. If there is functionality that we want to
provide at many different types, then we can use type classes to
describe how to get that functionality for each of these building
blocks, assuming we have it for their argument types, and then the user
automatically gets the functionality for any complex type they build.

Typical examples for such functionality are parsers, pretty-printers,
serialization libraries, substitutions of sorts, random values, test
case generation\ldots{}

Let us define a type class that describes \emph{finite} types,
i.e.~types with a finite number of values, and a function that returns
the number of values in the type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Finite}\NormalTok{ a }\KeywordTok{where}
\OtherTok{    size ::} \DataTypeTok{Integer}
\end{Highlighting}
\end{Shaded}

Is this a good type class, i.e.~does it have \emph{meaning}? Yes, it
does: When a type has an instance of \texttt{Finite}, it means that the
type is finite, and that \texttt{size} designates the number of
elements. Unfortunately Haskell does not prevent you from writing an
instance that does not adhere to that, but that would then simply be
wrong.

This definition is a bit weird: The type signature of \texttt{size} does
not mention the type \texttt{a} anywhere. On the one hand, this makes
sense: We do not need a concrete element in our hand to ask the question
``how many elements are there in \texttt{a}''. On the other hand, when
we use \texttt{size} somewhere, how will the compiler know for which
type we want to invoke it?

Therefore, this would be prohibited in plain Haskell. But as mentioned
before, contemporary Haskell often uses language extensions supported by
the compiler, and that is what we will do here, namely

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{\{{-}\# LANGUAGE AllowAmbiguousTypes \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE TypeApplications \#{-}\}}
\OtherTok{\{{-}\# LANGUAGE ScopedTypeVariables \#{-}\}}
\end{Highlighting}
\end{Shaded}

(in \texttt{ghci} you can type
\texttt{:set\ -XAllowAmbiguousTypes} \texttt{-XTypeApplications} \break \texttt{-XScopedTypeVariables}).
With these extensions, the class declaration is accepted, and we can use
the syntax \texttt{size\ @Bool} to say which instance to use.

We start with instances for some basic types:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Finite} \DataTypeTok{Bool} \KeywordTok{where}\NormalTok{ size }\OtherTok{=} \DecValTok{2}
\KeywordTok{instance} \DataTypeTok{Finite}\NormalTok{ () }\KeywordTok{where}\NormalTok{ size }\OtherTok{=} \DecValTok{1}
\KeywordTok{data} \DataTypeTok{Suit} \OtherTok{=} \DataTypeTok{Diamonds} \OperatorTok{|} \DataTypeTok{Clubs} \OperatorTok{|} \DataTypeTok{Hearts} \OperatorTok{|} \DataTypeTok{Spades}
\KeywordTok{instance} \DataTypeTok{Finite} \DataTypeTok{Suit} \KeywordTok{where}\NormalTok{ size }\OtherTok{=} \DecValTok{4}
\end{Highlighting}
\end{Shaded}

More interesting are the instances for the types that build on other
types. These are not always \texttt{Finite}, but only if the types
therein are themselves \texttt{Finite}, so we constrain the instance
itself:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Finite}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Finite}\NormalTok{ (}\DataTypeTok{Maybe}\NormalTok{ a) }\KeywordTok{where}
\NormalTok{    size }\OtherTok{=}\NormalTok{ size }\OperatorTok{@}\NormalTok{a }\OperatorTok{+} \DecValTok{1}
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{Finite}\NormalTok{ a, }\DataTypeTok{Finite}\NormalTok{ b) }\OtherTok{=\textgreater{}} \DataTypeTok{Finite}\NormalTok{ (a,b) }\KeywordTok{where}
\NormalTok{    size }\OtherTok{=}\NormalTok{ size }\OperatorTok{@}\NormalTok{a }\OperatorTok{*}\NormalTok{ size }\OperatorTok{@}\NormalTok{b}
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{Finite}\NormalTok{ a, }\DataTypeTok{Finite}\NormalTok{ b) }\OtherTok{=\textgreater{}} \DataTypeTok{Finite}\NormalTok{ (}\DataTypeTok{Either}\NormalTok{ a b) }\KeywordTok{where}
\NormalTok{    size }\OtherTok{=}\NormalTok{ size }\OperatorTok{@}\NormalTok{a }\OperatorTok{+}\NormalTok{ size }\OperatorTok{@}\NormalTok{b}
\end{Highlighting}
\end{Shaded}

Even the function type is finite, if both domain and codomain are
finite:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{Finite}\NormalTok{ a, }\DataTypeTok{Finite}\NormalTok{ b) }\OtherTok{=\textgreater{}} \DataTypeTok{Finite}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\KeywordTok{where}
\NormalTok{    size }\OtherTok{=}\NormalTok{ size }\OperatorTok{@}\NormalTok{b }\OperatorTok{\^{}}\NormalTok{ size }\OperatorTok{@}\NormalTok{a}
\end{Highlighting}
\end{Shaded}

Note that for obvious reasons we do not have an instance for
\texttt{Integer}, or the list type.

Now that we have sown the seed, we want to reap the fruit: Whatever
complex type we build out of these constructors, we can evaluate
\texttt{size} that that type:

\begin{verbatim}
Prelude> size @(Maybe Bool)
3
Prelude> size @(Maybe (Maybe Bool))
4
Prelude> size @(Suit -> Bool)
16
Prelude> size @(Suit -> Bool, Bool -> Suit)
256
Prelude> size @((Suit -> Suit) -> Maybe Bool)
1390084523771447327649397867896613031142188508
0852913799160482443003607262976643594100176915
4109609521811665540548899435521
\end{verbatim}

The utility of such a \texttt{size} function is questionable (but not
completely void), but I hope you understand the power behind this
approach, and also recognize the pattern if you see it in the wild.

In fact, instances of the \texttt{Eq} and \texttt{Ord} class for the
container types like tuples and lists etc. also follow this pattern.

\hypertarget{common-pre-defined-type-classes}{%
\subsection{Common pre-defined type classes
☆}\label{common-pre-defined-type-classes}}

You should know the following common type classes. Follow the links for
the list of methods and other documentation:

\begin{itemize}
\item
  \href{http://hackage.haskell.org/package/base/docs/Prelude.html\#t:Eq}{\texttt{Eq}}:
  Equality (or equivalence)
\item
  \href{http://hackage.haskell.org/package/base/docs/Prelude.html\#t:Ord}{\texttt{Ord}}:
  Ordering
\item
  \href{http://hackage.haskell.org/package/base/docs/Prelude.html\#t:Num}{\texttt{Num}}:
  Numeric operations (\texttt{(+)}, \texttt{(-)}, \texttt{(*)} and
  others). There are more numerical type classes (\texttt{Real},
  \texttt{Integral}, \texttt{Fractional}, \texttt{RealFloat}).
\item
  \href{http://hackage.haskell.org/package/base/docs/Prelude.html\#t:Show}{\texttt{Show}}:
  Provides
  \texttt{show\ ::\ Show\ a\ =\textgreater{}\ a\ -\textgreater{}\ String}
  to serialize a value to a textual representation that is (supposed to
  be) valid source code. Should be used for debugging mostly, or to
  convert numbers to strings.
\item
  \href{http://hackage.haskell.org/package/base/docs/Prelude.html\#t:Read}{\texttt{Read}}:
  Provides
  \texttt{read\ ::\ Read\ a\ =\textgreater{}\ String\ -\textgreater{}\ a},
  which goes the other way. Again, not ideal for production use, but can
  sometimes be used with \texttt{Show} to scaffold serialization. If you
  have to use it, consider using
  \href{http://hackage.haskell.org/package/base/docs/Text-Read.html\#v:readMaybe}{\texttt{readMaybe}}.
\item
  \href{http://hackage.haskell.org/package/base/docs/Prelude.html\#t:Functor}{\texttt{Functor}}:
  Provides
  \texttt{fmap\ ::\ Functor\ f\ =\textgreater{}\ (a\ -\textgreater{}\ b)\ -\textgreater{}\ f\ a\ -\textgreater{}\ f\ b}.
  This type class can only be instantiated for type constructors
  (\texttt{Maybe}, the list type, etc.). It provides the ability to
  apply a function to each value within the container (for types that
  are a container, of sorts).
\item
  \href{http://hackage.haskell.org/package/base/docs/Prelude.html\#t:Applicative}{\texttt{Applicative}}
  and
  \href{http://hackage.haskell.org/package/base/docs/Prelude.html\#t:Monad}{\texttt{Monad}}
  are used to model effects of sorts, for example to hide bookkeeping
  (in a parser) or safely allow side-effects (in IO code). We will
  discuss them in great detail in the next chapter.
\item
  \href{http://hackage.haskell.org/package/base/docs/Prelude.html\#t:Foldable}{\texttt{Foldable}}
  and
  \href{http://hackage.haskell.org/package/base/docs/Prelude.html\#t:Traversable}{\texttt{Traversable}}
  are abstractions over containers where elements can be visited in
  sequence, i.e.~a generalization of lists.
\end{itemize}

\hypertarget{monads}{%
\section{Monads}\label{monads}}

Haskell is famous for \emph{monads}. If you are scared by complicated
sounding words, you might even consider them to be infamous. Judging by
the number of ``monad tutorials'' and other noise about this topic,
these monads must indeed be crazy arcane black magic.

So what's the deal? What is a monad?

Really, the concept of a monad is surprisingly small. It is a pattern of
abstraction, expressed as a type class with merely two essential methods
and a small number of laws. That's it, the rest is just applications.
But this small idea turns to be amazingly powerful and expressive.

I can't help but notice that monads are like burritos: What is a
burrito? It is a bunch of protein and seasoning, neatly wrapped in a
flour tortilla. That's it. But with just that knowledge, it is
impossible to fully appreciate or recreate the wealth and richness of
Mexican cuisine. The idea is simple, but the applications are rich and
manifold and, and therefore require skill and experience to master.

(Oh, and of course, sometimes a taco would do better than a burrito.
Monads are not always the right tool.)

This is a cute analogy, but it does not help the aspiring Haskell
reader. So how do we proceed from here? This material offers two
choices:

\begin{itemize}
\item
  A quick path to understanding ``imperative Haskell code'',
  i.e.~Haskell code that uses the \texttt{IO} monad and \texttt{do}
  notation, and looks similar to, say, Python code. This path avoids
  almost all technical details about monads, and simply gives you a way
  to decipher the syntax. This is in the \protect\hyperlink{io}{chapter
  on imperative Haskell}.
\item
  A slow path where we actually look at the \texttt{Monad} type class,
  the idea behind it, and some of the more advanced (but still common)
  applications of it. This is this chapter.
\end{itemize}

\hypertarget{kinds}{%
\subsection{Kinds}\label{kinds}}

Before we talk about monads, we have to discuss the concept of
\emph{kinds}.

You might have already noticed that there is a fundamental difference
between a type like \texttt{Bool} and a type like \texttt{Maybe}. The
former has values, e.g.~\texttt{True}, and it can be an argument or a
return value of a function. That is not true for \texttt{Maybe}. There
is no value that has type \texttt{Maybe}! Only when we say what type we
maybe have, it gives us a proper type. So \texttt{Maybe} is not a normal
type in that sense, but \texttt{Maybe\ Bool} is, or in general
\texttt{Maybe\ a} for any normal type \texttt{a}.

So what is \texttt{Maybe}? It is a \emph{type constructor}! It takes a
normal type (with values, like \texttt{Bool}) and constructs a new
normal type from it (namely \texttt{Maybe\ Bool}).

We can apply \texttt{Maybe} multiple times:
\texttt{Maybe\ (Maybe\ Bool)} is also a normal type. But we cannot apply
\texttt{Maybe} to itself: \texttt{Maybe\ Maybe} is nonsense.

This is all very similar to the term level, where \texttt{True} is a
Boolean, but \texttt{not} is not a Boolean. But \texttt{not} can be
applied to a Boolean, and \texttt{not\ True} is another Boolean. We can
apply it multiple times \texttt{not\ (not\ True)}, but we cannot apply
it to itself, \texttt{not\ not} is nonsense.

On the term level, terms have \emph{types} that describe what
compositions make sense and which compositions are disallowed.
\texttt{True} has type \texttt{Bool}, and \texttt{not} has type
\texttt{Bool\ -\textgreater{}\ Bool}, which explains why you can apply
\texttt{not} to \texttt{True}, but not to \texttt{not}.

We find the same on the type level: Types have \emph{kinds} that
describe which compositions make sense and which compositions are
disallowed. \texttt{Bool} has kind \texttt{*} (pronounced ``star'' or
simply ``type''), and \texttt{Maybe} has kind
\texttt{*\ -\textgreater{}\ *}, which explains why you can apply
\texttt{Maybe} to \texttt{Bool}, but not to \texttt{Maybe}.

The kind \texttt{*} is the kind of all the normal types, which have
values, and which can be the argument or return type of a function.
\texttt{*\ -\textgreater{}\ *} is the kind of simple \emph{type
constructors} like \texttt{Maybe}, or \texttt{Tree}, or the list type.
Some have more than one argument, e.g.~\texttt{Either} has kind
\texttt{*\ -\textgreater{}\ *\ -\textgreater{}\ *}. GHCi happily tells
you the kind of a type constructor using the \texttt{:kind} command:

\begin{verbatim}
Prelude> :kind Bool
Bool :: *
Prelude> :kind Maybe
Maybe :: * -> *
Prelude> :kind Either
Either :: * -> * -> *
\end{verbatim}

In mundane code, kinds do not get more complicated than that, but there
are good uses for higher kinds, such as

\begin{verbatim}
Prelude> newtype Fix f = Fix (f (Fix f))
Prelude> :kind Fix
Fix :: (* -> *) -> *
\end{verbatim}

\hypertarget{the-kind-of-type-classes}{%
\subsection{The kind of type classes}\label{the-kind-of-type-classes}}

Type classes are also kinded. You can have a constraint
\texttt{Eq\ Bool}, or \texttt{Eq\ (Maybe\ Bool)}, but not
\texttt{Eq\ Maybe} -- that does not make sense. So \texttt{Eq} takes a
parameter of kind \texttt{*}, and produces a constraint:

\begin{verbatim}
Prelude> :kind Eq
Eq :: * -> Constraint
Prelude> :kind Monoid
Monoid :: * -> Constraint
\end{verbatim}

Most type classes that we saw in the previous section have that kind
(\texttt{Eq}, \texttt{Ord}, \texttt{Num}, \texttt{Show}, \texttt{Read},
\texttt{Monoid}). But there are also type classes that characterize type
constructors, in particular the infamous \texttt{Monad}:

\begin{verbatim}
Prelude> :kind Functor
Functor :: (* -> *) -> Constraint
Prelude> :kind Monad
Monad :: (* -> *) -> Constraint
\end{verbatim}

\hypertarget{a-close-look-at--}{%
\subsection{\texorpdfstring{A close look at
\texttt{*\ -\textgreater{}\ *}}{A close look at * -\textgreater{} *}}\label{a-close-look-at--}}

So according to the kind of \texttt{Monad}, only type constructors of
kind \texttt{*\ -\textgreater{}\ *} can be instances of \texttt{Monad} .
And I believe that one way towards grasping monads is to get a good
handle on the concept of a type constructor, both concretely, and the
abstract concept. Once we have seen enough concrete examples of them,
worked out the common patterns, we can appreciate that \emph{monad is an
abstraction over type constructors}.

Let us start abstractly, and consider a type constructor \texttt{m} with
kind \texttt{*\ -\textgreater{}\ *}. So for every type \texttt{a} (of
kind \texttt{*}), there is a type \texttt{m\ a}. The meaning of
\texttt{m\ a} is (usually) very different from, but still somehow
related, to the meaning of \texttt{a}. It could be ``extra data'', it
could be additional behavior, some kind of bookkeeping, or effects of
sorts.

To make this more concrete, let us look at some examples of type
constructors with kind \texttt{(*\ -\textgreater{}\ *)}, and how they
change the meaning of a type.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Maybe}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Nothing} \OperatorTok{|} \DataTypeTok{Just}\NormalTok{ a}
\KeywordTok{data} \DataTypeTok{Either}\NormalTok{ e a }\OtherTok{=} \DataTypeTok{Left}\NormalTok{ e }\OperatorTok{|} \DataTypeTok{Right}\NormalTok{ a}
\KeywordTok{data}\NormalTok{ [a] }\OtherTok{=}\NormalTok{ [] }\OperatorTok{|}\NormalTok{ a }\OperatorTok{:}\NormalTok{ [a]}
\KeywordTok{newtype} \DataTypeTok{Identity}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Identity}\NormalTok{ a}
\KeywordTok{data} \DataTypeTok{Proxy}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Proxy}
\KeywordTok{newtype} \DataTypeTok{Reader}\NormalTok{ r a }\OtherTok{=} \DataTypeTok{Reader}\NormalTok{ (r }\OtherTok{{-}\textgreater{}}\NormalTok{ a))}
\KeywordTok{newtype} \DataTypeTok{State}\NormalTok{ s a }\OtherTok{=} \DataTypeTok{State}\NormalTok{ (s }\OtherTok{{-}\textgreater{}}\NormalTok{ (a, s))}
\KeywordTok{newtype} \DataTypeTok{Parser}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Parser}\NormalTok{ (}\DataTypeTok{String} \OtherTok{{-}\textgreater{}}\NormalTok{ [(a,}\DataTypeTok{String}\NormalTok{)])}
\KeywordTok{data} \DataTypeTok{IO}\NormalTok{ a }\OtherTok{=}\NormalTok{  ¯\textbackslash{}\_(ツ)\_}\OperatorTok{/}\NormalTok{¯}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  The first example is the \texttt{Maybe} type that we have looked at
  before. A value of type \texttt{Maybe\ a} is either \texttt{Just} a
  value of type \texttt{a}, or it is \texttt{Nothing}. So \texttt{Maybe}
  takes a type \texttt{a} and adjoins an extra element to it.

  You can think of \texttt{Maybe\ a} as a container with zero or one
  element. But you can also think of it as a \emph{computation} that can
  fail, or return an \texttt{a}. This is commonly used for lookups in
  maps, or text parsing that can fail.

  \texttt{Maybe} has kind \texttt{*\ -\textgreater{}\ *}, so it ``fits''
  the \texttt{Monad} type class, and an \texttt{instance\ Monad\ Maybe}
  would make sense.
\item
  The next example, \texttt{Either}, is a close relative of
  \texttt{Maybe}. It also commonly models ``\texttt{a} with failure'',
  but the failure can carry additional data of type \texttt{e}.

  Because it takes two type arguments, the kind of \texttt{Either} is
  \texttt{*\ -\textgreater{}\ *\ -\textgreater{}\ *}, and there cannot
  be an \texttt{instance\ Monad\ Either}. But we can make it fit by
  providing \emph{one} type argument. For each type \texttt{e},
  \texttt{Either\ e} has kind \texttt{*\ -\textgreater{}\ *}, and it
  would make sense to have an \texttt{instance\ Monad\ (Either\ e)}.
\item
  The list type has kind \texttt{*\ -\textgreater{}\ *}. The meaning of
  \texttt{{[}a{]}} is ``zero, one or more values of type \texttt{a}''
  and shows that it is \emph{not} the case that a value of type
  \texttt{m\ a} always contains a value of type \texttt{a}.

  This example becomes immediately more interesting if we
  \emph{interpret} a list differently. Instead of considering it to be a
  container of many values, we can also think of it as a
  non-deterministic computation, i.e.~a computation with multiple
  possible results of type \texttt{a}.
\item
  A bit vacuous, but we can create a type constructor that does not
  actually change the meaning of the type; that would be the
  \texttt{Identity} type constructor.
\item
  Since we are looking at corner cases, let us introduce the
  \texttt{Proxy} type constructor. It is an example where \texttt{m\ a}
  really never contains a value of type \texttt{a}. In fact, a value of
  type \texttt{m\ a} is always just \texttt{Proxy}. The type \texttt{a}
  is merely a phantom that spooks on the type level.
\item
  Back to more useful examples: The meaning of \texttt{Reader\ r\ a} is
  ``a value of type \texttt{a} -- if you give me an \texttt{r}''. Again,
  no value of type \texttt{a} is contained in \texttt{Reader\ r\ a}; if
  anything, there is a promise for one. Or, actually, for many: it has
  one for each possible value of type \texttt{r}.

  Incidentally, the \texttt{Reader} type is just an alternative name for
  the function arrow \texttt{(-\textgreater{})}, and if we partially
  apply the function arrow to a type,
  i.e.~\texttt{(-\textgreater{})\ r}, we get something of kind
  \texttt{*\ -\textgreater{}\ *} just as well.
\item
  A similar idea is behind the \texttt{State} type constructor. Here, a
  value of type \texttt{State\ s\ a} is ``a value of type \texttt{a}, if
  you give me an \texttt{s}, and by the way, I will also give you a new
  value of type \texttt{s}'', or, maybe more helpfully, ``a computation
  that accesses state of type \texttt{s} and produces a value of type
  \texttt{a}''.
\item
  The \texttt{Parser} type constructor implements a backtracking parser.
  Let's not look at the definition too much, and just appreciate that
  going from \texttt{a} to ``something that can parse a value of type
  \texttt{a}'' can be modeled as a type constructor.
\item
  And finally there is the \texttt{IO\ a} type constructor, for which
  the definition is opaque. But it still has a clear meaning: A value of
  type \texttt{IO\ a} is a computation that, after interacting with the
  external world (terminal, files, network, randomness, etc.), produces
  a value of type \texttt{a}. (See the \protect\hyperlink{io}{chapter on
  imperative code} if you want a diversion.)
\end{itemize}

This was a long list, and I could have easily extended it with many
more. So what is the point? The point is that there are a large number
of very different concepts that can be naturally expressed as a type
constructor. If we now venture out to find similarities between them, we
will stumble upon monads.

\hypertarget{the-monad-type-class}{%
\subsection{\texorpdfstring{The \texttt{Monad} type
class}{The Monad type class}}\label{the-monad-type-class}}

If we look at the list above, we might notice that all of them have
something in common: When working with these objects, we often want to
\emph{compose} in the following way.

\begin{itemize}
\tightlist
\item
  If I have a computation that returns an \texttt{a} or fails, and one
  that takes an \texttt{a} and may fail or return a \texttt{b}, I want
  to plug them together to get a \texttt{b} (or failure).
\item
  If I have a computation that accesses state and produces a value of
  type \texttt{a}, and one that -- given a value of type \texttt{a} --
  accesses state and produces a value of type \texttt{b}, I want to
  compose them to get a computation that accesses state and returns a
  \texttt{b}.
\item
  If I have a parser that parses a number, and a parser that parses a
  string of a given length, I want to compose them to parse a
  string-with-length data format.
\item
  If I have a computation that reads from a file and returns the content
  as a string, and one that takes a string and writes it to another
  file, I want to compose them to one that copies a file.
\item
  etc.
\end{itemize}

We could implement this composition separately for each of these, and
obtain a long list of functions

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{andThen ::} \DataTypeTok{Maybe}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ b) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ b}
\OtherTok{andThenEither ::} \DataTypeTok{Either}\NormalTok{ e a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Either}\NormalTok{ e b) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Either}\NormalTok{ e b}
\OtherTok{flipConcatMap ::}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ [b]) }\OtherTok{{-}\textgreater{}}\NormalTok{ [b]}
\OtherTok{bindIdentity ::} \DataTypeTok{Identity}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Identity}\NormalTok{ b) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Identity}\NormalTok{ b}
\OtherTok{bindProxy ::} \DataTypeTok{Proxy}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Proxy}\NormalTok{ b) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Proxy}\NormalTok{ b}
\OtherTok{bindReader ::} \DataTypeTok{Reader}\NormalTok{ r a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Reader}\NormalTok{ r b) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Reader}\NormalTok{ r b}
\OtherTok{bindState ::} \DataTypeTok{State}\NormalTok{ s a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{State}\NormalTok{ s b) }\OtherTok{{-}\textgreater{}} \DataTypeTok{State}\NormalTok{ s b}
\OtherTok{bindParser ::} \DataTypeTok{Parser}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Parser}\NormalTok{ b) }\OtherTok{{-}\textgreater{}} \DataTypeTok{Parser}\NormalTok{ b}
\OtherTok{bindIO ::} \DataTypeTok{IO}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ b) }\OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

This would suffice for many applications, but it is not nice -- I even
ran out of names to use.

Haskell is all about abstraction, and clearly, there \emph{is} a common
pattern here. If distill the abstract type here, using \texttt{m} to
stand for the type constructor, we get
\texttt{m\ a\ -\textgreater{}\ (a\ -\textgreater{}\ m\ b)\ -\textgreater{}\ m\ b}.
Remember that for a moment.

For all these type constructors, there is something else that we want to
do. When we have a value \texttt{x} of type \texttt{a}, we want to be
able to treat it as

\begin{itemize}
\tightlist
\item
  a computation that could fail (but doesn't), or
\item
  a computation that could access state of type \texttt{s} (but doesn't
  actually look at it) before returning \texttt{x},
\item
  a parser that does not touch the input, but simply always produces
  \texttt{x},
\item
  etc.
\end{itemize}

Again, we could have separate functions for each of these injections,
but that would be tedious. So if we try to phrase this as an abstract
type, in terms of \texttt{m}, we get \texttt{a\ -\textgreater{}\ m\ a}.

This brings us to the concept of a monad: A type constructor that allows
composition and injection in this way is a monad.

\hypertarget{the-definition}{%
\subsubsection{The definition}\label{the-definition}}

Finally, it is time to look at the actual
\href{http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html\#t:Monad}{definition
of the \texttt{Monad} type class} (with optional and obsolete methods
omitted):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Applicative}\NormalTok{ m }\OtherTok{=\textgreater{}} \DataTypeTok{Monad}\NormalTok{ m }\KeywordTok{where}
\OtherTok{    return ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\OtherTok{    (\textgreater{}\textgreater{}=)  ::}\NormalTok{ m a }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m b) }\OtherTok{{-}\textgreater{}}\NormalTok{ m b}

\CommentTok{{-}{-} Laws:}
\CommentTok{{-}{-} return a \textgreater{}\textgreater{}= k = k a}
\CommentTok{{-}{-} m \textgreater{}\textgreater{}= return = m}
\CommentTok{{-}{-} m \textgreater{}\textgreater{}= (\textbackslash{}x {-}\textgreater{} k x \textgreater{}\textgreater{}= h) = (m \textgreater{}\textgreater{}= k) \textgreater{}\textgreater{}= h}
\end{Highlighting}
\end{Shaded}

The most important bit of information is actually only implicit: The
fact that the argument \texttt{m} has kind
\texttt{*\ -\textgreater{}\ *}. We can infer that from the fact that
\texttt{m} is applied to \texttt{a} in the type signature of the
methods.

\hypertarget{the-operations}{%
\subsubsection{The operations}\label{the-operations}}

What we do find very explicitly, however, are the two type signatures
that we have just distilled:

\begin{itemize}
\tightlist
\item
  The operator with the funny arrow does the kind of composition that we
  wanted. It is also called \emph{bind} or the \emph{monad composition
  operator}.
\item
  The function \texttt{return} (also available as \texttt{pure}) injects
  a value into the monad.
\end{itemize}

In this context, when \texttt{m} is a monad, we call a value of type
\texttt{m\ a} ``a monadic action returning a value of type \texttt{a}'',
or sometimes also ``monadic computation with return type \texttt{a}''.

For additional intuition, squint at these type signatures, and imagine
the \texttt{m} were not there:

\begin{itemize}
\item
  Then the bind operator would simply have type
  \texttt{a\ -\textgreater{}\ (a\ -\textgreater{}\ b)\ -\textgreater{}\ b},
  and due to parametricity it is clear what such an operator does: It is
  function application! (i.e.~\texttt{(\$)} with parameters flipped,
  also available as
  \href{http://hackage.haskell.org/package/base/docs/Data-Function.html\#v:-38-}{\texttt{(\&)}}
  in \texttt{Data.Function}.) The bind operator does morally the same,
  while at the same time taking care of the particular meaning that is
  introduced by the type constructor \texttt{m}.
\item
  Similarly, \texttt{return} has squinted type
  \texttt{a\ -\textgreater{}\ a} and thus simply becomes the identity
  function. So \texttt{return} doesn't do anything interesting to its
  argument, it just makes it look like it \emph{could} have additional
  meaning.
\end{itemize}

\hypertarget{the-laws}{%
\subsubsection{The laws}\label{the-laws}}

As discussed before, a type class is more than just a set of function
signatures: The laws that come with it are equally important.

\begin{itemize}
\item
  The first two laws can be summarized as ``\texttt{return} is the
  neutral element of bind''. Notice how \texttt{return} is a function
  that perfectly fits as the second argument to bind? If we do so, the
  bind operator composes the particular meaning of the first argument of
  type \texttt{m\ a} with the particular meaning introduced by
  \texttt{return}. The second law says that this does \emph{not}
  actually affect the meaning, we could have just used the original
  \texttt{m\ a}. In that sense, \texttt{return} turns an \texttt{a} into
  something that has the shape of an \texttt{m\ a}, without giving it
  any interesting meaning beyond the value of type \texttt{a} itself.
\item
  The last law expresses that the bind operator is associative.
  Composing monadic operations -- \texttt{m}, \texttt{k} and \texttt{h}
  in the law -- we get the same result independent of whether we combine
  \texttt{m} with \texttt{k} first or \texttt{k} with \texttt{h} first.

  Note that the \emph{order} of these operations still matters -- in
  general, the bind operator is not commutative.
\end{itemize}

\hypertarget{no-escape}{%
\subsubsection{No escape?}\label{no-escape}}

Let me point out two things that are notably missing from this type
class:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  There is no method that takes a monadic action \texttt{m\ a} and
  returns just the \texttt{a}. Hence the slogan ``You can't escape the
  monad.''.

  The slogan is only half true, and should better be ``You can't escape
  an arbitrary monad'', as you can escape concrete monads (think of
  \texttt{Identity}, or \texttt{Reader\ r}, if you supply the
  \texttt{r}). But in general it is not possible; think of
  \texttt{Proxy} or, most confusingly for novice Haskell writers,
  \texttt{IO}.
\item
  There is no method that creates any \emph{interesting} monad actions.
  We already deduced that the \texttt{return} method cannot actually do
  anything interesting, and the bind operator merely combines what is
  there.
\end{enumerate}

This shows that the monad abstraction is \emph{only} concerned with the
composition of the monadic actions, but to do anything interesting, we
need additional functions for a concrete monad.

\hypertarget{monad-ops}{%
\subsection{More monad operations ☆}\label{monad-ops}}

It suffices to define \texttt{return} and
\texttt{(\textgreater{}\textgreater{}=)} to define a monad, but when
working with monads, there a number of other operations in common use:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{(\textgreater{}\textgreater{})    ::} \DataTypeTok{Monad}\NormalTok{ m       }\OtherTok{=\textgreater{}}\NormalTok{ m a        }\OtherTok{{-}\textgreater{}}\NormalTok{ m b }\OtherTok{{-}\textgreater{}}\NormalTok{ m b}
\FunctionTok{fmap}\OtherTok{    ::} \DataTypeTok{Functor}\NormalTok{ f     }\OtherTok{=\textgreater{}}\NormalTok{   (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\OtherTok{(\textless{}$\textgreater{})   ::} \DataTypeTok{Functor}\NormalTok{ f     }\OtherTok{=\textgreater{}}\NormalTok{   (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\OtherTok{(\textless{}$)    ::} \DataTypeTok{Functor}\NormalTok{ f     }\OtherTok{=\textgreater{}}\NormalTok{   a        }\OtherTok{{-}\textgreater{}}\NormalTok{ f b }\OtherTok{{-}\textgreater{}}\NormalTok{ f a}
\OtherTok{(\textless{}*\textgreater{})   ::} \DataTypeTok{Applicative}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ f (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\OtherTok{(\textless{}*)    ::} \DataTypeTok{Applicative}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ f a        }\OtherTok{{-}\textgreater{}}\NormalTok{ f b }\OtherTok{{-}\textgreater{}}\NormalTok{ f a}
\OtherTok{(*\textgreater{})    ::} \DataTypeTok{Applicative}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ f a        }\OtherTok{{-}\textgreater{}}\NormalTok{ f b }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\OtherTok{liftA2  ::} \DataTypeTok{Applicative}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b }\OtherTok{{-}\textgreater{}}\NormalTok{ c) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b }\OtherTok{{-}\textgreater{}}\NormalTok{ f c}
\OtherTok{(\textgreater{}=\textgreater{})   ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m b) }\OtherTok{{-}\textgreater{}}\NormalTok{ (b }\OtherTok{{-}\textgreater{}}\NormalTok{ m c) }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m c)}
\OtherTok{join    ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ m (m a) }\OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\FunctionTok{mapM}\OtherTok{    ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m b) }\OtherTok{{-}\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ m [b]}
\FunctionTok{mapM\_}\OtherTok{   ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m b) }\OtherTok{{-}\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ m ()}
\OtherTok{forM    ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m b) }\OtherTok{{-}\textgreater{}}\NormalTok{ m [b]}
\OtherTok{forM\_   ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m b) }\OtherTok{{-}\textgreater{}}\NormalTok{ m ()}
\OtherTok{when    ::} \DataTypeTok{Applicative}\NormalTok{ f }\OtherTok{=\textgreater{}} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}}\NormalTok{ f () }\OtherTok{{-}\textgreater{}}\NormalTok{ f ()}
\OtherTok{unless  ::} \DataTypeTok{Applicative}\NormalTok{ f }\OtherTok{=\textgreater{}} \DataTypeTok{Bool} \OtherTok{{-}\textgreater{}}\NormalTok{ f () }\OtherTok{{-}\textgreater{}}\NormalTok{ f ()}
\OtherTok{forever ::} \DataTypeTok{Applicative}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\end{Highlighting}
\end{Shaded}

For now, pretend that instead of \texttt{Applicative} or
\texttt{Functor} it would read \texttt{Monad}, we will discuss the
difference later.

\begin{itemize}
\item
  The first bunch of operators are simply for various combinations of

  \begin{itemize}
  \tightlist
  \item
    is an argument an action or a pure value
  \item
    is one argument a function? If not, which value is used.
  \end{itemize}

  and you tell which it is from the type. Note that
  \texttt{\textless{}\$\textgreater{}} is simply a different name for
  \texttt{fmap}.

  Here are concrete examples:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{getName ::} \DataTypeTok{IO} \DataTypeTok{String}
\NormalTok{getName }\OtherTok{=} \FunctionTok{putStr} \StringTok{"What is your name? "} \OperatorTok{\textgreater{}\textgreater{}} \FunctionTok{getLine}

\CommentTok{{-}{-} parses the format \textasciigrave{}23+42i\textasciigrave{} as a complex number}
\OtherTok{parseComplex ::} \DataTypeTok{Parser} \DataTypeTok{Complex}
\NormalTok{parseComplex }\OtherTok{=} \DataTypeTok{C} \OperatorTok{\textless{}$\textgreater{}}\NormalTok{ parseInteger }\OperatorTok{\textless{}*}\NormalTok{ parseStr }\StringTok{"+"} \OperatorTok{\textless{}*\textgreater{}}\NormalTok{ parseInteger }\OperatorTok{\textless{}*}
\NormalTok{    parseStr }\StringTok{"i"}
\end{Highlighting}
\end{Shaded}

  \textbf{Exercise 25}

  Give definitions of the operators up to \texttt{join} using
  \texttt{(\textgreater{}\textgreater{}=)}, \texttt{return}, and
  operators you already defined. (You will have to change the
  constraints to \texttt{Monad} for this to typecheck.)
\item
  The \texttt{(\textgreater{}=\textgreater{})} operator is very similar
  to \texttt{(\textgreater{}\textgreater{}=)}, only that both arguments
  have the same type. With this operator, the monad laws are much more
  accessible:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{return} \OperatorTok{\textgreater{}=\textgreater{}}\NormalTok{ m }\OtherTok{=}\NormalTok{ m}
\NormalTok{m }\OperatorTok{\textgreater{}=\textgreater{}} \FunctionTok{return} \OtherTok{=}\NormalTok{ m}
\NormalTok{(a }\OperatorTok{\textgreater{}=\textgreater{}}\NormalTok{ b) }\OperatorTok{\textgreater{}=\textgreater{}}\NormalTok{ c }\OtherTok{=}\NormalTok{ a }\OperatorTok{\textgreater{}=\textgreater{}}\NormalTok{ (b }\OperatorTok{\textgreater{}=\textgreater{}}\NormalTok{ c)}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{mapM} and \texttt{forM} apply a monadic action to each element
  of a list, collecting the results. The variants with underscore do not
  collect the results, e.g.~when you are only interested in the monadic
  effect, and are more efficient.

  These functions demonstrate one benefit we get from monads that goes
  beyond some petty operator overloading: It distills the (still simple,
  but non-trivial) concept of ``traversing a list while doing
  \emph{something} on the side''. These functions are defined once, and
  we can use it in all those different contexts, whether that is
  handling failures, manipulating state, consuming parser input and
  backtracking or exploring all possibilities of non-deterministic
  computation.
\item
  \texttt{when} and \texttt{unless} are pretty simple one: If the
  Boolean argument is true (respectively false), the action is executed,
  otherwise not.

  \textbf{Exercise 26}

  Why is the type not
  \texttt{when\ ::\ Bool\ -\textgreater{}\ m\ a\ -\textgreater{}\ m\ a}?
\item
  \texttt{forever} just keeps executing the same action over and over.
  This does not make sense for every monad, but it is useful for some --
  including \texttt{IO}, where you might find an event loop wrapped in
  \texttt{forever}. The return type \texttt{b} is completely
  unconstrained, because \texttt{forever} never ``returns'' anyways.
\end{itemize}

\hypertarget{do-notation}{%
\subsection{\texorpdfstring{\texttt{do} notation
☆}{do notation ☆}}\label{do-notation}}

So monads are powerful and ubiquitous, and we have these expressive
monad operators to compose monadic actions, both for a concrete monad,
or abstractly. Code written using these operations might look like this:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} parses the format \textasciigrave{}23+42i\textasciigrave{} as a complex number}
\OtherTok{parseComplex ::} \DataTypeTok{Parser} \DataTypeTok{Complex}
\NormalTok{parseComplex }\OtherTok{=}
\NormalTok{  parseInteger }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ \textbackslash{}r }\OtherTok{{-}\textgreater{}}
\NormalTok{  parseStr }\StringTok{"+"} \OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ \textbackslash{}\_ }\OtherTok{{-}\textgreater{}}
\NormalTok{  parseInteger }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ \textbackslash{}i }\OtherTok{{-}\textgreater{}}
\NormalTok{  parseStr }\StringTok{"i"} \OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ \textbackslash{}\_ }\OtherTok{{-}\textgreater{}}
  \FunctionTok{return}\NormalTok{ (}\DataTypeTok{C}\NormalTok{ r i)}

\CommentTok{{-}{-} parses a sequence of such numbers, with the length given before}
\OtherTok{parseSequence ::} \DataTypeTok{Parser}\NormalTok{ [}\DataTypeTok{Complex}\NormalTok{]}
\NormalTok{parseSequence }\OtherTok{=}
\NormalTok{  parseInteger }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ \textbackslash{}n }\OtherTok{{-}\textgreater{}}
\NormalTok{  forM [}\DecValTok{1}\OperatorTok{..}\NormalTok{n] (\textbackslash{}\_ }\OtherTok{{-}\textgreater{}}\NormalTok{ parseComplex)}
\end{Highlighting}
\end{Shaded}

This works, but it is not really pretty. Therefore, Haskell offers
syntactic sugar for working with monads that hides the
\texttt{(\textgreater{}\textgreater{}=)} operator. It is called
\emph{\texttt{do}-notation} and makes the code read almost like
imperative code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} parses the format \textasciigrave{}23+42i\textasciigrave{} as a complex number}
\OtherTok{parseComplex ::} \DataTypeTok{Parser} \DataTypeTok{Complex}
\NormalTok{parseComplex }\OtherTok{=} \KeywordTok{do}
\NormalTok{  r }\OtherTok{\textless{}{-}}\NormalTok{ parseInteger}
\NormalTok{  parseStr }\StringTok{"+"}
\NormalTok{  i }\OtherTok{\textless{}{-}}\NormalTok{ parseInteger}
\NormalTok{  parseStr }\StringTok{"i"}
  \FunctionTok{return}\NormalTok{ (}\DataTypeTok{C}\NormalTok{ r i)}

\CommentTok{{-}{-} parses a sequence of such numbers, with the length given before}
\OtherTok{parseSequence ::} \DataTypeTok{Parser}\NormalTok{ [}\DataTypeTok{Complex}\NormalTok{]}
\NormalTok{parseSequence }\OtherTok{=} \KeywordTok{do}
\NormalTok{  n }\OtherTok{\textless{}{-}}\NormalTok{ parseInteger}
\NormalTok{  forM [}\DecValTok{1}\OperatorTok{..}\NormalTok{n] (\textbackslash{}\_ }\OtherTok{{-}\textgreater{}}\NormalTok{ parseComplex)}
\end{Highlighting}
\end{Shaded}

\newpage

But remember, it is really just sugar, and code involving \texttt{do}
simply gets translated into code using
\texttt{\textgreater{}\textgreater{}=}. The translation is pretty
straight-forward, and essentially as follows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{do}\NormalTok{ x }\OtherTok{\textless{}{-}}\NormalTok{ a    ⟹  a }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ (\textbackslash{}x }\OtherTok{{-}\textgreater{}} \KeywordTok{do}\NormalTok{ more)       }\KeywordTok{do}\NormalTok{ a   ⟹  a }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ (\textbackslash{}\_ }\OtherTok{{-}\textgreater{}} \KeywordTok{do}\NormalTok{ more)}
\NormalTok{   more                                          more}

\KeywordTok{do} \KeywordTok{let}\NormalTok{ x }\OtherTok{=}\NormalTok{ e ⟹  }\KeywordTok{let}\NormalTok{ x }\OtherTok{=}\NormalTok{ e }\KeywordTok{in} \KeywordTok{do}\NormalTok{ more         }\KeywordTok{do}\NormalTok{ a  ⟹  a}
\NormalTok{   more}
\end{Highlighting}
\end{Shaded}

Note the difference between \texttt{let\ x\ =\ e} and
\texttt{x\ \textless{}-\ a}. The former is simply a pure \texttt{let},
i.e.~gives a name to a pure expression; no monadic actions are executed
here, no bind is involved. The latter invokes
\texttt{(\textgreater{}\textgreater{}=)} and \texttt{x} is bound to the
``result'' of that monadic action.

When we use this style with the \texttt{IO} monad we end up with code
that almost looks like normal, say, Python:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{copyFile ::} \DataTypeTok{FilePath} \OtherTok{{-}\textgreater{}} \DataTypeTok{FilePath} \OtherTok{{-}\textgreater{}} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{copyFile from to }\OtherTok{=} \KeywordTok{do}
\NormalTok{    content }\OtherTok{\textless{}{-}} \FunctionTok{readFile}\NormalTok{ from}
    \FunctionTok{putStrLn}\NormalTok{ (}\StringTok{"Read "} \OperatorTok{++} \FunctionTok{show}\NormalTok{ (}\FunctionTok{length}\NormalTok{ content) }\OperatorTok{++} \StringTok{" bytes."}\NormalTok{)}
    \FunctionTok{writeFile}\NormalTok{ to content}

\OtherTok{main ::} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{main }\OtherTok{=} \KeywordTok{do}
    \FunctionTok{putStrLn} \StringTok{"Which file do you want to copy?"}
\NormalTok{    from }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
    \FunctionTok{putStrLn} \StringTok{"Where do you want to copy it to?"}
\NormalTok{    to }\OtherTok{\textless{}{-}} \FunctionTok{getLine}
\NormalTok{    copyFile from to}
    \FunctionTok{putStrLn} \StringTok{"Done copying."}
\end{Highlighting}
\end{Shaded}

\textbf{Exercise 27}

Implement
\texttt{forM\ ::\ Monad\ m\ =\textgreater{}\ {[}a{]}\ -\textgreater{}\ (a\ -\textgreater{}\ m\ b)\ -\textgreater{}\ m\ {[}b{]}}
using \texttt{do}-notation.

\hypertarget{functor-and-applicative}{%
\subsection{\texorpdfstring{\texttt{Functor} and \texttt{Applicative}
☆}{Functor and Applicative ☆}}\label{functor-and-applicative}}

In the \protect\hyperlink{monad-ops}{listing of derived monad
operations}, some type signatures had a \texttt{Functor} or
\texttt{Applicative} constraint instead of \texttt{Monad} constraint.
What are these?

Well, they are type classes, and here are their definitions, including
laws

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Functor}\NormalTok{ f }\KeywordTok{where}
\OtherTok{  fmap ::}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}

\CommentTok{{-}{-} Laws:}
\CommentTok{{-}{-} fmap id = id}
\CommentTok{{-}{-} fmap f . fmap g = fmap (f . g)}

\KeywordTok{class} \DataTypeTok{Functor}\NormalTok{ f }\OtherTok{=\textgreater{}} \DataTypeTok{Applicative}\NormalTok{ f }\KeywordTok{where}
\OtherTok{  pure ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ f a}
\OtherTok{  (\textless{}*\textgreater{}) ::}\NormalTok{ f (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}

\CommentTok{{-}{-} Laws:}
\CommentTok{{-}{-} pure id \textless{}*\textgreater{} v = v}
\CommentTok{{-}{-} pure (.) \textless{}*\textgreater{} u \textless{}*\textgreater{} v \textless{}*\textgreater{} w = u \textless{}*\textgreater{} (v \textless{}*\textgreater{} w)}
\CommentTok{{-}{-} pure f \textless{}*\textgreater{} pure x = pure (f x)}
\CommentTok{{-}{-} u \textless{}*\textgreater{} pure y = pure ($ y) \textless{}*\textgreater{} u}
\end{Highlighting}
\end{Shaded}

Like \texttt{Monad}, these are type classes of kind
\texttt{(*\ -\textgreater{}\ *)\ -\textgreater{}\ Constraint},
i.e.~\texttt{f} is a type constructor.

\begin{itemize}
\item
  The \texttt{Functor} type class allows you to apply a (pure) function
  to the (well, all) \texttt{a} in an \texttt{f\ a}. This is most
  intuitive when \texttt{f} is a container data structure like
  \texttt{Maybe} or lists. In fact, if \texttt{f} is simply the list
  type constructor, then \texttt{fmap} is the normal \texttt{map}
  function. For a type constructor with a more computational
  interpretation, such as \texttt{Parser} or \texttt{IO}, \texttt{fmap}
  simply ``keeps the extra meaning, and applies the function to the
  result''.

  The laws also express that \texttt{fmap} does not actually change the
  extra meaning of its argument.
\item
  The \texttt{Applicative} type class is very similar to \texttt{Monad}:
  It has \texttt{pure} instead of \texttt{return}, but they are
  essentially the same. And it has a binary operation, sometimes called
  \emph{ap}, that takes two values with extra meaning and composes them.
  The crucial difference is: With
  \texttt{(\textgreater{}\textgreater{}=)}, you choose which action to
  do as the second argument based on the \emph{return value} of the
  action of the first argument. With
  \texttt{(\textless{}*\textgreater{})}, both actions need to be given
  separately and independently, and only their results are combined.
  Therefore, there is strictly less you can do with the
  \texttt{Applicative} interface than with the \texttt{Monad} interface.

  The laws are analogous to the monad laws: Essentially,
  \texttt{(\textless{}*\textgreater{})} is associative and \texttt{pure}
  is its unit.
\end{itemize}

Every \texttt{Monad} is both an \texttt{Applicative} and a
\texttt{Functor}, as we have seen in the exercise in the previous
section. So \texttt{Monad} is more expressive than the other two. Why do
we bother with separate type classes for them? Because less expressive
interfaces are more widely applicable! If the user of an interface can
do less, then the implementor of an interface has more freedom.

What can we do with that freedom? Create more instances!

\begin{itemize}
\item
  Consider the following type constructor:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Two}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Two}\NormalTok{ a a}
\end{Highlighting}
\end{Shaded}

  It is a container, not unlike \texttt{Maybe} and lists, that stores
  exactly two values of type \texttt{a}. It is impossible to have a
  (lawful) \texttt{Monad} instance for this type. But it can have a
  \texttt{Functor} instance, and it is a very useful instance that we
  would often want:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Functor} \DataTypeTok{Two} \KeywordTok{where} \FunctionTok{fmap}\NormalTok{ f (}\DataTypeTok{Two}\NormalTok{ x y) }\OtherTok{=} \DataTypeTok{Two}\NormalTok{ (f x) (f y)}
\end{Highlighting}
\end{Shaded}

  This type constructor can also be given an \texttt{Applicative}
  instance, so it serves as a proof that \texttt{Applicative} is more
  general than \texttt{Monad}.
\item
  To see that \texttt{Functor} is more general than \texttt{Applicative}
  we can use the following type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Tagged}\NormalTok{ t a }\OtherTok{=} \DataTypeTok{Tagged}\NormalTok{ t a}
\end{Highlighting}
\end{Shaded}

  that is a value \texttt{a} with a tag \texttt{t}. This is easily a
  functor (just apply the function to the second parameter of
  \texttt{Tagged}), but there is no function
  \texttt{pure\ ::\ a\ -\textgreater{}\ Tagged\ t\ a}, because it would
  have to come up with a value of type \texttt{t} out of thin air, so
  there cannot be an \texttt{instance\ Applicative\ (Tagged\ t)}.

  \textbf{Exercise 28}

  You might observe that \texttt{Tagged} is simply the existing pair
  type. There is an \texttt{Applicative} instance for pairs. Look it up!
  How does that fit to what I just said?
\item
  And since we are discussing counter-examples, the type constructor

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{Printer}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Printer}\NormalTok{ (a }\OtherTok{{-}\textgreater{}} \DataTypeTok{String}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  is not even a \texttt{Functor}: Since a \texttt{Printer\ a}
  \emph{expects} a value of type \texttt{a}, you can't apply a function
  \texttt{a\ -\textgreater{}\ b} anywhere. (You could apply a function
  \texttt{b\ -\textgreater{}\ a}; this means that \texttt{Printer} is a
  \emph{contravariant functor}.)
\end{itemize}

At a high level, the main advantage of an applicative computation over a
monadic one is that the \emph{structure of the computation} is static,
and can be known ahead of time. This is not the case in a monadic
computation, because the second argument to
\texttt{(\textgreater{}\textgreater{}=)} is an opaque function, and only
once a concrete \texttt{a} was extracted from the first argument do we
know what kind of computation is produced by the second.

As a concrete example, consider a library that provides a type
constructor \texttt{AParser} that is an instance of
\texttt{Applicative}, but \emph{not} of \texttt{Monad}. You write a
parser \texttt{p\ ::\ AParser\ a} using this interface. Then the library
can ``run'' this parser without actual input, and learn everything it
\emph{would} do. It could use that to provide a function
\texttt{describe\ ::\ AParser\ a\ -\textgreater{}\ String} that produces
a grammar for the given parser, which you can use as documentation, and
thus these can never go out of sync.

\section*{Solutions}
\addcontentsline{toc}{section}{Solutions}

\textbf{Solution 1}

Both operators are left-associative, so that
\texttt{10\ -\ 2\ +\ 3\ -\ 4} means \texttt{((10\ -\ 2)\ +\ 3)\ -\ 4} as
expected.

\textbf{Solution 2}

The precedences of \texttt{(+)} and \texttt{(-)} are the same, and
smaller than the precedence of \texttt{(*)}, which is again smaller than
the precedence of \texttt{(\^{})}.

\textbf{Solution 3}

\begin{verbatim}
7
\end{verbatim}

\textbf{Solution 4}

\begin{verbatim}
3
\end{verbatim}

\textbf{Solution 6}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{absoluteValue x }\OtherTok{=} \KeywordTok{if}\NormalTok{ x }\OperatorTok{\textless{}} \DecValTok{0} \KeywordTok{then} \OperatorTok{{-}}\NormalTok{ x }\KeywordTok{else}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 7}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{isHalfRound x }\OtherTok{=}\NormalTok{ x }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10} \OperatorTok{==} \DecValTok{0} \OperatorTok{||}\NormalTok{ x }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10} \OperatorTok{==} \DecValTok{5}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 8}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{isEven x }\OtherTok{=}\NormalTok{ x }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10} \OperatorTok{==} \DecValTok{0} \OperatorTok{||}\NormalTok{ x }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10} \OperatorTok{==} \DecValTok{2} \OperatorTok{||}\NormalTok{ x }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10} \OperatorTok{==} \DecValTok{4} \OperatorTok{||}\NormalTok{ x }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10} \OperatorTok{==} \DecValTok{6} \OperatorTok{||}\NormalTok{ x }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10} \OperatorTok{==} \DecValTok{8}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 9}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sumDigits n }\OtherTok{=} \KeywordTok{if}\NormalTok{ n }\OperatorTok{\textless{}} \DecValTok{10} \KeywordTok{then}\NormalTok{ n }\KeywordTok{else}\NormalTok{ sumDigits (n }\OtherTok{\textasciigrave{}div\textasciigrave{}} \DecValTok{10}\NormalTok{) }\OperatorTok{+}\NormalTok{ (n }\OtherTok{\textasciigrave{}mod\textasciigrave{}} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 10}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fixEq f x }\OtherTok{=} \KeywordTok{if}\NormalTok{ x }\OperatorTok{==}\NormalTok{ f x }\KeywordTok{then}\NormalTok{ x }\KeywordTok{else}\NormalTok{ fixEq f (f x)}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 11}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{isMultipleOf3 x }\OtherTok{=}\NormalTok{ fixEq sumDigits x }\OperatorTok{==} \DecValTok{3} \OperatorTok{||}\NormalTok{ fixEq sumDigits x }\OperatorTok{==} \DecValTok{6} \OperatorTok{||}\NormalTok{ fixEq sumDigits x }\OperatorTok{==} \DecValTok{9}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 12}

The definitions for \texttt{countCountDigits} and \texttt{sumSumDigits}:

\begin{verbatim}
Prelude> countCountDigits = twice countCountDigits
Prelude> sumSumDigits = twice sumDigits
\end{verbatim}

\textbf{Solution 13}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{id}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 14}

It is the function \texttt{flip} that takes a function and swaps its
first two arguments.

\textbf{Solution 15}

This type is legal. Every value of type \texttt{Wat} is built from the
constructor \texttt{Wat}, applied to another value of type \texttt{Wat}.
So, unless there are exceptions or nontermination around, it is just an
infinite tower of \texttt{Wat}s:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{wat ::} \DataTypeTok{Wat}
\NormalTok{wat }\OtherTok{=} \DataTypeTok{Wat}\NormalTok{ wat}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 16}

There are four: \texttt{Nothing}, \texttt{Just\ Nothing},
\texttt{Just\ (Just\ False)} and \texttt{Just\ (Just\ True)}. It can be
useful if, for example, the outer \texttt{Maybe} indicates whether some
input was \emph{valid}, whereas \texttt{Just\ Nothing} could indicate
that the input was valid, but empty. But arguably this is not best
practice, and dedicated data types with more descriptive names could be
preferred here.

\textbf{Solution 17}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{Integer}\NormalTok{, }\DataTypeTok{Integer}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 18}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{fromEitherUnit ::} \DataTypeTok{Either}\NormalTok{ () a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Maybe}\NormalTok{ a}
\NormalTok{fromEitherUnit (}\DataTypeTok{Left}\NormalTok{ ()) }\OtherTok{=} \DataTypeTok{Nothing}
\NormalTok{fromEitherUnit (}\DataTypeTok{Right}\NormalTok{ x) }\OtherTok{=} \DataTypeTok{Just}\NormalTok{ x}

\OtherTok{toEitherUnit ::} \DataTypeTok{Maybe}\NormalTok{ a }\OtherTok{{-}\textgreater{}} \DataTypeTok{Either}\NormalTok{ () a}
\NormalTok{toEitherUnit }\DataTypeTok{Nothing} \OtherTok{=} \DataTypeTok{Left}\NormalTok{ ()}
\NormalTok{toEitherUnit (}\DataTypeTok{Just}\NormalTok{ x) }\OtherTok{=} \DataTypeTok{Right}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

We can make \texttt{fromEitherUnit} more polymorphic; it can simply
ignore the argument to \texttt{Left}. We cannot do this in
\texttt{toEitherUnit}: we would not have a value of type \texttt{b} at
hand to pass to \texttt{Left}.

\textbf{Solution 19}

\begin{verbatim}
Pondering the question...
42
\end{verbatim}

The line \texttt{return\ 23} doesn't do anything: There is no
side-effect, and the result (the value \texttt{23}) is not bound to any
variable and hence ignored.

\textbf{Solution 20}

\begin{verbatim}
Hooray!
Hooray!
Hooray!
Almost done
Hooray!
Done
Done
\end{verbatim}

Note that the \texttt{putStrLn\ "And\ up\ she\ rises."} is never
executed.

\textbf{Solution 21}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Eq} \DataTypeTok{Employee} \KeywordTok{where}
\NormalTok{    e1 }\OperatorTok{==}\NormalTok{ e2 }\OtherTok{=}
\NormalTok{        name e1 }\OperatorTok{==}\NormalTok{ name e2 }\OperatorTok{\&\&}
\NormalTok{        room e1 }\OperatorTok{==}\NormalTok{ room e2 }\OperatorTok{\&\&}
\NormalTok{        pubkey e1 }\OperatorTok{==}\NormalTok{ pubkey e2}
\end{Highlighting}
\end{Shaded}

The problem is: If the record gains additional fields, this code still
compiles, and the programmer is not warned that they should update it.
By not using the record accessors, and using normal constructor syntax
instead, this can be avoided:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Eq} \DataTypeTok{Employee} \KeywordTok{where}
    \DataTypeTok{Employee}\NormalTok{ n1 r1 p1 }\OperatorTok{==} \DataTypeTok{Employee}\NormalTok{ n2 r2 p2 }\OtherTok{=}
\NormalTok{        n1 }\OperatorTok{==}\NormalTok{ n2 }\OperatorTok{\&\&}\NormalTok{ r1 }\OperatorTok{==}\NormalTok{ r2 }\OperatorTok{\&\&}\NormalTok{ p1 }\OperatorTok{==}\NormalTok{ p2}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 22}

The \texttt{Semigroup} type class is defined as

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Semigroup}\NormalTok{ a }\KeywordTok{where}
\OtherTok{  (\textless{}\textgreater{}) ::}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

with the additional requirement that the
\texttt{(\textless{}\textgreater{})} operation is associative.

\textbf{Solution 23}

There are (at least) two sensible instances for the \texttt{Semigroup}
type class for trees:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The first one concatenates two trees, so that an in-order traversal
  first visits the value of the left and then of the right tree:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Semigroup}\NormalTok{ (}\DataTypeTok{Tree}\NormalTok{ a) }\KeywordTok{where}
    \DataTypeTok{Leaf} \OperatorTok{\textless{}\textgreater{}}\NormalTok{ t }\OtherTok{=}\NormalTok{ t}
    \DataTypeTok{Node}\NormalTok{ x l r }\OperatorTok{\textless{}\textgreater{}}\NormalTok{ t }\OtherTok{=} \DataTypeTok{Node}\NormalTok{ x l (r }\OperatorTok{\textless{}\textgreater{}}\NormalTok{ t)}
\end{Highlighting}
\end{Shaded}

  There are variations of this code that are more likely to produce a
  balanced tree -- although then it might be that associativity holds
  when one considers different shapes of the same data equivalent (which
  is commonly the case for search trees).
\item
  Another one traverses both trees in parallel, using a
  \texttt{Semigroup} instance for the elements to combine values that
  are present in both trees:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Semigroup}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Semigroup}\NormalTok{ (}\DataTypeTok{Tree}\NormalTok{ a) }\KeywordTok{where}
    \DataTypeTok{Leaf} \OperatorTok{\textless{}\textgreater{}}\NormalTok{ t }\OtherTok{=}\NormalTok{ t}
\NormalTok{    t }\OperatorTok{\textless{}\textgreater{}} \DataTypeTok{Leaf} \OtherTok{=}\NormalTok{ t}
    \DataTypeTok{Node}\NormalTok{ x l1 r1 }\OperatorTok{\textless{}\textgreater{}} \DataTypeTok{Node}\NormalTok{ y l2 r2 }\OtherTok{=} \DataTypeTok{Node}\NormalTok{ (x }\OperatorTok{\textless{}\textgreater{}}\NormalTok{ y) (l1 }\OperatorTok{\textless{}\textgreater{}}\NormalTok{ l2) (r1 }\OperatorTok{\textless{}\textgreater{}}\NormalTok{ r2)}
\end{Highlighting}
\end{Shaded}

  Here, the instance head itself has a constraint: This instance for
  \texttt{Tree\ a} only exists if there is a \texttt{Semigroup} instance
  for the type of values.
\end{enumerate}

Which instance is the right one? That depends on the purpose of the
\texttt{Tree} data structure in the code; and maybe neither is the right
one, in which case it might be better to have \emph{no} instance at all,
and use normal functions for these operations.

\textbf{Solution 24}

One might expect this code:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{summarize ::} \DataTypeTok{Monoid}\NormalTok{ a }\OtherTok{=\textgreater{}} \DataTypeTok{Tree}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ a}
\NormalTok{summarize }\DataTypeTok{Leaf} \OtherTok{=} \FunctionTok{mempty}
\NormalTok{summarize (}\DataTypeTok{Node}\NormalTok{ x l r) }\OtherTok{=}\NormalTok{ summarize l }\OperatorTok{\textless{}\textgreater{}}\NormalTok{ x }\OperatorTok{\textless{}\textgreater{}}\NormalTok{ summarize r}
\end{Highlighting}
\end{Shaded}

(at least given everything we did so far considered in-order
traversals.)

If we have two trees with the same elements in the same order, but in a
different shape, e.g.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1 }\OtherTok{=} \DataTypeTok{Tree}\NormalTok{ x }\DataTypeTok{Leaf}\NormalTok{ (}\DataTypeTok{Tree}\NormalTok{ y }\DataTypeTok{Leaf}\NormalTok{ (}\DataTypeTok{Tree}\NormalTok{ z }\DataTypeTok{Leaf}\NormalTok{))}
\NormalTok{t2 }\OtherTok{=} \DataTypeTok{Tree}\NormalTok{ y (}\DataTypeTok{Tree}\NormalTok{ x }\DataTypeTok{Leaf} \DataTypeTok{Leaf}\NormalTok{) (}\DataTypeTok{Tree}\NormalTok{ z }\DataTypeTok{Leaf} \DataTypeTok{Leaf}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

for some values \texttt{x}, \texttt{y} and \texttt{z}, then we will
always have \texttt{summarize\ t1\ =\ summarize\ t2}, assuming that the
\texttt{Monoid} instance for the type of values is lawful. This is
important if we use these trees as search trees, where the internal
shape should be an implementation detail that should not be visible from
the outside.

\textbf{Solution 27}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{forM ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ [a] }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m b) }\OtherTok{{-}\textgreater{}}\NormalTok{ m [b]}
\NormalTok{forM [] f }\OtherTok{=} \FunctionTok{return}\NormalTok{ []}
\NormalTok{forM (x}\OperatorTok{:}\NormalTok{xs) f }\OtherTok{=} \KeywordTok{do}
\NormalTok{    y }\OtherTok{\textless{}{-}}\NormalTok{ f x}
\NormalTok{    ys }\OtherTok{\textless{}{-}}\NormalTok{ forM xs f}
    \FunctionTok{return}\NormalTok{ (y }\OperatorTok{:}\NormalTok{ ys)}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 25}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import} \DataTypeTok{Prelude} \KeywordTok{hiding}\NormalTok{ (fmap, (\textless{}$\textgreater{}))}
\OtherTok{(\textgreater{}\textgreater{}) ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ m a }\OtherTok{{-}\textgreater{}}\NormalTok{ m b }\OtherTok{{-}\textgreater{}}\NormalTok{ m b}
\NormalTok{a }\OperatorTok{\textgreater{}\textgreater{}}\NormalTok{ b }\OtherTok{=}\NormalTok{ a }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ (\textbackslash{}\_ }\OtherTok{{-}\textgreater{}}\NormalTok{ b)}
\FunctionTok{fmap}\OtherTok{ ::} \DataTypeTok{Monad}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\FunctionTok{fmap}\NormalTok{ f a }\OtherTok{=}\NormalTok{ a }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ (}\FunctionTok{return} \OperatorTok{.}\NormalTok{ f)}
\OtherTok{(\textless{}$\textgreater{}) ::} \DataTypeTok{Monad}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\NormalTok{(}\OperatorTok{\textless{}$\textgreater{}}\NormalTok{) }\OtherTok{=} \FunctionTok{fmap}
\OtherTok{(\textless{}$) ::} \DataTypeTok{Monad}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b }\OtherTok{{-}\textgreater{}}\NormalTok{ f a}
\NormalTok{x }\OperatorTok{\textless{}$}\NormalTok{ a }\OtherTok{=} \FunctionTok{const}\NormalTok{ x }\OperatorTok{\textless{}$\textgreater{}}\NormalTok{ a}
\OtherTok{liftA2 ::} \DataTypeTok{Monad}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b }\OtherTok{{-}\textgreater{}}\NormalTok{ c) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b }\OtherTok{{-}\textgreater{}}\NormalTok{ f c}
\NormalTok{liftA2 f a b }\OtherTok{=}\NormalTok{ a }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ (\textbackslash{}x }\OtherTok{{-}\textgreater{}}\NormalTok{ b }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ (\textbackslash{}y }\OtherTok{{-}\textgreater{}} \FunctionTok{return}\NormalTok{ (f x y)))}
\OtherTok{(\textless{}*\textgreater{}) ::} \DataTypeTok{Monad}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ f (a }\OtherTok{{-}\textgreater{}}\NormalTok{ b) }\OtherTok{{-}\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\NormalTok{(}\OperatorTok{\textless{}*\textgreater{}}\NormalTok{) }\OtherTok{=}\NormalTok{ liftA2 (\textbackslash{}f x }\OtherTok{{-}\textgreater{}}\NormalTok{ f x)}
\OtherTok{(\textless{}*) ::} \DataTypeTok{Monad}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b }\OtherTok{{-}\textgreater{}}\NormalTok{ f a}
\NormalTok{(}\OperatorTok{\textless{}*}\NormalTok{) }\OtherTok{=}\NormalTok{ liftA2 (\textbackslash{}x y }\OtherTok{{-}\textgreater{}}\NormalTok{ x)}
\OtherTok{(*\textgreater{}) ::} \DataTypeTok{Monad}\NormalTok{ f }\OtherTok{=\textgreater{}}\NormalTok{ f a }\OtherTok{{-}\textgreater{}}\NormalTok{ f b }\OtherTok{{-}\textgreater{}}\NormalTok{ f b}
\NormalTok{(}\OperatorTok{*\textgreater{}}\NormalTok{) }\OtherTok{=}\NormalTok{ liftA2 (\textbackslash{}x y }\OtherTok{{-}\textgreater{}}\NormalTok{ y)}
\OtherTok{(\textgreater{}=\textgreater{}) ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m b) }\OtherTok{{-}\textgreater{}}\NormalTok{ (b }\OtherTok{{-}\textgreater{}}\NormalTok{ m c) }\OtherTok{{-}\textgreater{}}\NormalTok{ (a }\OtherTok{{-}\textgreater{}}\NormalTok{ m c)}
\NormalTok{a }\OperatorTok{\textgreater{}=\textgreater{}}\NormalTok{ b }\OtherTok{=}\NormalTok{ (\textbackslash{}x }\OtherTok{{-}\textgreater{}}\NormalTok{ a x }\OperatorTok{\textgreater{}\textgreater{}=}\NormalTok{ b)}
\OtherTok{join ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=\textgreater{}}\NormalTok{ m (m a) }\OtherTok{{-}\textgreater{}}\NormalTok{ m a}
\NormalTok{join a }\OtherTok{=}\NormalTok{ a }\OperatorTok{\textgreater{}\textgreater{}=} \FunctionTok{id}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 26}

Since \texttt{when\ False\ action} is not supposed to execute
\texttt{action}, it has no way of producing an \texttt{m\ a}. But it can
always create an \texttt{m\ ()} using \texttt{return\ ()}.

\textbf{Solution 28}

The instance is

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{Monoid}\NormalTok{ r }\OtherTok{=\textgreater{}} \DataTypeTok{Applicative}\NormalTok{ ((,) r)}
\end{Highlighting}
\end{Shaded}

and the \texttt{Monoid} constraint on \texttt{r} gives us exactly the
operations needed to implement \texttt{pure} and
\texttt{(\textless{}*\textgreater{})}. Try it yourself!

\end{document}
