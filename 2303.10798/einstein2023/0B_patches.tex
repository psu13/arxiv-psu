\section{Case analysis for $1$-patches}
\label{sec:patches}

We present here details of a computer-generated but human-verifiable
case analysis, based on consideration of $1$-patches rather than
$2$-patches.  This analysis can be used to complete a variant of the
proof in \secref{sec:clusters} that,
when tiles in a tiling by the hat polykite
are assigned labels following the rules given there, (a)~the labels
assigned do induce a division into the clusters shown, and (b)~the
clusters adjoin other clusters in accordance with the matching rules.
As is justified in Appendix~\ref{sec:align}, we only consider tilings
where all tiles are aligned with an underlying $[3.4.6.4]$ Laves
tiling.

\subsection{Enumeration of neighbours}

First we produce a list of possible neighbours of the hat polykite in a
tiling.  There are $58$~possible neighbours when we only require such
a neighbour not to intersect the original polykite; these are shown in
Figure~\ref{fig:nbr}, with that original polykite shaded.  The first
$41$ of these neighbours remain in consideration for the enumeration
of $1$-patches.  The final~$17$ are immediately eliminated (in the
order shown) because they cannot be extended to a tiling: either there
is no possible neighbour that can contain the shaded kite (without
resulting in an intersection, or a pair of tiles that were previously
eliminated as possible neighbours), or we eliminated $Y$ as a
neighbour of~$X$ and so can also eliminate $X$ as a neighbour of~$Y$.

\input{auto-tilea-nbrs}

\FloatBarrier

\subsection{Enumeration of $1$-patches}

Having produced a list of possible neighbours, we now proceed to
enumerating possible $1$-patches.  When we have a partial $1$-patch
(some number of neighbours for the original, shaded polykite), we pick
some kite neighbouring that original polykite and enumerate the
possible neighbouring polykites containing that kite, excluding any
that would result in the patch containing two polykites that either
intersect or form a pair of neighbours previously ruled out; the kite
we use is chosen so that the number of choices for the neighbour added
is minimal.  This process results in $37$~possible $1$-patches; the
partial patches from the search process are shown in
Figure~\ref{fig:partpatch} and the $1$-patches are shown in
Figures~\ref{fig:patch}.

Some of the $1$-patches found can be immediately eliminated at this
point, by identifying a tile in the $1$-patch that cannot itself be
surrounded by any of the $1$-patches (that has not yet been
eliminated) without resulting in either an intersection or a pair of
neighbours that were previously ruled out.  In the $12$ cases 
implicated here, the tile that cannot be surrounded is shaded, and they are
eliminated in the order shown, leaving $25$~remaining $1$-patches.
For each of those remaining $1$-patches, the classification of the
central tile by the
rules in \secref{sec:clusters} is shown.

\input{auto-tilea-patches}

\FloatBarrier

\subsection{Classification of outer tiles}

For each of the possible neighbours that actually occurs in some of
the remaining $1$-patches, we can now list the possible
classifications of a central tile that has such a neighbour; see
Table~\ref{table:nbrclass}.

For each of the outer tiles in a $1$-patch, we have some but not all
of its neighbours, and can take the intersection of the sets from
Table~\ref{table:nbrclass} to produce a set of possible classes for
that outer tile.  Although this is not a single class, it can still be
used for the within-cluster and between-cluster checks.  In each case,
it turns out that the set of possible classes for a neighbour
appearing in one of those checks is a subset of the classes permitted
by that check, and so we have a complete proof of the within-cluster
and between-cluster matching properties that depends only on the
enumeration of $1$-patches presented here and not on a larger
enumeration of $2$-patches; the lists of checks and corresponding sets
of classes appear below.

\input{auto-tilea-patch-checks}

\FloatBarrier
