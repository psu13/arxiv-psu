\section{Formalisation in Coq}
\label{sec:formalisation-coq}

We have partially formalised our work in the Coq proof assistant~\citep{coq} on top of the HoTT library~\citep{bauer17:_hott}. The formalisation is publicly available at~\citep{lumsdaine:_formal}, wherein further instructions are given on how to compile and use the formalisation.
%
The formalisation will continue to evolve in future; the description here refers to the version tagged as \texttt{\small arXiv}.

The formalisation broadly follows the structure of the paper.
%
\Cref{tab:dict-paper-coq} lists selected major definitions and theorems from the paper, along with the names of the corresponding items in the formalisation, if any.
%
Almost all material of \cref{sec:preliminaries,sec:raw-syntax,sec:typing} has been formalised, as has some but not all of \cref{sec:well-behavedness}.
%
Versions of the main definitions of \cref{sec:well-founded-type-theories} are also formalised, but at time of writing, their treatment in the formalisation has non-trivial differences from the definitions here; such items are marked with an asterisk.
 
\begin{table}[htbp]
  \centering
  \footnotesize
  \begin{tabular}{ll}
    \toprule
    Paper & Formalisation \\ \midrule
    Family
    (\cref{def:family})
    & \coqident{Auxiliary.Family.family}
    \\
%    Family map
%    (\cref{def:family-map})
%    & \coqident{Auxiliary.Family.map}
%    \\
%    Family map over
%    (\cref{def:family-map-over})
%    & \coqident{Auxiliary.Family.over}
%    \\
    Closure rule
    (\cref{def:closure-rule})
    & \coqident{Auxiliary.Closure.rule}
    \\
    Closure system
    (\cref{def:closure-system})
    & \coqident{Auxiliary.Closure.system}
    \\
    Derivation
    (\cref{def:closure-system-derivation})
    & \coqident{Auxiliary.Closure.derivation}
    \\
%    Derivation grafting
%    (\cref{lem:hypotheses-grafting})
%    & \coqident{Auxiliary.Closure.graft}
%    \\
%    Well-founded order
%    (\cref{def:well-founded-order})
%    & \coqident{Auxiliary.WellFounded.well\_founded\_order}
%    \\
    Scope system
    (\cref{def:scope-system})
    & \coqident{Syntax.ScopeSystem.system}
    \\
    De Bruijn scope system
    (\cref{ex:de-bruijn-scope-systems})
    & \coqident{Examples.ScopeSystemExamples.DeBruijn}
    \\
    Syntactic class
    (\cref{def:syntactic-class})
    & \coqident{Syntax.SyntacticClass.class}
    \\
    Arity
    (\cref{def:arity})
    & \coqident{Syntax.Arity.arity}
    \\
    Signature
    (\cref{def:signature})
    & \coqident{Syntax.Signature.signature}
    \\
    Signature map
    (\cref{def:signature-map})
    & \coqident{Syntax.Signature.map}
    \\
    Raw expressions
    (\cref{def:raw-syntax})
    & \coqident{Syntax.Expression.expression}
    \\
    % Renaming action
    % (\cref{renaming-action})
    % & \coqident{Syntax.Expression.rename}
    % \\
    % Signature map action
    % (\cref{def:signature-map-action})
    % & \coqident{Syntax.Expression.rename}
    % \\
%    Renaming functoriality
%    (\cref{prop:commutation-renaming-signature-map})
%    & \coqident{Syntax.Expressions.Renaming}
%    \\
%    Signature map functoriality
%    (\cref{prop:commutation-renaming-signature-map})
%    & \coqident{Syntax.Expressions.Signature\_Maps}
%    \\
    Raw substitution
    (\cref{def:raw-substitution})
    & \coqident{Syntax.Substitution.raw\_substitution}
    \\
    Metavariable extension
    (\cref{def:metavariable-extensions})
    & \coqident{Syntax.Metavariable.extend}
    \\
    Instantiation of syntax
    (\cref{def:instantiation})
    & \coqident{Syntax.Metavariable.instantiate\_expression}
    \\
    Raw context
    (\cref{def:raw-context})
    & \coqident{Typing.Context.raw\_context}
    \\
    Raw rule
    (\cref{def:raw-rule})
    & \coqident{Typing.RawRule.raw\_rule}
    \\
    Instantiation of derivations
    (\cref{cor:instantiation-of-derivations})
    & \coqident{Typing.RawTypeTheory.instantiate\_derivation}
    \\
    Associated closure system
    (\cref{def:associated-closure-system})
    & \coqident{Typing.RawRule.closure\_system}
    \\
    Structural rules
    (\cref{def:structural-rules})
    & \coqident{Typing.StructuralRule.structural\_rule}
    \\
    Congruence rule
    (\cref{def:congruence-rule})
    & \coqident{Typing.RawRule.raw\_congruence\_rule}
    \\
    Raw type theory
    (\cref{def:raw-type-theory})
    & \coqident{Typing.RawTypeTheory.raw\_type\_theory}
    \\
    Acceptable rule
    (\cref{def:acceptable-rule})
    & (not formalised)
    \\
    Acceptable type theory
    (\cref{def:theory-good-properties})
    & \coqident{Metatheorem.Acceptability.acceptable}
    \\
    Presuppositions theorem
    (\cref{thm:presuppositions})
    & \coqident{Metatheorem.Presuppositions.presupposition}
    \\
    Admissibility of renaming
    (\cref{lem:admissibility-renaming})
    & \coqident{Metatheorem.Elimination.rename\_derivation}
    \\
    Admissibility of substitution
    (\cref{lem:admissibility-substitution})
    & \coqident{Metatheorem.Elimination.substitute\_derivation}
    \\
    Admissibility of equality substitution
    (\cref{lem:admissibility-equality-substitution})
    & \coqident{Metatheorem.Elimination.substitute\_equal\_derivation}
    \\
    Elimination of substitution
    (\cref{thm:elimination-substitution})
    & \coqident{Metatheorem.Elimination.elimination}
    \\
    Uniqueness of typing
    (\cref{thm:tight-uniqueness-of-typing})
    & (not formalised)
    \\
    Inversion principle
    (\cref{thm:inversion-principle})
    & (not formalised)
    \\
    Sequential context
    (\cref{def:seq-cxt-by-rules})
    & \coqident{ContextVariants.wf\_context\_derivation}$^{(*)}$
    \\
    Sequential rule
    (\cref{def:sequential-rule})
    & (not formalised)
    \\
    Well-presented rule
    (\cref{def:realisation-well-presented-rule})
    & (not formalised)
    \\
    Well-presented type theory
    (\cref{def:well-presented-type-theory})
    & \coqident{Presented.TypeTheory.type\_theory}$^{(*)}$
    \\
    Well-founded replacement
    (\cref{thm:wf-replacement-equivalence})
    & (not formalised)
    \\ \bottomrule
  \end{tabular}
  \caption{The correspondence between the paper and the formalisation~\citep{lumsdaine:_formal}. Items marked with~$(*)$ differ non-trivially from their counterparts in the paper.}
  \label{tab:dict-paper-coq}
\end{table}

Throughout the paper we worked rigorously but informally, and without discussing which mathematical foundation might be sufficient to carry out the constructions and proofs.
%
On this topic we may consult the formalisation.

Our formalisation is built on top of a homotopy type theory library with an eye towards future formalisation of the categorical semantics of type theories, but is so far agnostic with respect to commitments such as the Univalence axiom or the Uniqueness of identity proofs. The only axiom that we use is function extensionality. In other words, the code can be read in plain Coq.

The formalisation confirms that our development is constructive, there are no uses of excluded middle or the axiom of choice.

It is a bit harder to tell how many universes we have used, because Coq relieves the user from explicit handling of universes. Two seem to be enough, one to serve as a base and another to work with families over the base. The base universe can be very small, say consisting of the decidable finite types, if we limit attention to finitary syntax only.

We rely in many places on the ability to perform inductive constructions and carry out proofs by induction, and so we require some meta-theoretic support for these. Of course, there is no shortage of induction in Coq, and even a fairly weak set theory will have the capability to construct the necessary inductive structures, whereas the higher-order logic of toposes would have to be extended with $W$-types. Alternatively, we could restrict to finitary syntax, contexts and rules throughout to allow GÃ¶delization of 
syntax and reliance on induction supplied by arithmetic.

%%% Local Variables:
%%% mode: latex
%%% End:
