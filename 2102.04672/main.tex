\documentclass[12pt]{article}

%%% LICS SUGGESTED PACKAGES %%%
%\usepackage{algorithmic}
%\usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
%\usepackage{fixltx2e}
%\usepackage{stfloats}
%\usepackage{dblfloatfix}
%\usepackage{url}

\usepackage[colorlinks=true
,breaklinks=true
,urlcolor=blue
,anchorcolor=blue
,citecolor=blue
,filecolor=blue
,linkcolor=blue
,menucolor=blue
,linktocpage=true]{hyperref}
\hypersetup{
bookmarksopen=true,
bookmarksnumbered=true,
bookmarksopenlevel=10
}
\usepackage[noBBpl,sc]{mathpazo}
\usepackage[papersize={7.0in, 10.0in}, left=.5in, right=.5in, top=1in, bottom=.9in]{geometry}
\linespread{1.05}
\sloppy
\raggedbottom
\pagestyle{plain}
% these include amsmath and that can cause trouble in older docs.
\input{../helpers/cmrsum}
\input{../helpers/fix-underbrace.tex}

\usepackage[small]{titlesec}
\usepackage{cite}

\usepackage{subfiles}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{pict2e}
\usepackage[mathscr]{euscript}
\usepackage{tikz-cd}
\usetikzlibrary{decorations.pathmorphing}
\usepackage{caption, floatrow}
\usepackage{graphicx}
\usepackage{array}
%\usepackage{bussproofs}
\usepackage{ebproof}
\usepackage{epigraph}
\usepackage{upgreek}
\usepackage{csquotes}
\usepackage{hyperref}
\usepackage{fancybox}
\usepackage{nicematrix}
\usepackage{stmaryrd} % for double brackets ⟦-⟧

\DeclareMathSymbol{'}{\mathord}{operators}{"3A}

\hypersetup{colorlinks=true}

\usepackage[colorinlistoftodos]{todonotes} % Todo notes
\newcommand{\CWin}[1]{{\color{purple} Christian: #1}}
\newcommand{\MSin}[1]{{\color{orange} Mike: #1}}

% formatting
\newcommand{\cnt}[1]{\begin{center}#1\end{center}}
\newcommand{\arr}[2]{
  \[\arraycolsep=1pt\def\arraystretch{1.4}
    \begin{array}{#1}#2\end{array}\]}
\newcolumntype{L}{>$l<$}
\newcolumntype{R}{>$r<$}
\newcolumntype{C}{>$c<$}

% theorems
\theoremstyle{definition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}[theorem]{Example}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem*{note}{Note}

\newcommand{\define}[1]{{\bf \boldmath{#1}}}

% fonts
\newcommand{\msf}[1]{\mathsf{#1}}
\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\msc}[1]{\mathscr{#1}}
\newcommand{\mrm}[1]{\mathrm{#1}}
\newcommand{\mtt}[1]{\mathtt{#1}}

\newcommand{\rtail}{\rightarrowtail}
\newcommand{\xr}[2]{\xrightarrow[#2]{#1}}
\newcommand{\ra}{\Rightarrow}
\newcommand{\op}{\mrm{op}}
\newcommand{\lrh}{\leftrightharpoons}

% categories
\newcommand{\T}{\mrm{T}}
\newcommand{\Set}{\mrm{Set}}
\newcommand{\Cat}{\mrm{Cat}}
\newcommand{\Mod}{\mrm{Mod}}
\newcommand{\HOAT}{\mrm{HOAT}}
\newcommand{\CartEx}{\mrm{CartEx}}
\newcommand{\coRefl}{\mrm{coRefl}}
\newcommand{\Sub}{\mrm{Sub}}
\newcommand{\CHA}{\mrm{CHA}}
\newcommand{\Topos}{\mrm{Topos}}
\newcommand{\Fib}{\mrm{Fib}}
\newcommand{\Rep}{\msf{Rep}}
\newcommand{\Prop}{\msf{Prop}}
\newcommand{\Type}{\msf{Type}}

\newcommand{\C}{\mrm{C}}
\newcommand{\D}{\mrm{D}}
\newcommand{\R}{\mrm{R}}
\newcommand{\aych}{\mrm{H}}
\newcommand{\ess}{\mrm{S}}
\newcommand{\F}{\mrm{F}}
\newcommand{\I}{\mrm{I}}
\newcommand{\E}{\mrm{E}}

% topos
\newcommand{\pow}{\msc{P}}
\newcommand{\wand}{\mbox{--\!$\ast$}}

% theory
\newcommand{\ttC}{\mtt{C}}
\newcommand{\ttr}{\mtt{R}}
\newcommand{\tts}{\mtt{S}}
\newcommand{\ttt}{\mtt{T}}
\newcommand{\ttu}{\mtt{U}}
\newcommand{\ttB}{\mtt{B}}
\newcommand{\TT}{\mtt{T}}
\newcommand{\ttx}{\mtt{x}}
\newcommand{\ttf}{\mtt{f}}
\newcommand{\ttg}{\mtt{g}}
\newcommand{\tth}{\mtt{h}}
\newcommand{\ttY}{\mtt{Y}}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}

% th.rho
\newcommand{\N}{\mtt{N}}
\newcommand{\PP}{\mtt{P}}
\newcommand{\tto}{\mtt{out}}
\newcommand{\tti}{\mtt{in}}
\newcommand{\ttz}{\mtt{0}}
\newcommand{\n}{\mtt{n}}
\newcommand{\p}{\mtt{p}}
\newcommand{\q}{\mtt{q}}
\newcommand{\tta}{\mtt{a}}
\newcommand{\ttb}{\mtt{b}}
\newcommand{\ttc}{\mtt{c}}


\begin{document}
\title{Native Type Theory}
\date{9 Feb 2021}
% \author{
% \IEEEauthorblockN{Author(s) anonymized} }

\author{
{Christian Williams}
\and
{Michael Stay}}


\maketitle

\begin{abstract}
    We present a method to construct ``native'' type systems for a broad class of languages, in which types are built from term constructors by predicate logic and dependent types. Any language with products and functions can be modelled as a higher-order algebraic theory with rewrites, and the internal language of its presheaf topos provides total specification of the structure and behavior of terms. This construction is functorial, so translations of languages give translations of type systems.  The construction therefore provides a shared framework of higher-order reasoning for most existing programming languages.
\end{abstract}

\section{Introduction}
\label{sec:intro}

% The paper must be in English and provide sufficient detail to allow the program committee to assess the merits of the paper. It should begin with a succinct statement of the issues, a summary of the main results, and a brief explanation of their significance and relevance to the conference and to computer science, all phrased for the non-specialist. Technical development directed to the specialist should follow.

As society becomes rooted in network computing, it is vital to develop general methods of reasoning about code. Type theory is growing as a guiding philosophy in the design of programming languages, but in practice type systems are mostly heterogeneous, and there are not standard ways to reason across languages. In this paper we construct from a higher-order presentation a \textit{native type system} which provides total specification of the structure and behavior of terms.
% \footnote{Completeness of native types with respect to structure is apparent in the construction; for behavior we construct a complete modal logic.}

% (more explicit?)
% In this paper we construct and apply a functor which takes a higher-order presentation and gives the internal logic of the presheaf topos of the classifying category, which we call the \textit{native type system} of the language.

Categorical logic unifies languages: virtually any formalism, from a simple heap to the calculus of constructions, can be modelled as a structured category \cite{jacobs}. In doing so, we inherit a wealth of tools from category theory. In particular, we can generate expressive type systems by composing known ideas:
\[\mtt{language} \xr{\Lambda}{}  \mtt{category} \xr{\pow}{} \mtt{topos} \xr{\Phi}{} \mtt{type \; system}\]
The first $\Lambda$ forms the \textit{syntactic category} of a language \cite{lawvere}; the second $\pow$ is the \textit{presheaf construction} \cite{leinster}; and the third $\Phi$ is the concept of \textit{logic over a type theory} \cite{jacobs}. The composite is functorial, so that translations between languages induce translations between type systems.

%The completeness and soundness of the type theory are apparent in the construction, and are proved in e.g. \cite{jacobs}.

The type system is \textit{native} in the sense that types are built only from term constructors, predicate logic, and a form of dependent type theory. For example, the following predicate on processes in a concurrent language is a compile-time firewall.
\[\mu\mtt{X}.\; (\tti(\alpha,\N.\mtt{X})\;\vert\; \PP) \land \neg(\tti(\neg\alpha,\N.\PP)\;\vert\; \PP))\]
\cnt{\footnotesize{``Can always input from channels in the set $\alpha$ and cannot input from $\neg\alpha$.''}}

Native type theory is intended to be a practical framework to equip all programming languages with a shared system for higher-order reasoning. The authors believe that the potential applications are significant and broad, and we advocate for community development.

\subsection{Motivation and Implementation}
\label{ssec:motivation}

Why do we want native type systems? How can they be implemented practically? What are the intended applications?

% Experience has shown that static types are essential to understanding and maintaining code. Yet many widely-used languages, such as JavaScript, do not have well-structured type systems. What should be done then?

JavaScript is a dynamic, weakly-typed language built into every web browser. When code breaks, it does so at runtime.  Online companies have recognized that correct and maintainable code requires static type checking. Microsoft's TypeScript \cite{microsoft}, Facebook's Flow \cite{facebook}, and Google's Closure Compiler \cite{google} are all multi-million dollar efforts to retrofit JavaScript with a strong, static type system.

The native type system of JavaScript is free, and sound by construction: it conditions code explicitly by its structure and behavior.  By specifying both the language and the platforms on which it runs, JavaScript can be formally integrated into composite systems, to reason in the practical context of communicating with a back-end server ($\S$\ref{ssec:composite}).

We aim to implement native type theory as a tool which inputs the formal semantics of a language and outputs a type system, which can then be used to condition an entire codebase. Properly integrated, it could introduce expressive type theory directly into everyday programming. To do so, we plan to utilize the progress made in language specification.

K Framework \cite{kframe} is a popular formal verification tool which has been used to give complete semantics of many popular languages, including JavaScript, C, Java, Python, Haskell, LLVM, Solidity, and more.  These specifications can represented as ``higher-order algebraic theories with rewrites'', which we explore in $\S$\ref{algthy}. These in turn can serve as the input of the native types method.

The type system generated can then be used for many purposes, e.g. to query codebases. The search engine Hoogle \cite{hoogle} queries Haskell libraries on Stackage by function signature. The system can be expanded to many languages, and strengthened by more expressive types. For example, if $\varphi:\tts\to \Prop$ is a type of program and $\psi:\ttt\to \Prop$ is a security property, there is a ``rely-guarantee'' operator to form the type of $\tts.\ttt$-contexts for which substituting a program with property $\varphi$ guarantees the property $\psi$ ($\S$\ref{ssec:sub}).
\[\begin{array}{ll}
    [\varphi, \psi] & := \{\lambda x.c:\tts\to \ttt \;|\; \forall p : \tts.\; \varphi(p) \ra \psi(c[p/x])\}
\end{array} \]
RV-Match \cite{RVMatch} is a tool built with K Framework that finds undefined behavior in C code, essentially unifying code against the type $[\mathsf{program\_input}, \mathsf{undefined}]$.  Searching for such a type in a codebase would automate bug discovery.

Of course, the applications of native type systems require substantial development. Most basic is the need for efficient type-checking, but much has been done for this \cite{coqTypeCheck}. For usability we need conversion between existing types and native types, as well as libraries of native types, so programmers can say useful things without overly complex formulae.

The larger endeavor, to create a framework for reasoning across many languages, calls for developing a public library of both formal semantics and translations between languages.

\subsection{Origin and Connected Ideas}
\label{ssec:connected}

There are many kinds of language-specific logics which share generally the same form:
\[\T\text{-logic} = \T\text{-constructors} + \text{predicate logic } + \text{ recursion}.\]

The present work began in seeking to generate these logics for concurrency. For example, Hennessy-Milner logic \cite{hml} uses formulae that determine when processes are bisimilar. Spatial-behavioral logic \cite{caires} specifies system properties such as secrecy and resource usage \cite{spatial}. Namespace logic \cite{namespace} for the $\uprho$-calculus \cite{rhocal} ($\S$\ref{ssec:rho}) expands these in reasoning about data and channels.

In literature review, we found that Matching $\mu$-Logic \cite{matchlog}, the basis of K Framework, is closely related work. It is based on ``patterns'', formulae made from term constructors, predicate logic, and recursion.  The present work generalizes the logic to include binding operations, and gives a categorical foundation which provides substantial expansions, such as dependent and inductive types. The precise relation to Matching $\mu$-Logic is yet to be expounded.

In ``Functors are Type Refinement Systems'' \cite{refine}, Melli\`es and Zeilberger introduce a syntax for reasoning about functors $F:\mrm{D}\to \T$, and use this to distinguish two notions of type.

\textit{Intrinsic types} are the sorts of a language, $\tts:\T$, i.e. the symbols in a BNF grammar or the parts of the total state of a machine. In the $\pi$-calculus, there are distinct sorts $\N$ and $\PP$ for name and process. In a grammar of an 80x86 CPU, there would be distinct sorts for each of the registers and another for the address space.

\textit{Refinement types} are predicates on a sort, $\varphi:\tts\to \msf{Prop}$. In Hoare logic \cite{hoare}, assertions are predicates on the valuation of a memory heap. The triples $\{\varphi\}C\{\psi\}$, which express that if $\varphi$ holds and command $C$ is applied then $\psi$ holds, are modelled as the preimage $F^{-1}(C)$.

Static type systems have historically focused on intrinsic types, but refinement types are growing in popularity. Template meta-programming in C++ allows checking propositions at compile time \cite{template}. TypeScript has type guards that refine union types and superclasses to subclasses \cite{typeguards}. Haskell has various libraries that provide compile-time refinement types \cite{haskellrefinement}.

A natural setting for this type distinction is a topos, a category with a structure called a \textit{predicate fibration}, which we use in this paper. The modelling of type theories with toposes is well-established; pertinent here is the Hyland--Pitts model of the Calculus of Constructions \cite{cocmodel}, and more generally the notion of classifying topos \cite[X]{sheavesinGL}.

\subsection{Contribution and Organization}

The primary goal of the paper is to show that composing a few ideas in categorical logic can be very useful to computer science. In the process, we emphasize many facts that are known in theory but not widely used in practice; we also define and prove the existence of several new constructions.

We give two sections to develop the categorical foundation, one section to present the type system, and one section to demonstrate applications. The reader focused on the latter half can first see $\S$\ref{sec:typeth},\ref{sec:apply}. The sections are organized as follows.

$\S$\ref{algthy} \textbf{Higher-order algebraic theories} \cite{hoat} are a general framework for modelling languages with product and function types. We define a new category HOAT and introduce the concept of theories with rewriting. We use the $\uprho$-calculus ($\S$\ref{ssec:rho}) as a running example for demonstrating concepts.

$\S$\ref{sec:topos} \textbf{The logic of a presheaf topos}. A theory embeds into a presheaf topos, and we develop its structure. We show that its predicate and codomain fibrations form a cartesian closed, complete and cocomplete structure of dependent type theory, and we prove that this construction is functorial.
\[\mrm{Pres}^\op \xr{\Lambda}{} \HOAT^\op\xr{\pow}{} \mrm{CCT} \xr{\Phi}{} \mrm{CHDT}\]
The internal hom of types is highly expressive; we give a new form of type-level binding called reification.

$\S$\ref{sec:typeth} \textbf{The native type system} is presented as the internal language of the topos structure. The system is an extension of \textit{full higher-order dependent type theory} \cite{jacobs}, as in the Calculus of Constructions \cite{coc}. We present the system as generated from the theory, and outline the basic types, rules, and usage.

$\S$\ref{sec:apply} \textbf{Applications}. We describe several concrete applications: modalities for security and liveness, rely-guarantee for semantic search, sublanguages for managing resources, translation of types between languages, and types for composite systems.



\section{Higher-order algebraic theories}
\label{algthy}

The syntax of a programming language can be modelled by a \textit{syntactic category}, in which an object is a sorted variable context, a morphism is a term constructor, and composition is substitution. Algebraic theories are a class of such categories, which provide a general formalism of algebraic structures \cite{algthys}. Recently, they have been generalized to include higher-order operations of logic and computer science \cite{hoat}. We give an overview of higher-order algebraic theories: their syntax and structure, the category they form, and motivating examples.
%\footnote{Equivalently, a BNF grammar generates a category in which an object is a symbol and a morphism is a production rule.}

%Single-sorted theories, introduced by Lawvere \cite{lawvere}, are equivalent to finitary monads on $\Set$ \cite{linton}. This offers an alternate view of the data structures and computational effects of functional programming \cite{hylandpower}.

Algebraic structures, defined by operations and equations, can be defined in any cartesian category. The 2-category of cartesian categories has been studied as the abstract setting of multisorted universal algebra \cite{algthys}. These categories model many structures found in mathematics and computer science.

\begin{example}
The algebraic theory of a $\mtt{stack}$ of $\mtt{A}$ is presented:
\[\begin{array}{rrl@{\quad}rrl}
    \mtt{push}: & \tts\times \mtt{A} &\to \tts & \mtt{pop}: & \tts & \to \tts\\
    \mtt{empty}: & 1 & \to \tts & \mtt{top}: & \tts & \to \mtt{A}
\end{array}\]
\[\langle\mtt{pop}(\mtt{push}\langle l,i\rangle),\mtt{top}(\mtt{push}\langle l,i\rangle) \rangle = \langle l,i\rangle.\]
\end{example}

In logic and computer science, there are \textit{higher-order} operations whose operands are themselves operations, such as universal quantification with predicates and $\lambda$-abstraction with expressions. Higher-order operations bind the variables of their operands, which establishes the concept of evaluation.

Binding and capture-avoiding substitution are formalized by monad strength with respect to a monoidal structure on presheaves \cite{abssyn}. But in computer science, it is standard to use \textit{exponentials} to represent variable-binding operators. This practice was formally justified by Fiore and Mahmoud \cite{soats}, who proved the binding algebraic structure of Fiore, Plotkin, and Turi \cite{abssyn} to be equivalent to exponential structure.

To represent a higher-order operation, a cartesian category is equipped with an exponentiable object $\tts$. Then $\ttt^\tts$ represents terms of sort $\ttt$ with free variable of sort $\tts$; hence an operation $\ttt^\tts\to \ttu$ inputs terms of the form $\lambda x:\tts.f(x):\ttt$, and binds $x$. The definition of $\ttt^\tts$ is characterized by the evaluation map, which substitutes terms of sort $\tts$ for the free variable.

\begin{definition}
    Let $\T$ be a cartesian category. An object $\tts\in \T$ is \define{exponentiable} if the functor $\tts\times -$ has a right adjoint $(-)^\tts$. We may denote $\ttt^\tts$ as $[\tts,\ttt]$ for readability.

% f: (u:U \times x:S) \to T
% lam x:S.f(-, x) : U \to T^S
% lam x:S.f(u, x) : (u:U) \to T^S
    
    We denote ``currying'' $\ttf:\ttu\times \tts\to \ttt$ by $\lambda x.\ttf:\ttu\to \ttt^\tts$ (short for $\lambda x'\tts.\ttf(-,x)$), and the counit by $ev_{\tts,\ttt}:\tts\times \ttt^\tts\to \ttt$, written in syntax as substitution: $\ttf[u/x] := ev_{\tts,\ttt}(u,\lambda x.\ttf)$.
    
    A cartesian functor $F:\T_1\to \T_2$ \define{preserves} an exponentiable object $\tts$ if $F(\tts)$ is exponentiable and for all $\ttt$ $$\lambda x.(ev_{\tts,\ttt}\circ \langle F(\pi_\tts),F(\pi_{\ttt^\tts})\rangle^{-1}):F(\ttt^\tts)\simeq F(\ttt)^{F(\tts)}.$$ If $F$ preserves all exponentiable objects of $\T_1$ it is \define{cartex}.
\end{definition}

A higher-order algebraic theory is essentially a cartesian category equipped with objects which are exponentiable ``up to a certain order''. For example, the control operators of \cite{escard} are third-order operations of the form $\ttt^{(\ttt^\tts)}\to \tts$ and $\tts^{(\ttt^\tts)}\to \tts$.

The context for higher-order algebraic theories is contained in that of algebraic theories, because we require the functors to preserve the exponentiable objects.

\begin{definition}
    The 2-category of cartesian categories, cartex functors, and natural transformations is denoted $\CartEx$. 
    
    %The wide sub-2-category of strict cartex functors is denoted $\CartEx_s$.
\end{definition}

The 2-category $\CartEx$ is one definition of the universe of higher-order algebraic theories. However, more refined structure is necessary for syntactic presentation of theories. In particular, it must be represented explicitly in the theory that every sort is generated by products and exponents from a set of base sorts, an element of which is denoted $\ttB$.

\subsection{Presentation and syntax}

To formalize higher-order presentations, \cite[A1]{hoat} defines the $n$th-order $S$-sorted simply typed $\lambda$-calculus, meaning that $\lambda$-abstraction is limited to order $n$; we denote this language by $\lambda_n(S)$. Contexts, terms, and substitution define a classifying category $\Lambda_n(S)$, which is a free cartesian category with base sorts in $S$ being exponentiable to order $n$.
%\footnote{Here we take the American view that the ground is the ``first floor''.} 

\begin{definition}
    An \define{$n$th-order $S$-sorted signature} consists of a set of operations $O$ and an arity function $\lvert -\rvert:O\to \Lambda_n(S)\times S$.
    
    The signature gives a syntactic category $\Lambda_O$, generated by $\lambda_n(S)$ plus the following axiom schema.
    \[\begin{prooftree}
        \hypo{\Gamma \vdash s:\tts}
        \infer1[$(\ttf \in O, \lvert \ttf\rvert = (\tts,\ttB))$]{\Gamma \vdash \ttf(s):\ttB}
    \end{prooftree}\]
\end{definition}

\begin{definition}
    An \define{$n$th-order $S$-sorted presentation} $\Sigma=(O,\lvert -\rvert,E)$ consists of a signature and a set of equations
    \[\begin{array}{c}
        E\subseteq \sum_{(\tts,\ttB)\in \Lambda_n(S)\times S} \Lambda_O(\tts,\ttt)\times \Lambda_O(\tts,\ttt).
    \end{array}\]
    The presentation gives a syntactic category $\Lambda_\Sigma$ generated by the signature plus the following axiom schema.
        \[\begin{prooftree}
        \hypo{\Gamma \vdash u:\tts}
        \infer1[$((\tts,\ttB),(\ttf_1,\ttf_2))\in E$]{\Gamma \vdash \ttf_1(u) = \ttf_2(u):\ttB}
    \end{prooftree}\]
    Finally, we add the inference rules for equality to be an equivalence relation.
\end{definition}

A \define{transliteration} of presentations $f:(O_1,\lvert -\rvert_1,E_1)\to (O_2,\lvert -\rvert_2, E_2)$ is a function of operations $f:O_1\to O_2$ which preserves arities and equations. For order $n$ and sorts $S$, presentations and transliterations form a category $\mrm{Pre}_n(S)$.

\begin{example}
    The second-order theory of the untyped equational $\lambda$-calculus $\T_{\lambda 2}^=$ is presented as follows.
    
    \begin{minipage}{0.2\textwidth}
    \[\begin{array}{rrl}
    \mtt{l}: & [\ttu,\ttu] & \to \ttu\\
    \mtt{a}: & \ttu\times\ttu & \to \ttu
    \end{array}\]
    \end{minipage}
    \begin{minipage}{0.2\textwidth}
    \[\begin{array}{l}
         \mtt{a}(\mtt{l}(\lambda x.t),u) \equiv t[u/x]
    \end{array}\]
    \end{minipage}
\end{example}

\begin{example}
    \textit{Monad comprehension} is a method to construct terms of a monad analogous to set comprehension, introduced by Wadler \cite{WadlerComprehendingMonads}and used in Haskell \cite{HaskellDo},
    Scala \cite{ScalaFor}, and Python \cite{PythonList}.
    
    Monad comprehensions are terms in a second-order theory. Let Th be a first-order algebraic theory of sort $\ttt$, and let $M$ be a monad on $\Set$. The comprehension
    \[\begin{array}{rl}
    \mtt{[expr(x_1, \ldots x_n)~|}&\mtt{x_1 \leftarrow expr_0;}\\
    &\mtt{x_2 \leftarrow expr_1(x_1);}\\
    &\mtt{\cdots}\\
    &\mtt{x_n \leftarrow expr_{n-1}(x_1, \ldots, x_{n-1})]_{n}}
    \end{array}\]
    can be represented as a morphism in a theory MonComp(Th) that augments Th with a sort $\ttC$ and operations for each $n \in \mbb{N}$
    \[\begin{array}{rl}
    \mtt{[-|-]_{n}}:&\ttt^{\ttt^n} \times \ttC \times \ttC^{\ttt} \times \cdots \times \ttC^{\ttt^{n-1}} \to \ttC
    \end{array}\]
    The morphism can be interpreted in a model $F\colon {\rm Th} \to {\rm Set}$ by extending to $F_M\colon {\rm MonComp(Th)} \to {\rm Set}$ such that $F_M(\mtt{C}) = M(F(\ttt))$.  Each $\mtt{x}_i \leftarrow \mtt{expr}_{i-1}(\mtt{x}_1, \ldots, \mtt{x}_{i-1})$ is a morphism in the Kleisli category of $M$, the semicolon is composition, and $\mtt{expr}$ is composed with the monad unit.
    
    We thereby extend the language of Th with collections given by a monad $M$. For example, we can construct lists of stacks to represent memory. Understood as second-order theories, we can generalize monad comprehensions to multisorted, higher order, and more. This is a topic of research in itself.
    
    % As Wadler described, when $M$ factors through a functor into the category of unital magmas, we can think of comprehensions as denoting set-like {\em collections} of elements; for example, lists, sets, trees, multisets, etc.  We can then include extra term constructors in MonComp(Th) like ``[]'' for the empty collection and ``,'' for assembling multiple elements into a collection.
\end{example}

For each presentation $\Sigma$, the syntactic category $\Lambda_\Sigma$ is equipped with a canonical functor $\tau_\Sigma:\Lambda_n(S)\to \Lambda_\Sigma$, which we take to be the categorical definition of an $n$th-order $S$-sorted algebraic theory.

\subsection{The category of higher-order algebraic theories}

We define the category of all higher-order algebraic theories, the domain of the native type theory construction. To do this, we define the category of $n$-$S$ theories and show that this is functorial in $n$ and $S$. We then assemble these into one category, using a tool called the Grothendieck construction.  

The definition of single-sorted algebraic theory, a cartesian identity-on-objects functor $\tau: \mbb{F}^\op = \Lambda_1(1)\to \T$, generalizes to many sorts and higher orders.

\begin{definition}
    An \define{$n$th-order $S$-sorted algebraic theory} or \define{$n$-$S$ theory} $(\T,\tau)$ is a cartesian category $\T$ equipped with a strict cartex identity-on-objects functor $\tau:\Lambda_n(S)\to \T$.
    
    An \define{$n$-$S$ theory morphism} $F:(\T_1,\tau_1)\to (\T_2,\tau_2)$ is a cartex functor $F:\T_1\to \T_2$ such that $F\circ \tau_1 = \tau_2$. Composition is given by pasting commutative triangles.
    
    We denote the category of $n$-$S$ theories by $\mbb{T}_n(S)$.
\end{definition}

\begin{example}
    A theory of arithmetic $\T_{\mtt{Ar}}$ can be presented by $0, \mtt{s}, +,\times$, and the equations for a commutative rig. There is a well-known translation into the $\lambda$-calculus \cite{selingerLambda}:
    \[\begin{array}{lll}
        0 \mapsto & \mtt{l}(\lambda f.\mtt{l}(\lambda x.x)) & : 1\to \ttu\\
        \mtt{s}\mapsto & \mtt{l}(\lambda f.\mtt{l}(\lambda x.\mtt{a}(f,\mtt{a}(\mtt{a}(-,f),x)))) & : \ttu\to \ttu \\
        + \mapsto & \mtt{l}(\lambda f.\mtt{l}(\lambda x.\mtt{a}(\mtt{a}(-,f),\mtt{a}(=,\mtt{a}(f,x))))) & :\ttu^2\to \ttu\\
        \times \mapsto & \mtt{l}(\lambda f.\mtt{a}(-,\mtt{a}(=,f))) & :\ttu^2\to \ttu.
    \end{array}\]
    This is a morphism $F:(\T_{\mtt{Ar}},\tau_\mtt{Ar})\to (\T_{\lambda 2}^=,\tau_{\lambda 2}^=).$
\end{example}

To understand the category of $n$-$S$ theories more concretely, we clarify its relation to presentations.

A transliteration is a map of base operations, but in practice one maps base operations to arbitrary terms. A \define{translation} of presentations $f:(O_1,\lvert -\rvert_1,E_1)\to (O_2,\lvert -\rvert_2, E_2)$ is a function $f:\prod_{o\in O_1} \Lambda_{O_2}(\lvert o\rvert)$ which preserves equations. Presentations and translations form a category \define{$\mrm{Pres}_n(S)$}.
\[\begin{NiceArray}
{@{\;\;}c@{\;\;}l@{}}[code-before =\rowcolor{gray!5}{1} \rowcolor{gray!2}{2-3}
\rowcolor{gray!5}{4}]
    \text{Objects} & \Sigma=(O,\lvert -\rvert,E) \\
    \text{Morphisms} & f:\Sigma_1\to \Sigma_2\\
    & f:\prod_{o\in O_1} \Lambda_{O_2}(\lvert o\rvert)
\end{NiceArray}\]

The functor $\xi: \mrm{Pre}_n(S)\to \mbb{T}_n(S)$ which sends $\Sigma$ to $\Lambda_\Sigma$ has a right adjoint $\upsilon: \mbb{T}_n(S) \to \mrm{Pre}_n(S)$, which sends a theory $\tau:\Lambda_n(S)\to \mrm{T}$ to the signature whose operations are the morphisms of $\T$. This adjunction is monadic: $$\mbb{T}_n(S)\simeq \mrm{Kl}(\upsilon\circ \xi)\simeq \mrm{Pres}_n(S).$$

In \cite{hoat} this fact is proved and used to show that $n$-$S$ theories are a coreflective subcategory of $(n+1)$-$S$ theories: there is an adjunction which adds and removes exponentiable structure, and the unit is an isomorphism.
$$\lceil -\rceil \dashv \lfloor -\rfloor: \mbb{T}_n(S)\simeq \mrm{Pres}_n(S) \lrh \mrm{Pres}_{n+1}(S) \simeq \mbb{T}_{n+1}(S)$$
This implies that $(n+1)$-$S$ theories correspond to a class of monads on $n$-$S$ theories, generalizing the theory-monad correspondence which is central to categorical algebra.

% Given an $(n+1)$-$S$ theory $\tau:\Lambda_{n+1}(S)\to \T$, the explicit formula for the monad $\bar{\tau}:\mbb{T}_n(S)\to \mbb{T}_n(S)$ can be given as
% \[\begin{array}{c}
%     \bar{\tau}(L)(X,Y) \simeq \int^{\Gamma :\Lambda_{n+1}(S)} \lceil L\rceil(1,\Gamma)\times \T(\Gamma,Y^X).
% \end{array}\]

We show that $\mbb{T}$ is functorial in $n$ and $S$. Let $\mrm{CR}$ be the free coreflection: the free 2-category with $l:a\to b$, $r:b\to a$, $\varepsilon:lr\ra 1_b$, $\eta:1_a\simeq rl$ satisfying the triangle identities \cite{freeAdj}. Let $\mrm{CR}_\omega$ be an $\omega$-chain of copies of $\mrm{CR}$ connected end-to-end. We take $[\mrm{CR}_\omega,\Cat]$ to be a category of 2-functors and 2-natural transformations.

\begin{proposition}
    There is a functor
    $$\lambda n.\mbb{T}:\Set \to [\mrm{CR}_\omega,\Cat]$$
    such that $\lambda n.\mbb{T}(S)(n) = \mbb{T}_n(S)$, the category of $n$-$S$ theories.
\end{proposition}

\begin{proof}
    For each set $S$ of base sorts, $\lambda n.\mbb{T}(S):\mrm{CR}_\omega\to \Cat$ gives an $\omega$-chain of coreflective subcategories. $$ \dots \lrh \mbb{T}_n(S) \lrh \mbb{T}_{n+1}(S) \lrh \dots$$
    For each change of base sorts $f:S_1\to S_2$, we define $\lambda n. \mbb{T}(f)(n)$ in terms of presentations
    $$\lambda n.\mbb{T}(f)(n):\mbb{T}_n(S_1)\simeq \mrm{Pres}_n(S_1) \xr{\bar{f}}{} \mrm{Pres}_n(S_2)\simeq \mbb{T}_n(S_2),$$
    given by substitution of base sorts in operations and equations. Then $\lambda n.\mbb{T}(f)$ is a morphism of adjunctions \cite{maclane}: one may check for $\T\in \mbb{T}_n(S_1), \mrm{U}\in \mbb{T}_{n+1}(S_1)$ that
\[\begin{array}{lcl}
    \mbb{T}_{n+1}(f)(\lceil\T\rceil) & = & \lceil \mbb{T}_n(f)(\T)\rceil \\
    \lfloor \mbb{T}_{n+1}(f)(\mrm{U})\rfloor & = & \mbb{T}_n(f)(\lfloor \mrm{U}\rfloor)\\
    \mbb{T}_n(f)(\eta_{S_1}(\T)) & = & \eta_{S_2}(\mbb{T}_{n+1}(f)(\T)),
\end{array}\]
simply because substitution of base sorts commutes with adding and removing exponentiable structure.
\end{proof}%\vspace*{-\baselineskip}

Uncurrying, there is an indexed category
\[\mbb{T}:\Set\times \mrm{CR}_\omega \to \Cat.\]
The image of $\mbb{T}$ assembles into a single category as follows.
% \footnote{$\mbb{T}$ is a 2-functor, but presently it suffices to consider the underlying functor.}

\begin{definition}
    The \define{Grothendieck construction} \cite{mongroth} of an indexed category $F:C^\op\to \Cat$ is a category $C\ltimes F$, defined:
    \[\begin{array}{ll}
        \text{object} & \langle c:C,x: F(c)\rangle \\
        \text{morphism} & \langle f:c\to d, \alpha:F(f)(x)\to y \rangle\\
        \text{composition} & \langle g,\beta\rangle\circ \langle f,\alpha\rangle:= \langle g\circ f,\beta\circ F(g)(\alpha)\rangle
    \end{array}\]
    
    This category is equipped with a \textit{fibration} ($\S$\ref{sec:topos}) over $C$ which projects onto the first coordinate. $$\pi_F:C\ltimes F\to C$$
\end{definition}

\begin{definition}
    The category of higher-order algebraic theories \define{$\HOAT$} is defined to be $(\mrm{CR}_\omega\times \Set) \ltimes \mbb{T}$.

    Hence a \define{higher-order algebraic theory} $\langle (n,S),(\T,\tau)\rangle$ consists of an order $n$, base sorts $S$, and cartesian category with a strict cartex identity-on-objects functor $\tau:\Lambda_n(S)\to \T$.
    
    A \define{theory morphism} $\langle (i,f),F\rangle$ is a relation of orders $i:n_1\to n_2$, a function of base sorts $f:S_1\to S_2$, and a morphism of $n_2$-$S_2$ theories $F:\mbb{T}_i(f)(\T_1,\tau_1)\to (\T_2,\tau_2)$.
    
    Composition of theory morphisms can be inferred from the definition of the Grothendieck construction.
\end{definition}

The category HOAT contains all finite-order simple type theories and all translations between them. Most existing programming languages, data structures, and computing systems can be represented in HOAT.

Finally, we define how theories are instantiated.

\begin{definition}
    For a higher order algebraic theory $\langle (n,S),(\T,\tau)\rangle$ and a cartesian category $\C$, the \define{category of models} is defined to be $\CartEx(\T,\C)$. These assemble into a category of all higher-order models.
\end{definition}

In the present work we focus on native type theory for higher-order algebraic theories, and not yet for models thereof. However, we note that given an $n$-$S$ theory $\tau:\Lambda_n(S)\to \T$, a model $M:\T\to \C$ can be made into a (non-evil notion of) $n$-$S$ theory by taking the bijective-on-objects factor \cite{boff} of the composite $M\circ \tau:\Lambda_n(S)\to \C$.

The category $\HOAT$ is the domain in which to generate native type theories. Prior to the construction, we describe motivating examples of higher-order theories.

\subsection{Application: theories with rewrites}
\label{ssec:rewrites}

One major aspect of computing that higher-order algebraic theories do not explicitly represent is \textit{dynamics}. In practice, function evaluation is not an equation but a \textit{computation}. There are several ways to incorporate dynamics into languages \cite{opsem}; we introduce a new method, which is unusual but beneficial.

Rewrite systems can be modelled by theories that include an internal graph, {\em i.e.} two sorts $\mtt{E}$ for edges and $\mtt{V}$ for vertices, together with two operations $s,t\colon \mtt{E} \to \mtt{V}$ that encode the source and target of each edge.  Such theories construct terms as vertices and rewrites as edges.

Let $\{\tts_i\}_i$ be a family of sorts.  Given an $n$-ary edge constructor and two $n$-ary morphisms into $\mtt{V}$
\[\begin{array}{rl}
    \mtt{r}: & \prod_{i=0}^n \tts_i \to \mtt{E}\\
    \ttf,\ttg: & \prod_{i=0}^n \tts_i \to \mtt{V},
\end{array}\]
we write an abbreviation for the pair of equations
\[\begin{array}{lcccl}
    \mtt{r}(\vec{u}): \ttf(\vec{u}) \leadsto \ttg(\vec{u}) & := &
     s(\mtt{r}(\vec{u})) & = & \ttf(\vec{u})\\
     & \land & t(\mtt{r}(\vec{u})) & = & \ttg(\vec{u}).
\end{array}\]

By adding this structure, we can in fact reconstruct the operational semantics and behavioral equivalence of languages (\ref{ssec:behavior}). Moreover, by representing a rewrite as an operation within a theory, we gain control of its implementation: we can add sorts, operations, and equations which account for resource usage, reduction strategies, and other aspects of computing.

We exemplify reduction strategies: since not all rewrites happen at the top level of a term, a theory may include equations that propagate the reduction context inward.

\subsubsection{$\lambda$-calculus}
\label{lambdacalc}

The second-order theory of the untyped $\lambda$-calculus $\T_{\lambda 2}$ has two sorts: $\ttu$ for terms and $\mtt{E}$ for rewrites.

\begin{example} $\lambda$-calculus
\[\begin{array}{rrl@{\quad\quad}rrl}
    \mtt{a}: &\ttu \times \ttu & \to \ttu & \beta: &[\ttu,\ttu] \times \ttu &\to \mtt{E} \\
    \mtt{l}: &[\ttu,\ttu] &\to \ttu &
    \mtt{r}_{\mtt{a}}: &\mtt{E} \times \ttu & \to \mtt{E}\\
    &&& s,t:&\mtt{E} &\to \ttu
\end{array}\]
\[\begin{array}{rl}
    \beta(\lambda x.t, u): & \mtt{a}(\mtt{l}(\lambda x.t), u) \leadsto t[u/x]\\
    \mtt{r}_{\mtt{a}}(r, u): & \mtt{a}(s(r), u) \leadsto \mtt{a}(t(r), u)
\end{array}\]

The rewrite constructor $\mtt{r}_{\mtt{a}}$ restricts rewrites to the first coordinate, and propagates reduction contexts inward to head position.  This prohibits reductions under an abstraction and on the right side of an application, giving a ``head normal form'' for terminating terms.
\end{example}

\subsubsection{$\uprho$-calculus}
\label{ssec:rho}

The present work originated in an effort to develop logics for concurrent languages. RChain \cite{rchain} is a distributed computing system based on the  $\uprho$-calculus, or \textbf{r}eflective \textbf{h}igher-\textbf{o}rder $\pi$-calculus \cite{rhocal}.

We can model the $\uprho$-calculus\footnote{This theory differs slightly from the original presentation in that we use bound variables rather than semantic substitution \cite[section 2.7]{rhocal}.} as a second-order theory $\T_\uprho$ with two sorts, $\PP$ for processes and $\N$ for names. The sorts act as code and data respectively, and the operations of reference @ and dereference $\ast$ transform one into the other. There is a third sort $\mtt{E}$ for rewrites.\footnote{When the $\uprho$-calculus is in a system which includes parallel processors, instead of $\rfloor,\lfloor$ we can have $-\vert_\mtt{E}-:\mtt{E}^2\to \mtt{E}$ which puts rewrites in parallel.}

Terms are built up from one constant, the null process $\ttz$. The two basic actions of a process are output $\tto$ and input $\tti$, and parallel $-\vert-$ gives binary interaction: these earn their names in the communication rule.  

\begin{example}
$\uprho$-calculus
\[\begin{array}{rll@{\quad\quad}rll}
    \ttz: &1 &\to \PP & -\vert-: & \PP\times\PP & \to \PP \\
    @: & \PP & \to \N &  \mtt{out}: & \N\times\PP & \to \PP\\
    \ast: & \N & \to \PP & \mtt{in}: & \N\times[\N,\PP] & \to \PP\\~\\
    s,t: &\mtt{E} & \to \PP & \mtt{comm}: &\N\times\PP\times [\N,\PP] & \to \mtt{E}\\
    -\rfloor-: & \mtt{E}\times\PP & \to \mtt{E} & -\lfloor-: & \PP \times \mtt{E} & \to \mtt{E}\\
\end{array}\]

\[\begin{array}{rcl}
    \mtt{comm}(n,q,\lambda x.p) & : & \tto(n,q)|\tti(n,\lambda x.p) \leadsto p[@q/x]\\
    (\PP,-|-,\ttz) && \text{commutative monoid}\\
    \end{array}\]
\[\ast\circ @ \equiv 1_\PP\]
\[\begin{array}{rcl}
    r \rfloor p & : & s(r) | p \leadsto t(r) | p \\
    -\rfloor - && \text{commutative monoid action}
\end{array}\]
\[p \lfloor r \;\equiv \; r\rfloor p \; \circ swap_{\PP,\mtt{E}}\]
\end{example}

In the predicate logic of $\pow(\T_\uprho)$ ($\S$\ref{ssec:sub}), a predicate on names $\alpha:\Omega(\N)$ is called a \define{namespace} \cite{namespace}, and a predicate on processes $\varphi:\Omega(\PP)$ is called a \define{codespace}.

In the following sections we derive a native type system from such higher-order algebraic theories with rewrites to reason about the structure and behavior of terms.




\section{The Logic of a Presheaf Topos}
\label{sec:topos}

Topos theory \cite{sheavesinGL} expands the domain of higher-order predicate logic and dependent type theory beyond sets and functions. Most useful is the fact that every category embeds into a topos. For any higher-order algebraic theory, the internal language of its presheaf topos is its native type system.

Let $\T$ be a higher-order algebraic theory. A \define{presheaf} on $\T$ is a functor $A:\T^\op\to \Set$. The category of presheaves is the functor category $[\T^\op,\Set]$, which we denote $\pow(\T)$. This defines a functor to the category CCT of large, (co)complete toposes and (co)continuous logical functors
\[\pow:\HOAT^\op\to \mrm{CCT}\]
by $\pow(\langle (i,f),F\rangle) = -\circ F^\op:\pow(\T_2)\to \pow(\T_1)$.
% We define $\define{Psh}$ to be the essential image.
% \[\begin{NiceArray}
% {@{\;\;}c@{\;\;}l@{}}[code-before =\rowcolor{gray!5}{1} \rowcolor{gray!2}{2}]
%     \text{Objects} & \pow(\T) \text{ for each } $\T\in \HOAT$ \\
%     \text{Morphisms} & \pow(F) = -\circ F^\op:\pow(\T_2)\to \pow(\T_1)
% \end{NiceArray}\]

A presheaf is a context-indexed set of data on the sorts of a theory. The canonical example is a \define{representable} presheaf, of the form $\T(-,\tts)$, which indexes all terms of sort $\tts$. The basic logical objects are to be predicates on representables.

The \define{Yoneda embedding} $y:\T\to \pow(\T)$ is defined
\[\begin{array}{c@{\quad\quad}c}
    y(\tts) = \T(-,\tts) & y(\ttf) = \ttf \circ -.
\end{array}\]
Products and exponentials in $\pow(\T)$ ensure that $y$ is cartex.

A subobject of a presheaf $A$ is a natural indexed injection $\alpha_\tts:\varphi(\tts)\rtail A(\tts)$. Subobjects and commuting triangles form a category; isomorphism classes form the poset $\Sub(A)$.
    
A \define{subobject classifier} in a category with pullbacks $\C$ is an object $\Omega:\C$ equipped with a natural isomorphism \[\mrm{c}:\Omega^{(-)}\simeq \Sub(-).\]
A \define{predicate} in $\C$ is a morphism in $\C$ whose codomain is $\Omega$. In the type system, $\Omega$ is to play the role of the type $\Prop$. The \define{comprehension} of a predicate $\varphi:A\to \Omega$ is the subobject
\begin{eqnarray}
    \mrm{c}(\varphi) \; := \; \{a:A \;|\; \varphi(a)\} \rtail A.
\end{eqnarray}
\textbf{Note.} We may use the predicate and subobject interchangeably, e.g. writing $a:\varphi$ to mean $\varphi(a)$.
%\[\]

A \define{topos} is a cartesian closed category which has finite limits and a subobject classifier. The presheaf category $\pow(\T)$ is a topos: exponents and subobject classifier are defined
\begin{eqnarray}
    Q^P(\tts) & = & \pow(\T)(y(\tts)\times P,Q)\\
    \Omega^{y(\tts)}\simeq \Omega(\tts) & = & \{\varphi\rtail y(\tts)\}.
\end{eqnarray}
    % \[\begin{array}{rcl}
        
        
    % \end{array}\]
In fact $\pow(\T)$ has all limits and colimits, evaluated pointwise.
\[\begin{array}{rcl}
    (\mrm{lim}_i A_i)(\tts) & = & \mrm{lim}_i \; A_i(\tts) \\
    (\mrm{colim}_i A_i)(\tts) & = & \mrm{colim}_i \; A_i(\tts)
\end{array}\]

The values of $\Omega$ can be understood more concretely as
\[\Omega(\tts) \simeq \{\text{sieves of sort } \tts\}.\]
A \define{sieve} of sort $\tts$ is a set of terms of sort $\tts$ that is closed under substitution. A simple example is a \define{principal sieve} generated by a term $\ttf:\tts\to\ttt$.
\begin{eqnarray}
\label{eq:sieve}
    \langle \ttf\rangle:\Omega(\ttt) &&
    \langle \ttf\rangle(\ttr):= \sum_{u:\ttr\to\tts}\ttf\circ u.
\end{eqnarray}

\begin{example}
    The $\uprho$-calculus (\ref{ssec:rho}) is a concurrent language which can express recursive processes without a replication operator, as in the $\pi$-calculus. On a given name $n:1\to \N$, we may define a context which replicates processes as follows.
    \[\begin{array}{ll}
    c(n)& := \tti(n, \lambda x.\{\tto(n,\ast x) \; \vert \ast x \} ) \\
    !(-)_n & := \tto(n,\{c(n)\vert -\}) \; \vert \; c(n).
    \end{array}\]
One can check that $!(p)_n \;\; \leadsto \;\; !(p)_n \; \vert \; p$ for any process $p$.
The sieve $\langle!(-)_n\rangle:\Omega(\PP)$ consists of processes which replicate on the name $n$ by the above method.
\end{example}

For simpler formulae, we introduce some notation. We denote the values of a presheaf by $A_\tts := A(\tts)$, and the action of $u:\ttr\to \tts$ by $-\cdot u:= A(u): A(\tts)\to A(\ttr)$.

For a predicate $\varphi:\Omega^A$, we denote $\varphi_\tts^a := \varphi(\tts)(a)$. More generally for any indexed presheaf $p:P\to A$, we denote $p_\tts^a:=p_\tts^{-1}(a)$ as the \textit{fiber} over $a$ ($\S$\ref{ssec:cod}).

\subsection{The predicate fibration}
\label{ssec:sub}

There is a functor into $\pow(\T)$ called the predicate fibration, where the fiber over each presheaf is the complete Heyting algebra (CHA) of its predicates. We show that quantification gives change-of-base adjoints between fibers; and moreover the domain is cartesian closed, complete and cocomplete. The fibration encapsulates higher-order predicate logic.

We henceforth use $\Omega^A$ to denote the complete Heyting algebra of predicates, rather than the exponential object.

\begin{definition}
    The \define{predicate functor} of $\pow(\T)$ is defined
    \[\Omega^{(-)}:\pow(\T)^\op\to \CHA.\]
    For every $f:A\to B$, precomposition $\Omega^f:\Omega^B\to \Omega^A$ corresponds to preimage $\Sub(f):\Sub(B)\to \Sub(A)$. For any $\psi:\Omega^B$, this can be expressed as substitution
    \begin{eqnarray}
        \Omega^f(\psi)_\tts^a = \psi_\tts^{f_\tts(a)}.
    \end{eqnarray}
    %\[\]
    % The fact that $\Omega^f$ is a morphism in $\CHA$ is known as \textit{Frobenius reciprocity} \cite{sheavesinGL}.
\end{definition}

Substitution gives native type systems \textit{pattern-matching}.

\begin{example}
    For a $\uprho$-calculus process predicate $\varphi:\Omega^{y(\PP)}$, preimage along input $\tti:\N\times [\N,\PP]\to \PP$ is the basic query ``inputting on what name-context pairs yield property $\varphi$?''
    \[\Omega^{y(\tti)}(\varphi)_\tts = \{\tts\vdash (n,\lambda x.p):\N\times [\N,\PP] \;|\; \tti(n,\lambda x.p):\varphi\}\]
\end{example}

The complete Heyting algebra structure of $\Omega^A$ is given: predicates are partially ordered by implication, meet and join are defined by pointwise intersection and union, $\top = A$ and $\bot = \emptyset$, implication is defined
\begin{eqnarray}
    (\varphi\ra \psi)_\tts^a := \prod_{u:\ttr\to\tts} \varphi_\ttr^{a\cdot u}\ra \psi_\ttr^{a\cdot u}
\end{eqnarray}
%\[ \]
and negation is $\neg(\varphi):= (\varphi \ra \bot$).

Hence, $\Omega^{(-)}$ is an indexed category, and we can assemble its image into one category by applying the Grothendieck construction ($\S$\ref{algthy}).

\begin{definition}
The \define{category of predicates} of $\pow(\T)$ is denoted $\Omega\pow(\T)$, and is defined to be $\pow(\T)\ltimes \Omega^{(-)}$.
\arraycolsep=1pt\def\arraystretch{1.4}
\[\begin{NiceArray}
{@{\;\;}c@{\;\;}l@{}}[code-before =\rowcolor{gray!5}{1} \rowcolor{gray!2}{2-3}
\rowcolor{gray!5}{4}]
    \text{Objects} & \langle A \;,\; \varphi:\Omega^A\rangle \\
    \text{Morphisms} & f:\langle A,\varphi\rangle \to \langle B,\psi\rangle\\
    & \langle f:A\to B \;,\; \varphi\ra \Omega^f(\psi)\rangle
\end{NiceArray}\]
It is equipped with a projection called the \define{predicate fibration} \[\pi_\Omega:\Omega\pow(\T)\to \pow(\T),\] so that the fiber over $A$ is $\Omega^A$, and the fiber over $f:A\to B$ is $\Omega^f:\Omega^B\to \Omega^A$, known as a \define{change-of-base functor}.
\end{definition}

Melli\`es and Zeilberger give a syntax for functors to be understood as \textit{type refinement systems} \cite{refine}. Let $p:\D\to \T$ be a functor. We denote $p(\psi)=B$ by $\psi\sqsubset B$, read as ``$\psi$ refines $B$'', and we denote $p(\varphi\xr{\alpha}{} \psi)=(A\xr{f}{} B)$ by $\varphi\xr{\alpha}{f}\psi$; this can be understood as precondition-command-postcondition ($\S$\ref{ssec:connected}).

\begin{definition}
A \define{fibration} is a functor $p:\D\to \T$ with inference rules and axioms
\[\begin{prooftree}
    \hypo{f:A\to B}
    \hypo{\psi\sqsubset B}
    \infer2[$\mrm{L}$]
    {\Omega^f(\psi) \xr{}{f} \psi}
\end{prooftree}
\qquad
\begin{prooftree}
    \hypo{\varphi\xr{}{f\circ g} \psi}
    \infer1[$\mrm{R}$]
    {\varphi\xr{}{g} \Omega^f(\psi)}
\end{prooftree}\]
\[\begin{array}{cc@{\;\;}l}
    \text{for all} & \varphi\xr{\beta}{f\circ g} \psi, & \mrm{L}(f)\circ \mrm{R}(\beta) = \beta\\
    \text{for all} & \varphi\xr{\alpha}{g} \Omega^f(\psi), & \mrm{R}(\mrm{L}(f)\circ \alpha) = \alpha.
\end{array}\]
The projection $\pi_\Omega:\Omega\pow(\T)\to \pow(\T)$ is a fibration: for each $f:A\to B$ and $\psi\sqsubset B$ there is $\mrm{L}(f):\Omega^f(\psi)\to \psi$ which maps the preimage into its image; this morphism is \define{cartesian}, meaning the equations above ensure that derivations of type $\psi$ over $f\circ g$ factor uniquely through $\mrm{L}(f)$.
\end{definition}

In addition, the change-of-base functors have adjoints which generalize existential and universal quantification.

\begin{proposition}
$\pi_\Omega:\Omega\pow(\T)\to \pow(\T)$ is a \define{$\ast$-bifibration} \cite{frbicat}: for each $f:A\to B$, the functor $\Omega^f:\Omega^B\to \Omega^A$ has left and right adjoints $\Sigma_f\dashv \Omega^f\dashv \Pi_f$, defined as follows.
\arraycolsep=1pt\def\arraystretch{1.6}
\begin{eqnarray}
\label{sigma}
    \Sigma_f(\varphi)_\tts^b & := \sum_{a:A_\tts}\sum_{f_\tts(a)=b} \varphi_\tts^{a} \\
\label{pi}
    \Pi_f(\varphi)_\tts^b & := \prod_{u:\ttr\to \tts}\prod_{f_\ttr(a)=b\cdot u} \varphi_\ttr^{a}
\end{eqnarray}
 \end{proposition}

The left adjoint $\Sigma_f$ is called \define{direct image}, because on subobjects it is simply composition by $f$; we call the right adjoint $\Pi_f$ \define{secure image}. While $\Omega^f$ is a morphism of complete Heyting algebras, $\Sigma_f$ and $\Pi_f$ are only morphisms of join and meet semilattices, respectively.

These adjoints are intuited in the case of $\Set$. For $\varphi:2^A$ and $f:A\to B$, the subset $\Sigma_f(\varphi)$ is the image of $\varphi$, and $\Pi_f(\varphi)$ is the subset of elements of $B$ with preimage contained in $\varphi$. Existential and universal quantification are special cases of these adjoints, by taking $f$ to be a projection.

\begin{example}
    Let $\T$ be a theory with rewrites ($\S$\ref{ssec:rewrites}), and suppose $\varphi:\Omega^{y(\mtt{V})}$ is a predicate on terms. Then $\Omega^s(\varphi)$ are the rewrites with source in $\varphi$; and $\Sigma_t(\Omega^s(\varphi))$ are the targets of these rewrites. Hence there are \textit{step operators}:
    \[F_!:=\Sigma_t\Omega^s : \Omega^{y(\mtt{V})}\to \Omega^{y(\mtt{V})} \quad B_!:=\Sigma_s\Omega^t:\Omega^{y(\mtt{V})}\to \Omega^{y(\mtt{V})}\]
    The \textit{secure step-forward} performs a more refined operation: $F_*(\varphi):=\Pi_t(\Omega^s(\varphi))$ are terms $u$ for which $(t\leadsto u)\ra \varphi(t)$. For security protocols, we can filter agents by past behavior.
\end{example}

\begin{proposition}
    The change-of-base adjoints satisfy the \define{Beck--Chevalley condition}: if $\langle a,b\rangle: D \to A\times B$ is a pullback of $A\xr{f}{} C \xleftarrow{g} B$, then there are natural isomorphisms: \[\Omega^g\Sigma_f(\varphi) \simeq \Sigma_b\Omega^a(\varphi)\]
    \[\Omega^g\Pi_f(\varphi) \simeq \Pi_b\Omega^a(\varphi).\]
\end{proposition}

In type theory, the Beck--Chevalley condition means that quantification commutes with substitution. It implies that $\Omega^{(-)}:\pow(\T)\to \CHA$ is a \textit{first-order hyperdoctrine} \cite{hyper}.

\begin{proposition}
    The projection $\pi_\Omega:\Omega\pow(\T)\to \pow(\T)$ is a \define{higher-order fibration} \cite[section 5.3]{jacobs}: a preordered $\ast$-bifibration satisfying the Beck--Chevalley condition, with cartesian closed fibers and a \textit{generic object} $\Omega:\pow(\T)$.
\end{proposition}

This concept leaves implicit additional important structure: in predicate logic, there is implication between predicates on the same set; but more generally, the category of predicates is cartesian closed. Given $\varphi:2^A$ and $\psi:2^B$, we can define
\[[\varphi, \psi](f) := \forall a\in A.\; \varphi(a)\ra \psi(f(a)).\]

\begin{proposition}
    Let $\varphi:\Omega^A$, $\psi:\Omega^B$ in $\pow(\T)$, and let \[\langle\pi_1, \pi_2,ev\rangle:A\times [A,B]\to A\times [A,B]\times B.\] 
    Define the \define{hom predicate} $[\varphi, \psi]:\Omega^{[A,B]}$ to be
    \begin{eqnarray}
    \label{eq:hom}
        [\varphi,\psi]:=\Pi_{\pi_2}(\Omega^{\pi_1}(\varphi)\ra \Omega^{ev}(\psi)).
    \end{eqnarray}
    %\[\]
    % Hence the formula for $[\varphi, \psi](\tts)(z:y(\tts)\times A\to B)$ is:
    % \[[\varphi, \psi]_\tts^z= \prod_{u:\ttr\to\tts} \prod_{a:A_\tts} \varphi_\ttr^{a\cdot u}\ra \psi_\ttr^{z_\ttr(u,a\cdot u)}.\]
    With this structure, $\Omega\pow(\T)$ is cartesian closed, as is $\pi_\Omega$.
\end{proposition}


The above gives maps $(\Omega^A)^\op\times \Omega^B\to \Omega^{[A,B]}$, which assemble into a global closed structure; but there is another way to form hom predicates which is much more fine-grained.

\begin{proposition}
    Let $\msc{L}_{A,B}:[\Omega^A,\Omega^B]\to \Omega^{[A,B]}$ be the canonical morphism given by curried evaluation. There is a right adjoint which we call \define{reification}.
    \[\msf{R}_{A,B}:[\Omega^A,\Omega^B]\to \Omega^{[A,B]}\]
    The predicate $\msf{R}_{A,B}(F)$, denoted $\msf{R}\varphi.F(\varphi)$, determines the maps which ``respect the rule of $F$'':
    \arraycolsep=1pt\def\arraystretch{1.6}
    \begin{eqnarray}
        \msf{R}\varphi.F(\varphi)_\tts^f & = & \prod_{\varphi:\Omega^A} \Sigma_f(y(\tts)\times \varphi)\ra F(\varphi).
    \end{eqnarray}
\end{proposition}

The cartesian closed structure of $\Omega\pow(\T)$ is significant, because this means that $\pi_\Omega^{-1}(y(\T))$ can be understood as a higher-order theory which refines the entire language $\T$.

\textbf{Note.} We emphasize the idea of having ``lifted'' the language by an abuse of notation: for any operation $\ttf:\tts\to \ttt$, we denote $\Sigma_{y(\ttf)}:\Omega^{y(\tts)}\to \Omega^{y(\ttt)}$ simply by $\ttf$, and $\Pi_{y(\ttf)}$ by $\ttf_*$. Similarly, we may write $y(\tts)$ as $\tts$, when the context is clear.

\begin{example}
    Let $\T_{\uprho}$ be the theory of the $\uprho$-calculus ($\S$\ref{ssec:rho}). The operation $\tti:\N\times [\N,\PP]\to \PP$ constructs a process which inputs on a name $n:\N$ and continues as $\lambda x.p:[\N,\PP]$.
    
    Hence for $\alpha,\chi:\Omega(\N)$ and $\varphi:\Omega(\PP)$ there is a \textit{refined input}
    \[\tti_{\alpha,[\chi,\varphi]}:\alpha\times [\chi,\varphi]\to \PP\] which constructs a process that inputs on namespace $\alpha$ and upon receiving a name $n:\chi$ continues as $p[n/x]:\varphi$.
    
    Moreover, this generalizes to ``dependent processes'': given a rule $F:\Omega^\N\to \Omega^\PP$, then
    \[\tti_{\alpha,\msf{R}F}:\alpha\times \msf{R}\varphi.F(\varphi)\to \PP\]
    constructs a process that inputs on namespace $\alpha$ and upon receiving $n:\chi$ continues as $p[n/x]:F(\chi)$.
\end{example}

As a more widely known example of contexts which ensure implications across substitution, we can construct the ``magic wand'' of separation logic \cite{refine}: 
\begin{example}
    Let $\T_h$ be the theory of a commutative monoid $(H,\cup,e)$, with a set of constants $\{h\}:1\to H$ adjoined as the elements of a heap. If we define 
    \[(\varphi \wand \psi) := \Omega^{\lambda x.x\cup-}[\varphi, \psi]\]
    then $h_1:(\varphi \wand \psi)$ asserts that $h_2:\varphi\ra h_1\cup h_2:\psi$.
    
    Using reification as described above, separation logic can be generalized from using pairs of predicates to functions of predicates. We are not aware if this has been studied.
\end{example}
    
In addition, the category of predicates has all limits and colimits, by a result of \cite{burstall}. These can be used to form modalities, inductive and coinductive types, and more.
    
\begin{proposition}
    $\Omega\pow(\T)$ is complete and cocomplete, and $\pi_\Omega$ preserves all limits and colimits. They are computed pointwise; letting $\pi,\iota$ represent the cone and cocone:
    \[\begin{array}{rcl}
        \mrm{lim}_i\langle A_i,\varphi_i\rangle & = & \langle \mrm{lim}_i(A_i),\mrm{lim}_i(\Omega^{\pi_i}\varphi_i)\rangle \\
        \mrm{colim}_i\langle A_i,\varphi_i\rangle & = & \langle \mrm{colim}_i(A_i),\mrm{colim}_i(\Sigma_{\iota_i}\varphi_i)\rangle.
    \end{array}\]
\end{proposition}

\begin{example}
    In the $\uprho$-calculus, we can construct a predicate for \textit{safety and liveness} $\msf{sl}(\alpha)$, which asserts that a process that can always input on namespace $\alpha$ and cannot input on $\neg\alpha$.
    
    There is a functor $SL_\alpha:\Omega^{y(\PP)}\to \Omega^{y(\PP)}$ defined
    \[SL_\alpha(\varphi) = \ttz \lor (\tti(\alpha,[\N,\varphi]) \;|\; \PP)\land \neg(\tti(\neg\alpha,[\N,\PP]) \;|\; \PP).\]
    The free monad $SL_\alpha^\ast$ is constructed as a colimit of iterated composites, and its values are greatest fixed points. Then 
    \[SL_\alpha^*(\emptyset) =: \mu \varphi.SL_\alpha(\varphi) = \msf{sl}(\alpha).\]
\end{example}

\begin{definition}
    A \define{cartesian closed fibration} $F:\D\to \T$ is a fibration which is a morphism of the parameterized adjunction $-\times \varphi \dashv [\varphi,-]$ \cite[Def. 3.12]{enrfib}.
    
    Similarly, the fibration is \define{complete and cocomplete} if it preserves limits and colimits \cite{christinaThesis}.
 \end{definition}
 
To summarize the rich structure present, we allude to a term from category theory: a \textit{cosmos} is a monoidal closed category which is complete and cocomplete \cite{cosmos}.
 
% \begin{definition}
%     A higher-order fibration is \define{cosmic} if it is cartesian closed, complete and cocomplete.
% \end{definition}

\begin{proposition}
The predicate fibration $\pi_\Omega:\Omega\pow(\T)\to \pow(\T)$ is a higher-order fibration which is \define{cosmic}: cartesian closed, complete and cocomplete.
\end{proposition}

\subsection{The codomain fibration}
\label{ssec:cod}

Predicates $\varphi:\Omega^A$ correspond to subobjects $\mrm{c}(\varphi)\rtail A$. While predicates suffice for certain modes of reasoning, it is natural to consider any $p:P\to A$ as a \textit{dependent type}. This expands the fibers over $A$ from truth values to sets, and the fibers over $\pow(\T)$ from posets to categories.

% \begin{example}
%     A graph $\langle s,t\rangle:\mtt{E}\to \mtt{V}^2$ in a theory with rewrites is mapped by the Yoneda embedding to
%     \[\mrm{g_T} := y(\langle s,t\rangle):y(\mtt{E})\to y(\mtt{V})^2,\]
%     the context-indexed set of rewrite graphs of terms. This object can be understood and utilized as a dependent type.
% \end{example}


\begin{definition}
    The \define{slice category} over $A$ is denoted $\pow(\T)/A$. An object is a pair $\langle P,p:P\to A\rangle$, a morphism $h:p\to q$ is a morphism $h:P\to Q$ such that $q\circ h= p$.
\end{definition}

The slice category $\pow(\T)/A$ subsumes the poset $\Sub(A)$, and it has all of the same rich structure.

\begin{proposition}
    $\pow(\T)/A$ is equivalent to a presheaf topos.
    \[\begin{array}{rcl}
         k:\pow(\T)/A &\lrh & \pow(\mrm{el}(A)):l\\
         k(p)(\tts,x) = p_\tts^{-1}(x) & & l(F)_\tts^x = F(\tts,x)
    \end{array}\]
    Here $\mrm{el}(A)$ is the \textit{category of elements}, i.e. the Grothendieck construction of $\iota\circ A:\T^\op\to \Set\to \Cat$. \cite{sheavesinGL}
\end{proposition}

Hence $\pow(\T)/A$ is a complete and cocomplete topos. Given $p:P\to A$, $q:Q\to A$, the hom $[p,q]:[P,Q]\to A$ is given by the same formula as predicates (\ref{eq:hom}). The category has all limits and colimits, evaluated pointwise. Let $\mrm{CCT}$ be the category of complete and cocomplete toposes.
% \[[p, q]_\tts^z= \prod_{u:\ttr\to\tts} \prod_{a:A_\tts} p_\ttr^{a\cdot u}\ra q_\ttr^{z_\ttr(u,a\cdot u)}.\]

\begin{proposition}
    There is a functor $\Delta: \pow(\T)^\op\to \mrm{CCT}$ that maps $A$ to $\pow(\T)/A$ and $f:A\to B$ to pullback.
    \[\Delta^f:\pow(\T)/B\to \pow(\T)/A \qquad \Delta_f(P)_\tts^a = P_\tts^{f_\tts(a)}\]
\end{proposition}

\begin{definition}
The \define{category of dependent types} of $\pow(\T)$ is denoted $\Delta\pow(\T)$, and is defined to be $\pow(\T)\ltimes \Delta$.
\arraycolsep=1pt\def\arraystretch{1.4}
\[\begin{NiceArray}
{@{\;\;}c@{\;\;}l@{}}[code-before =\rowcolor{gray!5}{1} \rowcolor{gray!2}{2-3}
\rowcolor{gray!5}{4}]
    \text{Objects} & \langle A \;,\; p:P\to A\rangle \\
    \text{Morphisms} & f:\langle A,p\rangle \to \langle B,q\rangle\\
    & \langle f:A\to B \;,\; \alpha:p\to \Delta^f(q)\rangle\\
    \text{Composition} & \langle g,\beta\rangle\circ \langle f,\alpha\rangle = \langle g\circ f,\beta\circ\Delta^g(\alpha)\rangle
\end{NiceArray}\]
This is equivalent to the arrow category of $\pow(\T)$.
\end{definition}

The \textbf{codomain fibration} is the projection, which we denote
$\pi_\Delta:\Delta\pow(\T)\to \pow(\T).$ Change-of-base adjoints are given by the same formulae as predicates ($\S$\ref{sigma},$\S$\ref{pi}), and these satisfy the Beck--Chevalley condition.

% \begin{definition}
%     A \define{comprehension category} is a fibration $F:E\to B$ with a functor $H:E\to \Delta B$ which preserves cartesian morphisms, such that $\pi_\Delta\circ h = p$. It is \define{closed} if $H$ is full, the right adjoint of $F$ $1:B\to E$ has a right adjoint $\{-\}:E\to B$
    
%     It is \textbf{cosmic} if it is cartesian closed, complete and cocomplete.
% \end{definition}

\begin{proposition}
The codomain fibration $\pi_\Delta$ is a \textit{closed comprehension category} \cite[Sec 10.5]{jacobs} which is cosmic, i.e. cartesian closed, complete and cocomplete.
\end{proposition}

The two fibrations are connected by a reflection: comprehension interprets a predicate as a dependent type, and factorization takes a dependent type to its image predicate.

\begin{definition}
    The \define{native structure} of a presheaf topos $\pow(\T)$ (or any (co)complete topos), denoted \[\Phi(\pow(\T))=\langle \pi_{\Omega\T},\pi_{\Delta\T},\mrm{i}_\T,\mrm{c}_\T\rangle,\] consists of the predicate and codomain fibrations of $\pow(\T)$, connected by the image-comprehension adjunction.
    \[\begin{tikzcd}
    	{\Omega\pow(\T)} && {\Delta\pow(\T)} \\
    	& {\pow(\T)}
    	\arrow["{\mrm{c}}"{name=0, description}, from=1-1, to=1-3, shift right=3, tail]
    	\arrow["\mrm{i}"{name=1, description}, from=1-3, to=1-1, shift right=3]
    	\arrow["{\pi_\Delta}", from=1-3, to=2-2, shift left=3]
    	\arrow["{\pi_\Omega}"', from=1-1, to=2-2, shift right=3]
    	\arrow["\dashv"{rotate=-90}, from=1, to=0, phantom]
    \end{tikzcd}\]
\end{definition}

This is a \textit{full higher-order dependent type theory with comprehension} \cite[Sec. 11.6]{jacobs} (Fho-DTT), a very rich structure which we do not fully expound here.

There is a category of Fho-DTT structures in which a morphism is a morphism of predicate fibrations and a morphism of type fibrations such that the pair is a morphism of reflections.

% \begin{definition}
%     A \define{Fho-DTT structure} is a pair of fibrations $q:D\to B, p:E\to B$ with a fibered reflection $i\dashv c:D\lrh E$ such that $F:$
%     It is \textbf{cosmic} if the pair of fibrations are cosmic.
% \end{definition}

If moreover these fibrations are cosmic, we demand that the morphisms preserve this structure. We denote by $\mrm{CHDT}$ the category of cosmic FhoDTT-structures.

\begin{theorem}
    The native structure of a (co)complete topos defines a functor $\Phi:\mrm{CCT}\to \mrm{CHDT}$.
\end{theorem}
\begin{proof}
    The functor forms the native structure
    \[\Phi(\msc{E}) := \langle \pi_{\Omega\msc{E}}, \pi_{\Delta\msc{E}}, \mrm{i}_\msc{E}, \mrm{c}_\msc{E}\rangle\]
    and for $f:\msc{E}\to \msc{F}$ in $\mrm{CCT}$, a morphism in CHDT
    \[\Phi(f): \langle \pi_{\Omega\msc{E}}, \pi_{\Delta\msc{E}}, \mrm{i}_{\msc{E}}, \mrm{c}_{\msc{E}}\rangle\to \langle \pi_{\Omega\msc{F}}, \pi_{\Delta\msc{F}}, \mrm{i}_{\msc{F}}, \mrm{c}_{\msc{F}}\rangle  \]
    which is simply pointwise evaluation.
    \[\begin{array}{lcl}
        \Phi(f)_\Omega(\langle A,\varphi\rangle) & = & \langle f(A) \;,\; f(\varphi)\rangle\\
        \Phi(f)_\Delta(\langle A,p\rangle) & = & \langle f(A) \;,\; f(p)\rangle.
    \end{array}\]
    These are continuous and cocontinuous by definition. They are morphisms of fibrations because cartesian morphisms are pullback squares, and morphisms of reflections because $f$ as a logical functor preserves image and comprehension.
    % for any $\langle A,p\rangle:\Delta\pow(\msc{E})$, we have
    % \[\begin{array}{lcll}
    %     \Phi(F)_\Omega(\varepsilon_2) & = & \varepsilon_1(\Phi(F)_\Omega) : & \langle A\circ F,p\circ F\rangle \to \langle A\circ F,\mrm{c}(\mrm{i}(p\circ F))\rangle\\
    %     \Phi(F)_\Delta(\eta_2) & = & \eta_1(\Phi(F)_\Delta) : & \langle A\circ F,p\circ F\rangle \to \langle A\circ F,\mrm{c}(\mrm{i}(p\circ F))\rangle
    % \end{array}\]
\end{proof}

In summary, we have constructed a functor
\[\mrm{Pres}^\op \xr{\Lambda}{} \HOAT^\op\xr{\pow}{} \mrm{CCT} \xr{\Phi}{} \mrm{CHDT}\]
which elucidates a wealth of structure in every language given by a higher-order algebraic theory.
% \footnote{There is also a covariant functor, by taking left adjoint to precomposition for the presheaf construction, but some limit preservation is lost.}



\section{Native Type Theory}
\label{sec:typeth}

We present the \define{native type system} $\Phi(\pow(\T))$ of a higher-order algebraic theory $\T$ given by a presentation $\Sigma$ ($\S$\ref{algthy}).

The system is a \textit{full higher-order dependent type theory} \cite[Sec. 11.5]{jacobs} parameterized by the theory $\T$. We do not present Equality and Quotient types. We encode Subtyping, Hom, and Inductive types, which we use in applications.

The system has two basic entities: \define{predicates} and \define{types}
\[x'A\vdash \varphi(x):\Prop \qquad x'A\vdash B(x):\Type\]
interpreted as $\varphi:A\to \Omega$ and $p:B\to A$, where $\Omega$ is the subobject classifier. Type judgements are reversed because we use preimage for indexing; we leave the second variable implicit. The \define{higher-order axiom} $\Prop:\Type$ enables quantification over predicates of a type.

Substitution is interpreted as pullback: $B[t]:= \Delta^t(p)$. A term $\Gamma\vdash a:A$ is a morphism $a:X\to \Gamma$ together with a section $x:1_X\to A[a]$ in $\pow(\T)/X$. For details see \cite{seelyLCCC}.

For usability, we present the type system as generated from the theory. This way, a programmer can start in the ordinary language, and use the ambient logical structure as needed.

\define{Representables} are given in the type system as axioms, because $y:\T\to \pow(\T)$ preserves products and exponents.
\[\begin{prooftree}
    \hypo{\interp{\tts:\T}}
    \infer1[$\T_S$]{y(\tts):\Type}
\end{prooftree}\quad
\begin{prooftree}
    \hypo{\interp{\tts_1\vdash \ttf:\tts_2}}
    \infer1[$\T_O$]{x'y(\tts_2) \vdash y(\ttf): \Type}
\end{prooftree}\]
\[\begin{prooftree}
    \hypo{\interp{\tts_1 \vdash \ttf = \ttg:\tts_2}}
    \infer1[$\T_E$]{x'y(\tts_2) \vdash y(\ttf) = y(\ttg)}
\end{prooftree}\]

\define{Subobject type} of a predicate. Using comprehension, a predicate is converted to the type of its satisfying terms.
\[\begin{prooftree}
    \hypo{\Gamma,x'A\vdash \varphi:\Prop}
    \infer1[$\mrm{c}_\F$]{\Gamma \vdash \{x'A \;|\; \varphi\}:\Type}
\end{prooftree}\]
\[\begin{prooftree}
    \hypo{\Gamma,x'A\vdash \varphi:\Prop}
    \hypo{\Gamma\vdash M:A}
    \hypo{\Gamma\vdash \varphi[M/x]}
    \infer3[$\mrm{c}_\I$]
    {\Gamma \vdash \msf{i}(M):\{x'A \;|\; \varphi\}}
\end{prooftree}\]
\[\begin{minipage}{0.2 \textwidth}
\begin{prooftree}
    \hypo{\Gamma\vdash N:\{x'A \;|\; \varphi\}}
    \infer1[$\mrm{c}_\E$]
    {\Gamma \vdash \msf{o}(N):A}
\end{prooftree}
\end{minipage}\qquad
\begin{minipage}{0.2 \textwidth}
$\begin{array}{llcl}
    \msf{o}(\msf{i}(M)) & = & M & (\mrm{c}_\beta)\\
    \msf{i}(\msf{o}(N)) & = & N & (\mrm{c}_\eta)
\end{array}$
\end{minipage}\]
\[\begin{prooftree}
    \hypo{\Gamma_1, x'A, \Gamma_2,\varphi \vdash \psi}
    \infer[double]1[$\mrm{c}_\E^\circ$]
    {\Gamma_1, a:\{x'A \;|\; \varphi\}, \Gamma_2[\msf{o}(a)/x] \vdash \psi[\msf{o}(a)/x]}
\end{prooftree}\]
Image type rules, which convert a type to its image predicate, can be derived from $\Sigma$ and Equality.
%For a representable, $\mrm{i}(y(\ttf))$ is the principal sieve ($\S$\ref{sec:topos}).

Because predicates are a reflective subcategory of types, it suffices to give the inference rules for types.

\define{Dependent sum type} is a form of indexed sum, which generalizes product types and existential quantification.
\[\begin{prooftree}
    \hypo{\Gamma\vdash A:\Type}
    \hypo{\Gamma, x'A\vdash B:\Type}
    \infer2[$\Sigma_\F$]
    {\Gamma \vdash \Sigma x'A.B: \Type}
\end{prooftree}\]
\[\begin{prooftree}
    \hypo{\Gamma\vdash a:A}
    \hypo{\Gamma \vdash u: B[a/x]}
    \infer2[$\Sigma_\I$]
    {\Gamma\vdash \langle a,u\rangle :\Sigma x'A.\varphi}
\end{prooftree}\]
\[\begin{prooftree}
    \hypo{\Gamma, z:\Sigma x'A.\varphi\vdash B:\Type}
    \hypo{\Gamma,a'A,u'B\vdash Q:B[\langle a,u\rangle/z]}
    \infer2[$\Sigma_\E$]
    {\Gamma, z :\Sigma x'A.B\vdash (\msf{unpack}\; z \;\msf{as}\; \langle a,u\rangle \; \msf{in}\; Q):B}
\end{prooftree}\]
\[\begin{array}{lcll}
    \msf{unpack}\; \langle M,N\rangle \;\msf{as}\; \langle a,u\rangle \;\msf{in}\; Q & = & Q[M/a,N/u] & (\Sigma_\beta) \\
    \msf{unpack}\; P \;\msf{as}\; \langle a,u\rangle \;\msf{in}\; Q[\langle a,u\rangle/z] & = & Q[P/z] & (\Sigma_\eta)
\end{array}\]
\textbf{Note.} We denote $\Sigma g'y(\ttf).y(\tts)$ as the principal sieve $\langle \ttf\rangle$ (\ref{eq:sieve}) and the ``secure sieve'' $\Pi g'y(\ttf).y(\tts)$ as $\langle \ttf\rangle_*$.

\define{Dependent product type} is a form of indexed product, which generalizes function types and universal quantification.
\[\begin{prooftree}
    \hypo{\Gamma\vdash A: \Type}
    \hypo{\Gamma,x'A\vdash B:\Type}
    \infer2[$\Pi_\F$]
    {\Gamma \vdash \Pi x'A.B: \Type}
\end{prooftree}\]
\[\begin{prooftree}
        \hypo{\Gamma, x'A \vdash t:B}
        \infer1[$\Pi_\I$]
        {\Gamma\vdash \lambda x'A.t :\Pi x'A.B}
\end{prooftree}\]
\[\begin{prooftree}
        \hypo{\Gamma \vdash f:\Pi x'A.B}
        \hypo{\Gamma\vdash u:B}
        \infer2[$\Pi_\E$]
        {\Gamma\vdash f(u) :B[u/x]}
\end{prooftree}\]
\[\begin{array}{lcll}
    (\lambda x'A.t)(a) & = & t(a) & (\Pi_\beta) \\
    f & = & \lambda x'A.f & (\Pi_\eta)
\end{array}\]

We can derive existential $\exists$ from $\Sigma$ and universal $\forall$ from $\Pi$, by image factorization. The rest of predicate logic $\bot,\top,\lor,\land,\ra,\neg$ is also encoded as special cases of $\Sigma$ and $\Pi$.

\define{Subtyping} of predicates is defined
\[(\varphi\leq \psi):= \forall a'A.\; \varphi(a)\ra \psi(a).\]

\define{Inductive type}: for any endofunctor $F:\Omega^A\to \Omega^A$,  the greatest fixed point and least fixed point predicates are defined
\[\begin{array}{lcl}
    \mu \varphi.F(\varphi) & := & \forall \varphi'[A,\Prop].\; (F(\varphi)\leq \varphi)\ra \varphi\\
    \nu \varphi.F(\varphi) & := & \exists \varphi'[A,\Prop].\; (\varphi\leq F(\varphi))\ra \varphi.
\end{array}\]

\define{Hom type} is defined
\[\begin{prooftree}
    \hypo{A_1\vdash B_1:\Type}
    \hypo{A_2\vdash B_2:\Type}
    \infer2[]{[A_1,A_2]\vdash [B_1,B_2]:= \Pi x'A_1.B_1[\pi]\ra B_2[ev]}
\end{prooftree}\]
where $\langle\pi,ev\rangle:A_1\times [A_1,A_2]\to A_1\times A_2$. This encoding represents functions of ``independent types''.

We may also for any $F:[A,\Prop]\to [B,\Prop]$ define the \define{reification type} $\msf{R}\varphi.F(\varphi):[[A,B],\Prop]$ to be the predicate for maps respecting $F$, as given in (\ref{ssec:sub}).
% \[\begin{prooftree}
%     \hypo{\Gamma, \varphi'[A,\Prop]\vdash F:[B,\Prop]}
%     \infer1[$\mrm{R}_\F$]{\Gamma, [A,B]\vdash \mrm{R}(F):\Prop}
% \end{prooftree}\]
% \[\begin{prooftree}
%     \hypo{\Gamma,\varphi'[A,\Prop],x'\varphi\vdash f:F(\varphi)}
%     \infer1[$\mrm{R}_\I$]{\Gamma \vdash f:\mrm{R}(F)}
% \end{prooftree}\]
% \[\begin{prooftree}
%     \hypo{\Gamma \vdash f:\mrm{R}(F)}
%     \hypo{\Gamma\vdash \varphi:[A,\Prop]}
%     \infer2[$\mrm{R}_\E$]{\Gamma x:\varphi\vdash }
% \end{prooftree}\]

\vspace{0.5em}

These types and rules constitute the native type system $\Phi(\pow(\T))$, abridged for a first presentation. By adding rules of functoriality, we can incorporate translations of languages.

\define{Translation} is given by precomposition.
\[\begin{prooftree}
    \hypo{\interp{F:\T_1\to \T_2}}
    \hypo{\Gamma\vdash A:\Type_2}
    \infer2[$F_\msf{Ty}$]{\Gamma(F)\vdash A(F):\Type_1}
\end{prooftree}\]
\[\begin{prooftree}
    \hypo{\interp{F:\T_1\to \T_2}}
    \hypo{\Gamma\vdash a:A}
    \infer2[$F_\msf{Tm}$]{\Gamma(F)\vdash a(F):A(F)}
\end{prooftree}\]

How do we use the system to express simple, useful ideas? Suppose we are working in a language $\T$; we have constructed a program $\ttf:\tts\to \ttt$, and we have a protocol $\mtt{p}:\ttt\to \ttu$ for which we require terms to have been already processed by $\ttf$. We construct the type
\[\begin{prooftree}
    \hypo{y(\ttt)\vdash y(\ttf):\Type}
    \hypo{y(\ttt),y(\ttf)\vdash y(\tts):\Type}
    \infer2[]{y(\ttt)\vdash \langle \ttf\rangle:= \Sigma g'y(\ttf).y(\tts):\Type}
\end{prooftree}\]
for which a term must be derived by the rule
\[\begin{prooftree}
    \hypo{y(\ttt)\vdash \ttg:y(\ttf)}
    \hypo{y(\ttt)\vdash u:y(\tts)[\ttg/x]}
    \infer2[]{y(\ttt)\vdash \langle \ttg,u\rangle:\langle \ttf\rangle.}
\end{prooftree}\]
This type determines terms of the form $\ttg=\ttf(u)$ for some $u:\mtt{R}\to \tts$. We can then refine the protocol
\[y(\p)_\ttf:=\Sigma q'y(\p).\langle \ttf\rangle.y(\tts) = \langle\p\circ \ttf\rangle\] 
to enforce the requirement.



\section{Applications}
\label{sec:apply}

Native type systems are highly expressive and versatile.  We demonstrate examples to indicate only a few possibilities.

\subsection{Behavior and Modalities}
\label{ssec:behavior}

Because native type theory is based on term constructors, it may seem to be only good for reasoning about term structure; but simply by including a graph of rewrites internal to the language, we can reason effectively about behavior.

Let $\T$ be a higher-order algebraic theory with rewriting ($\S$\ref{ssec:rewrites}). The graph of rewrites over terms is a dependent type. The fiber over each pair is the set of rewrites between terms.
\[\begin{array}{lcl}
    \mrm{g} & := & y(\langle s,t\rangle): y(\mtt{E})\to y(\mtt{V}^2)\\
    \mrm{g}_\tts^{(v_1,v_2)} & = & \{e \;|\; \tts\vdash e:v_1 \leadsto v_2\}
\end{array}\]
This object is the space of all computations in language $\T$. The native type system can utilize it in many ways.

We can filter subgraphs of computations using predicates.
\begin{example}
    Consider the $\uprho$-calculus ($\S$\ref{ssec:rho}) predicate
    \[\mtt{comm}(\alpha,\psi,\msf{R}\chi.F(\chi)):[\mtt{E},\Prop]\]
    determines the communications in namespace $\alpha$, sending data in codespace $\psi$, and continuing in contexts $\lambda x.c:[\N,\PP]$ such that $n:\chi\ra c[n/x]:F(\chi)$ for some rule $F$. Then 
    \[\Sigma r'\mtt{comm}(\alpha,\psi,\msf{R}\chi.F(\chi)).\mrm{g}\]
    is the type of those computations.
\end{example}

We can express \textit{temporal modalities} to reason about past and future behavior. We defined step-forward and backward operators $\msf{F}_!,\msf{B}_!$ and ``secure-step'' operators $\msf{F}_*,\msf{B}_*$, using $\Sigma$ and $\Pi$ types of $s,t:\mtt{E}\to \mtt{V}$ ($\S$\ref{sec:topos}).

For a predicate $\varphi:[\mtt{V},\Prop]$ on terms, $\msf{B}_!(\varphi)$ are terms which \textit{possibly} rewrite to $\varphi$, and $\msf{B}_*(\varphi)$ are terms which \textit{necessarily} rewrite to $\varphi$. By iterating, we can form each kind of modality.
\[\begin{array}{ll@{\qquad}l}
    \msf{B}_!^\circ(\varphi) := & \exists n'\mbb{N}.\msf{B}_!^n(\varphi) & \text{can become } \varphi\\
    \msf{B}_*^\circ(\varphi) := & \exists n'\mbb{N}.\msf{B}_*^n(\varphi) & \text{will become } \varphi\\
    \msf{B}_!^\bullet(\varphi) := & \forall n'\mbb{N}.\msf{B}_!^n(\varphi) & \text{always can become } \varphi\\
    \msf{B}_*^\bullet(\varphi) := & \forall n'\mbb{N}.\msf{B}_*^n(\varphi) & \text{always will become } \varphi
\end{array}\]
and similarly for $\msf{F}$, to condition past behavior. Moreover, these operators and modalities can be restricted to subgraphs.

\begin{example}
    We can use the always modality to express constant system requirements, such as the capacity to receive and process input on certain channels, or the guarantee to only communicate on certain channels.
    \[\begin{array}{lcr}
        \msf{live}(\alpha) & := & \msf{B}_*^\bullet(\tti(\alpha,[\N,\PP]) \;|\; \PP))\\
        \msf{safe}(\alpha) & := & \msf{B}_*^\bullet(\neg(\tti(\neg\alpha,[\N,\PP]) \;|\; \PP))\\
        \msf{sl}(\alpha) & := & \msf{safe}(\alpha)\land \msf{live}(\alpha)
    \end{array}\]
In constructing a proof such as $\tti(\n,\ttx.\p):\tti(\N,\msf{R}\chi.\msf{sl}(\chi))$, we ensure that the program will maintain liveness and safety on the name it receives.
%The behavior of the process is controlled and understood.
\end{example}

In operational semantics, rewrites are ``silent reductions'' which can occur inside a closed system, while more generally \textit{transitions} allow for interaction with the environment. This can be expressed using substitution as pattern-matching.
\begin{example}
    Processes in the $\uprho$-calculus interact by parallel composition $-|-$. The basic actions are input and output. We can construct the labelled transition system of these observable behaviors and derive behavioral equivalences.
    
    First, we define the interaction contexts
    \[\msf{obs}:= [\lambda x.x]\lor [ \lambda x.(\tti\;|\; x)]\lor [ \lambda x.(\tto \;|\; x)]:[[\PP,\PP],\Prop]\]
    We then define labelled transition system as
    \[p'\PP,c'[\PP,\PP],q'\PP\vdash \msf{e}:=\mrm{g}[ev[p,\msf{obs}(c)],q]:[\PP\times[\PP,\PP]\times\PP,\Prop]\]
    the predicate which is written in operational semantics as
    \[\msf{e}(p,c,q) \quad :: \quad p\xr{c}{} q.\]
    We can now additionally define new modalities relative to this observational graph, denoted with $(-)_\msf{e}$.
    
    From this relation, many kinds of behavioral equivalence can be written explicitly as types. For example, bisimulation is the inductive type $\msf{Bisim}:=\mu \varphi.\msf{S}(\varphi)$ for
    \[\begin{array}{l}
        \msf{S}(\varphi)(p,q) :=\\
        \forall y'\PP.\; \forall c'[\PP,\PP].\; \msf{e}(p,c,y)
        \ra \exists z'\PP.\; \msf{e}(q,c,z) \land \varphi(y,z) \; \land \\
        \forall z'\PP.\; \forall c'[\PP,\PP].\; \msf{e}(q,c,z)
        \ra \exists y'\PP.\; \msf{e}(p,c,y) \land \varphi(y,z)
    \end{array}\]
    This type is very useful; e.g. by quotienting, we can reason up to bisimilarity.
    
    In this way the computation graph, combined with pattern-matching and predicate logic, suffice to reconstruct many aspects of operational semantics. Moreover, the fact that this is done ``natively'' means that the \textit{behavioral types} can interact fruitfully with \textit{structural types}.
\end{example}

\subsection{Internal Hom and Semantic Search}
\label{ssec:hom}

A common question in software is ``what contexts ensure this implication?'' For example, ``where can this protocol be executed without security leaks?'' Hom types provide this expressive power for reasoning contextually in codebases.

The hom predicate $[\varphi_1,\varphi_2]$
determines contexts $\lambda x.c:[A_1,A_2]$ so that substituting $t:\varphi_1$ yields $c[t/x]:\varphi_2$. This is highly expressive, especially when combined with behavior.

First, it allows for restricted binding.
\[\tti(n,\lambda x'\alpha.p)\]
This is a query which only accepts data from namespace $\alpha$; this could be a space of trusted addresses, a data type, or the set of programs which satisfy certain constraints.

Using native types, a code search engine can query by pre- or post-condition, using ``arrow types'' defined by composing modalities with the hom type.
\[\varphi \rhd \psi := [\varphi,\msf{B}^\circ_*(\psi)]\]
These are contexts for which substituting $\varphi$ could \textit{eventually} lead to some condition, desired or otherwise.

\begin{example}
    An arrow can be used to detect security leaks: given a trusted channel $a:\N$ and an untrusted $n:\N$, then the following program will not preserve safety on $a$.
    \[(- \;|\; \tto(a,\tti(n,\lambda x.p))): \msf{sl}(a)\rhd \neg\msf{sl}(a)\]
    Or it can detect if a program may not remain single-threaded:
    \[\begin{array}{c}
        \msf{s.thr}:= \neg \ttz\land \neg(\neg \ttz \;|\; \neg\ttz)\\
        \tti(@(-),\lambda x.(p \;|\; q)) : \msf{s.thr}\rhd_\msf{e} \neg\msf{s.thr}.
    \end{array}\]
    where $\rhd_\msf{e}$ is the arrow relative to the observational graph.
    
    We can search for problems before they occur, without knowing the source of bugs; the query time depends only on the system complexity and the efficiency of the type-checker.
\end{example}

Requiring preconditions on program input, using restricted binding, increases control and facilitates reasoning; in particular we can preserve and create system properties. With subtyping, we can reason about collections of programs.

\begin{example}
    Different kinds of programs preserve safety:
    \[\begin{array}{lcl}
        (- \;|\; \tto(\alpha,\msf{safe}(\alpha))) & \leq & [\msf{safe}(\alpha),\msf{safe}(\alpha)]\\
        \tti(a,\lambda x'\alpha.(\msf{sl}(x) \;|\; -)) & \leq & [\msf{safe}(\alpha),\msf{safe}(\alpha)].
    \end{array}\]
    
    Liveness can be reified ($\ref{sec:typeth}$) as the predicate $\msf{R}\varphi.\msf{live}(\varphi):[[\N,\PP],\Prop]$, which determines programs which remain live on the name they receive. The replication operator (\ref{eq:sieve}) can create liveness on any name:
    \[ \lambda a.(-)!_{a}:[\PP, \msf{R}\alpha.\msf{live}(\alpha)].\]

    Another example is a program which forms storage cells, with recursion and sum encoded in the $\uprho$-calculus \cite{rhocal}:
    \[\begin{array}{c}
        \msf{cell}(a,v):= \tto(a,v) + \tti(a, \lambda x.\msf{cell}(a,x))
    \end{array}\]
    then $\lambda a.\msf{cell}(a,-):[\PP,\msf{R}\alpha.\msf{live}(\alpha)].$
\end{example}
    

These kind of predicates in the $\uprho$-calculus have been studied for object capabilities \cite{ocaps}, advocating for better security by determining authority purely through object references.

\begin{example}
    A key concept in concurrency is that of a \textit{race condition}, in which multiple communications on one channel are possible simultaneously.
    \[\begin{array}{ll}
        \msf{race.in} & := \exists n:\N.\; \tto(n,\PP)\;|\;\tto(n,\PP)\;|\;\tti(n,\N.\PP)\;|\;\PP\\
        \msf{race.out} & := \exists n:\N.\; \tti(n,\N.\PP)\;|\;\tti(n,\N.\PP)\;|\;\tto(n,\PP) \;|\; \PP
    \end{array}\]
    Then we can design algorithms which identify and manage these conditions. Let $\mtt{comm}_n:= \lambda x. s(\mtt{comm}(n,\PP,\N.\PP))\;|\; x$, the contexts with potential communication on $n$.
    \[\begin{array}{lcl}
        \mtt{comm}_n & \leq & [\tto(n,\PP),\msf{race.in}]\\
        \mtt{comm}_n & \leq & [\tti(n,\N.\PP),\msf{race.out}]
    \end{array}\]
    One can then use this in inferences:
    \[\begin{array}{lcl}
         (\mtt{comm}_n \;|\; \tto(n,\PP)) & \leq & \msf{race.in}\\
         (\msf{s.thr} \;|\; \msf{s.thr}) & \leq & \neg\msf{race.out}.
    \end{array}\]
    This is useful especially in applications such as blockchain.
\end{example}

% The RV-Match software, built on K Framework's operational semantics for C, essentially tries to unify programs with the type of ``underspecified C program'' \cite{RV-Match}.  A successful unification indicates a bug in the software like a buffer overflow or an out-of-lifetime access.

\subsection{Sublanguages and Resources}
\label{ssec:sublang}

Languages have many useful ``sublanguages'' consisting of terms that satisfy certain properties. For example, the linear $\lambda$-calculus consists of terms which use each variable exactly once, such as the pairing combinator $\lambda xyz.zxy$.

\begin{example}
    In any higher-order algebraic theory $\T$, we can specify the ``linear sublanguage'' $\msf{linear}(\T)$ by restricting to terms which do not copy or delete variables, simply by excluding $\Delta_\tts:\tts\to \tts^2$ and $!_\tts:\tts\to 1$:
    \[\begin{array}{lcll}
        \msf{linear}(\T)(\tts) & := &  \forall f'\tts^2 \to \tts. & \neg(f \langle\Delta_\tts\rangle_*)\\
        & \land & \forall x'1\to \tts. & \neg(x\langle!_\tts\rangle_*).
    \end{array}\]
\end{example}

In general, typing rules which restrict terms by certain ``well-formed'' conditions can define a predicate that determines the sublanguage of such terms.

For example, starting from a set of terminating constants, the inference rules of the simply-typed $\lambda$-calculus pick out a certain subset of $\lambda$ terms which terminate.

Abramsky's ``proofs as processes'' does the same for a concurrent process calculus \cite{ProofAsProcess}; and Baillot and Terui describe a $\lambda$-calculus whose terms halt in polynomial time \cite{BaillotTerui}.

Hence, native types serve to reason about sublanguages for practical issues such as resource usage and complexity.

\subsection{Translations and Composite Systems}
\label{ssec:composite}

Strong type systems, when they exist, are usually restricted to reasoning about the language in isolation. But the reality of modern computing is that programs usually execute in an embedded, networked environment.

The native types construction is functorial, allowing us to reason across translations. By modelling composite systems as theories, we have complete specification of their interaction.

\begin{example}[Translations]
The $\lambda$-calculus embeds into the $\pi$-calculus \cite{pical}, and the $\pi$-calculus embeds into the $\uprho$-calculus \cite{rhocal}. In effect, the translation interprets the $\lambda$-calculus as a computer, and places it on one name, or node in a network.

Such a translation can act as a ``foreign function interface'' enabling the $\uprho$-calculus to ``call out'' to $\lambda$-calculus to avoid nondeterministic or nonconfluent behavior.  The refinements of $\lambda$-calculus code can be translated directly to refinements of $\uprho$-calculus processes for use by the $\uprho$ type checker.
\end{example}

\begin{example}[Composite Systems]

% Simple systems, when allowed to interact, often exhibit surprising synergy.  Consider the following toy example: there is a theory Th(List) with two sorts $\mtt{B}$ and $\mtt{L}$ and two function symbols $[\colon 1 \to \mtt{B}$ and $]\colon \mtt{B} \to \mtt{L}$.  The theory of a list, by itself, has only one term of sort $\mtt{L}$, [].  There is a second theory Th($\mathbb{N}$) of natural numbers; it has a sort $N$ and two functions symbols $z\colon 1\to N$ and $s\colon N\to N.$  The native type theory on natural numbers has some interesting refinements of $N$, like a type for evens and a type for primes.  But if we take the sum of the theories Th($\mathbb{N}$) + Th(List) and add a ``comma'' function symbol $,\colon \mtt{B} \times N \to \mtt{B}$, the resulting theory has infinitely many terms of sort $\mtt{L}$, one for each list of natural numbers.  For example, 
% $$[,2,3,5,7,11,13,17]\colon 1\to \mtt{L}.$$
% Refinements of $\mtt{L}$ allow the consideration of multiplicity and order of the natural numbers a list contains.  Since the set of finite lists of natural numbers is countable, there is a G\"odel-like encoding of such lists into the natural numbers.  We could work with types over that encoding, but the native type system generated by the theory is much more pleasant to work with.

% In a similar way, 
Software developers often combine systems, each with its own operational semantics, and add interaction terms. The composite can exhibit many emergent properties that require formal reasoning.

JavaScript is a single-threaded language, but it often runs in an asynchronous environment. Browsers and servers use the ``communicating event loop model'' \cite{CEL},
%: the initial JavaScript program sets up event handlers and terminates, asynchronous events get pushed onto a queue as they occur, and an ``event loop'' polls the queue, popping off events and invoking the relevant handlers synchronously. 
but no existing JavaScript type system models the interaction between different communicating event loops; they restrict themselves to what can be expressed solely in the language itself.

We can take the $\lambda$-calculus as a fragment of JavaScript and the $\uprho$-calculus as a model of the network, and derive a native type system  for the combined system: we form the sum of $\T_{\lambda2}$ and $\T_\uprho$ (\ref{ssec:rewrites}), and identify sorts $\mtt{U}$ and $\mtt{P}$.
% Some processes do not do anything: $\mathtt{a}(\mathtt{out}(@0, 0), \mathtt{l}(x.x))$ does not reduce because it does not match the left-hand side of any rewrite.  But there is a refinement of $\mtt{P}=\mtt{U}$ that picks out those terms that are structured as communicating event loops written in $\uprho$ that invoke event handlers written in $\lambda$ that return data structures consisting of lists of outgoing messages to the event loop to dispatch.  Further refinements pick out terms that are deadlock-free, that do not leak secrets, that involve rely-guarantee modalities, or any number of other interesting properties.

Let $\msf{event}$ be a data type of events, encoded as a namespace. Let $n:\N$ and $[\varphi,\psi]_t$ be any subtype of $[\varphi,\psi]$ consisting of provably terminating $\lambda$ terms.  Then 
$$\mu \varphi.\mtt{in}(n, \lambda e:\msf{event}.(\mtt{a}([\msf{event}, (\tto(\N, \PP) \;|\; \varphi)]_t,\, e)))$$
is the type of process guaranteed to be live by the type checker: it can always receive events on $q$ and handle them using a terminating $\lambda$ term, resulting in output messages and a new live process listening on $q$.
\end{example}

We have presented only a handful of first sketches, which hardly scratch the surface of native type theory. Native types are practical because they are basic: they are made by logic from the languages we already use. We encourage the reader to explore what native types can do for you.



\section{Conclusion}
Native type theory is a functorial way to generate expressive type systems for a broad class of languages. We have presented the construction and proposed directions for application.

The authors believe that integrating native type systems in software is a viable way to provide a shared framework of higher-order reasoning in everyday computing. Most of the tools necessary for implementation already exist.


%% SAVE FOR ACTUAL SUBMISSION

\section*{Acknowledgments}
The authors thank John Baez, Greg Meredith, Paul-Andr{\'{e}} Melli{\`{e}}s, Noam Zeilberger, Mike Shulman, Marcelo Fiore, Sam Staton, Nathanael Arkor, Joseph Denman, Xiaohong Chen, Stelios Tsampas, Joshua Meyers, and Alysha Toomey for many helpful conversations.
%\subfile{6_appen.tex}

\bibliographystyle{IEEEtran}
\bibliography{stthol.bib}

\end{document}


