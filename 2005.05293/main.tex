\documentclass[submission,copyright,creativecommons,sharealike,noncommercial]{eptcs}
\providecommand{\event}{ACT 2020}
\pdfoutput=1

\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsthm,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{url}
%\usepackage{hyperref}
\usepackage{mathtools, nccmath}
\usepackage[font={sf}]{caption}
\usepackage{tikz}
\usepackage{tikzit}
\usepackage{fontawesome}
\usepackage{stmaryrd}
\usepackage{physics}

%%%-------Tikz Options-------%
\input{tikzstyles}
\input{styles.tikzstyles}
\usetikzlibrary{calc, positioning, shapes.geometric}
\usetikzlibrary{
	arrows,
	shapes,
	decorations,
	intersections,
	backgrounds,
	positioning,
	circuits.ee.IEC
	}


\newcommand{\tikzfigscale}[2]{\scalebox{#1}{\tikzfig{#2}}}


%%----------Maths Characters---------%%
\newcommand{\cat}{\mathbf}
\newcommand{\morph}[1]{\xrightarrow{#1}}
\newcommand{\id}[1]{\textrm{id}_{#1}}
\newcommand{\ob}[1]{\textrm{Ob}(#1)}
\newcommand{\fhilb}{\textbf{FHilb}}
\newcommand{\frel}{\textbf{FRel}}
\newcommand{\fset}{\textbf{FSet}}
\newcommand{\cpm}[1]{\mathbf{CPM}(#1)}
\newcommand{\spl}[1]{\mathbf{Split}(#1)}


\newcommand{\overbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}
%\newcommand{\cor}{\textrm{cor}}
%\newcommand{\cor}{\operatorname{\text{\faChain}}}
\newcommand{\cor}{\operatorname{\rotatebox[origin=c]{90}{\text{\faRandom}}}}
\newcommand{\putt}[1]{\mathbin{\uparrow_{#1}}}
\newcommand{\get}[1]{\operatorname{\text{\faEye}}_{#1}}
\newcommand{\mix}[1]{\sim_{#1}}
\newcommand{\copyy}[1]{
\mathbin{\begin{tikzpicture}
		\node [style={black_dot}, scale=0.6] (0) at (0, 0) {};
		\node [style=none] (1) at (0, -0.2) {};
		\node [style=none] (2) at (-0.2, 0.2) {};
		\node [style=none] (3) at (0.2, 0.2) {};
		\draw (1.center) to (0);
		\draw [in=-90, out=150] (0) to (2.center);
		\draw [in=270, out=30] (0) to (3.center);
\end{tikzpicture}}_{\hspace{-0.05cm}#1}}

\newcommand{\unit}[1]{
\mathbin{\begin{tikzpicture}
	\begin{pgfonlayer}{nodelayer}
		\node [style={black_dot}, scale=0.6] (0) at (0, 0) {};
		\node [style=none] (1) at (0, 0.2) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw (1.center) to (0);
	\end{pgfonlayer}
\end{tikzpicture}}_{\hspace{-0.05cm}#1}}


\newcommand{\deco}[1]{
\mathbin{\begin{tikzpicture}
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (1) at (-0.3, 0.2) {};
		\node [style=none] (2) at (-0.3, -0.2) {};
		\node [style=none] (3) at (0.2, -0.2) {};
		\node [style={black_dot}, scale=0.6] (4) at (-0.3, 0) {};
		\node [style=none] (5) at (0.2, 0.2) {};
		\node [style={black_dot}, scale=0.6] (6) at (0.2, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw (2.center) to (1.center);
		\draw (5.center) to (3.center);
		\draw (4) to (6);
	\end{pgfonlayer}
\end{tikzpicture}}_{\hspace{-0.05cm}#1}}


\newcommand{\frob}[1]{
\mathbin{\begin{tikzpicture}
	\begin{pgfonlayer}{nodelayer}
		\node [style={black_dot}, scale=0.6] (0) at (0, 0) {};
		\node [style=none] (1) at (0, 0.2) {};
		\node [style=none] (2) at (-0.2, -0.2) {};
		\node [style=none] (3) at (0.2, -0.2) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw (1.center) to (0);
		\draw [in=90, out=-150] (0) to (2.center);
		\draw [in=-270, out=-30] (0) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}}_{\hspace{-0.05cm}#1}}

\newcommand{\wmult}{
\mathbin{\begin{tikzpicture}[rotate=180]
		\node [style={white_dot}, scale=0.6] (0) at (0, 0) {};
		\node [style=none] (1) at (0, -0.2) {};
		\node [style=none] (2) at (-0.2, 0.2) {};
		\node [style=none] (3) at (0.2, 0.2) {};
		\draw (1.center) to (0);
		\draw [in=-90, out=150] (0) to (2.center);
		\draw [in=270, out=30] (0) to (3.center);
\end{tikzpicture}}}

\newcommand{\wcomult}{
\mathbin{\begin{tikzpicture}
		\node [style={white_dot}, scale=0.6] (0) at (0, 0) {};
		\node [style=none] (1) at (0, -0.2) {};
		\node [style=none] (2) at (-0.2, 0.2) {};
		\node [style=none] (3) at (0.2, 0.2) {};
		\draw (1.center) to (0);
		\draw [in=-90, out=150] (0) to (2.center);
		\draw [in=270, out=30] (0) to (3.center);
\end{tikzpicture}}}

\newcommand{\banana}{\raisebox{-0.2cm}{\includegraphics[scale=0.03]{figs/banana}}}
\newcommand{\smallbanana}{\raisebox{-0.01cm}{\includegraphics[scale=0.013]{figs/banana}}}
\newcommand{\monkey}{\raisebox{-0.1cm}{\includegraphics[scale=0.05]{figs/monkey}}}
\newcommand{\smallmonkey}{\raisebox{-0.01cm}{\includegraphics[scale=0.03]{figs/monkey}}}
\newcommand{\smiley}{\raisebox{-0.15cm}{\includegraphics[scale=0.03]{figs/smile}}}
\newcommand{\smallsmiley}{\raisebox{-0.01cm}{\includegraphics[scale=0.013]{figs/smile}}}

%%-----------Theorems-------------%%
\theoremstyle{definition}
\newtheorem{defn}{Definition}
\theoremstyle{plain}
\newtheorem{prop}{Proposition}
\theoremstyle{plain}
\newtheorem{corr}{Corollary}

\begin{document}
\title{The Safari of Update Structures: Visiting the Lens and Quantum Enclosures}

\author{Matthew Wilson \institute{University of Oxford} \institute{HKU-Oxford Joint Laboratory for \\ Quantum Information and Computation \email{matthew.wilson@cs.ox.ac.uk}} \and
James Hefford \institute{University of Oxford} \email{james.hefford@cs.ox.ac.uk} \and Guillaume Boisseau \institute{University of Oxford} \email{guillaume.boisseau@cs.ox.ac.uk} \and 
Vincent Wang  \institute{University of Oxford} \email{vincent.wang@cs.ox.ac.uk}}

\def\titlerunning{The Safari of Update Structures}
\def\authorrunning{M. Wilson, J. Hefford, G. Boisseau and V. Wang}

\maketitle

\begin{abstract}
    We build upon our recently introduced concept of an update structure to show that they are a generalisation of very-well-behaved lenses, that is, there is a bijection between a strict subset of update structures and vwb lenses in cartesian categories. We then begin to investigate the zoo of possible update structures. We show that update structures survive decoherence and are sufficiently general to capture quantum observables, pinpointing the additional assumptions required to make the two coincide. In doing so, we shift the focus from $\dag$-special commutative Frobenius algebras to interacting (co)magma (co)module pairs, showing that the algebraic properties of the (co)multiplication arise from the module-comodule interaction, rather than direct assumptions about the magma-comagma pair. Thus this work is of foundational interest as update structures form a strictly more general class of algebraic objects, the taming of which promises to illuminate novel relationships between separately studied mathematical structures.
\end{abstract}

\section{Introduction}
Modelling meaning updating within natural language processing is an ongoing foundational problem. Inspired by an operational interpretation, we recently introduced the concept of an \textit{update structure} \cite{hefford2020categories} as a candidate for modelling meaning updating in monoidal categories, with the intention of possible applications within DisCoCat \cite{coecke_mathematics_2019, coecke_mathematical_meaning,coecke2020meaning}.

At its core, an update structure is a ``weak'' module-comodule pair, that is a pair of an action and coaction on a magma-comagma, without the stricter underlying assumption of a monoid-comonoid pair\footnote{that is, associativity and a unit, and often speciality and the Frobenius law, etc.}. An update structure also comes with two extra axioms which capture clear operational notions constraining how the magma and comagma should interact.

Particular cases of module-comodule pairs have been considered elsewhere; they make an appearance in both categorical quantum mechanics where they have been shown to capture quantum observables and measurements \cite{coecke_measurements, heunen2019categories} and in work on lenses \cite{bancilhon_update_1981,foster_combinators_nodate} in relation to the view-update problem. In this paper we offer a unifying perspective of these two fields from the vantage point of update structures. To this end, the purpose of the remainder of this article is twofold: to pinpoint precisely when lenses and update structures coincide and to demonstrate that update structures are sufficient to capture quantum observables and measurements. For the former, we demonstrate that update structures are more general than vwb lenses, capturing both demolition and non-demolition viewing (Get) processes and with regards to the latter, we demonstrate both that the application of decoherence to any update structure will produce a new update structure on classical objects and that to characterise quantum observables it is sufficient to look at how the weak module-comodule interact without underlying assumptions on the magma-comagma. This is contrary to the usual approach where one typically begins with a module-comodule over a $\dag$-Frobenius structure as their underlying assumptions. Thus the focus is shifted from demands on both how the module and comodule interact \textit{and} the algebraic structure of the (co)magma, to demands placed purely on the module-comodule interaction. This places quantum observables and vwb lenses within a zoo of update structures with many other exotic enclosures left to explore, an example of which we give in the last section.

We finish this introduction by recalling several definitions from \cite{hefford2020categories}.
\begin{defn}[(Strong) Update Structure]
An update structure $(\putt{},\get{},\mix{},\copyy{})$ in a monoidal category $\cat{C}$ consists of:
\begin{itemize}
    \item An object $S$, which we refer to as a \textbf{system}
    \item An object $p$, which we refer to as a \textbf{property}, which has:
    \begin{itemize}
    \item A magma structure $\mix{}: p \otimes p \rightarrow p$
    \item A comagma structure $\copyy{}: p \rightarrow p \otimes p$
    \end{itemize}
    \item A \textbf{Put} operation $\putt{}: S \otimes p \rightarrow S$
    \item A \textbf{Get} operation $\get{}: S \rightarrow S \otimes p$
\end{itemize}
Which satisfy the following equations:

\begin{equation}\label{putputgetget}
\arraycolsep=1.5cm
\begin{array}{cc}
    \textrm{PutPut} & \textrm{GetGet} \\
    \tikzfigscale{1}{figs/putput} & \tikzfigscale{1}{figs/getget}
\end{array}
\end{equation}
making $\putt{}$ a magma module and $\get{}$ a comagma module. Additionally we require:

\begin{equation}\label{putgetgetput}
\arraycolsep=1.5cm
\begin{array}{cc}
    \textrm{PutGet} & \textrm{GetPut} \\
    \tikzfigscale{1}{figs/putget} &\tikzfigscale{1}{figs/getput}
\end{array}
\end{equation}
\end{defn}

These four equations are operationally well-chosen with the intent of capturing what it means to be an ``update''. The PutPut rule says updating twice ought to be the same as performing some operation on the properties and then updating once with the new combined property. GetGet is the converse of this; retrieving a property twice should be the same as retrieving once and then performing some operation (e.g. copying) on the retrieved data. PutGet captures the notion that updating and then retrieving ought to be the same as copying, then updating with one of the copies. Finally GetPut is the notion that looking and then putting back ought to leave the system invariant. 

In some circumstances, GetPut is quite a strong demand. For instance quantum measurements do not satisfy this law, as measurement and reinsertion of classical data disturbs the system via decoherence. Thus we also defined a strictly weaker notion.
\begin{defn}[Weak Update Structure]
A weak update structure $(\putt{},\get{},\mix{},\copyy{})$ satisfies all the axioms of an update structure apart from GetPut which we replace with the strictly weaker \textit{repeat-update} axiom:
\begin{equation}\label{repeatupdate}
\tikzfigscale{1}{figs/repeatupdate}
\end{equation}
\end{defn}
\begin{prop}\cite{hefford2020categories}
Any strong update structure is a weak update structure.
\end{prop}

For  a  weak  update  structure measurement is allowed to disturb the system. The Put is however ``static'': updating twice with copies of a property is the same as updating once with that property. We give a separate operational axiom to capture when the occurrence of an update can be ignored.
\begin{defn}[Ignorable] Put is ignorable if
\begin{equation}\label{prop:discard}
    \tikzfigscale{1}{figs/discardable}
\end{equation}
Get is ignorable if it has the same property but flipped vertically.
\end{defn}
Since we introduced the weakening of strong update structures to cope with interactions which disturb or collapse systems in the way that for example quantum measurements do, it is appropriate that those weak updates that are truly ignorable are strong.
\begin{prop}\label{prop:weaktostrong}
    Any weak update structure with an ignorable Put is a strong update structure:
\end{prop}
\begin{proof}
By the ignorable Put, PutGet, the repeat-update axiom, and another use of the ignorable Put.
\begin{equation}\label{ignortogetput}
    \tikzfigscale{1}{figs/ignortogetput}
\end{equation}
\end{proof}
To finish this section, it is worth pointing out that the PutPut and GetGet laws place quite strong constraints on the (co)associativity of the (co)magma.  One can deduce the following from PutPut and GetGet:
\begin{equation*}
    \tikzfigscale{1}{figs/putgetcoass}
\end{equation*}
While the definition of an update structure allows for a (co)magma which is not (co)associative, in this case the put/get would have to be noisy. More concretely it cannot be \textit{faithful} (see definition \ref{faithful}).

\section{Relation to Very-Well-Behaved Lenses}
In this section we relate update structures to very-well-behaved lenses. Indeed, to those familiar with lenses, our choice of language ``Get'' and ``Put'' may raise suspicions that the two are related. We now make the connection precise.

\begin{defn}[Very-Well-Behaved Lens]
In a category $\cat{C}$ with finite products, a lens \cite{foster_combinators_nodate} is a tuple $(S,V,g:S\rightarrow V,p:S \times V \rightarrow S)$, where $S$ and $V$ are objects of $\cat{C}$. A lens is further \emph{very-well-behaved} (\emph{vwb}) if it satisfies the following:
\begin{itemize}
    \item (PutPut): $p(p(s,v_1),v_2) = p(s,v_2)$
    \item (PutGet): $g(p(s,v)) = v$
    \item (GetPut): $p(s,g(s)) = s$
\end{itemize}
\end{defn}

\begin{prop}
\label{lensequiv}
Vwb lenses $(S,V,g,p)$ in a category $\cat{C}$ with finite products are in bijection with update structures that have ignorable gets, $\mix{} := \pi_2$, and $\copyy{} := \delta_V$. Under this bijection, the very-well-behavedness laws are equivalent to their update structure counterparts.
\end{prop}

\begin{proof}
Given in Appendix \ref{proof:lens}.
\end{proof}

Thus update structures generalise lenses; every vwb lens is an update structure but not the converse. Perhaps the most import distinction is that update structures allow for the possibility that Get affects the system. When a lens is viewed as an update structure, its Get operation does not modify the system $S$; it duplicates it using the duplication map that comes with the finite product structure, and returns it unmodified alongside the computed $V$.

In the more general setting of a monoidal category one does not have this additional structure. In general, there will be no such duplication map (for instance we cannot copy quantum data) and as such it is important to require that the Get also returns a system of type $S$. Thus Proposition \ref{lensequiv} serves as a bridge between vwb lenses and update structures in monoidal settings: where $S$ and $V$ in the monoidal category are comonoid objects, and $\get{}$ and $\putt{}$ are comonoid homomorphisms, one obtains a close analogue of vwb lenses.

This vantage point of lenses \emph{qua} update structures appears to be an interesting new point in the space of lens-like structures: it generalizes the usual cartesian lenses without being as general as optics \cite{rileyCategoriesOptics2018}. We remark an interesting similarity with Abou-Saleh et al.'s monadic lenses \cite{abou-saleh_reflections_2016}: they also generalize lenses to a setting that is not quite cartesian monoidal, and in doing so come up with strikingly similar laws. Specifically, their MPutGet and MGetPut laws are exact analogues to our PutGet and GetPut, that would be drawn identically if string diagrams could be drawn in the monadic case. They also mention another approach to monadic lenses that requires an analogue of our GetGet law.

A final distinguishing point between lenses and update structures appears relative to composition. Notions of lenses all have the important property of composability: one can compose lenses to build accessors for a big data type in terms of accessors for its subcomponents. In this paper we however do not investigate composition of update structures, and it appears there might be different sensible such notions\footnote{with one possibility appearing in \cite{hefford2020categories}}, requiring different additional structure on the (co)magmas and operations.


\section{Interacting Module-Comodule Pairs}
Given a (co)magma (co)module pair, there are many possible PutGet rules one could impose and in this section we will study a handful of these possibilities, elucidating the restrictions each choice places on the rest of the structure, in particular the magma-comagma pair.

\begin{equation*}
\arraycolsep=0.8cm
\begin{array}{ccc}
    A & B & C \\
    \tikzfigscale{1}{figs/putget1} & \tikzfigscale{1}{figs/putget2} &
    \tikzfigscale{1}{figs/putget3}
\end{array}
\end{equation*}

\begin{prop}\label{prop:putgetA}
    In the presence of PutPut and GetGet, PutGet A leads to:
    \begin{enumerate}
    \item with the GetPut rule, $S\simeq S\otimes p$, which in many categories, for instance $\fhilb$, $\frel$ and $\fset$, means $S$ or $p$ have to in some way be trivial. In $\fhilb$ $p=I$, and in $\frel$ and $\fset$, either $p=I$, $p=\varnothing$ or $S=\varnothing$.
    \item If the (co)magma has a (co)unit then the identity separates.

    \end{enumerate}
\end{prop}
\begin{proof}
Given in Appendix \ref{proof:putgetA}.
\end{proof}

Thus an update satisfying PutGet A would imply a very exotic magma-comagma: they cannot have the GetPut rule in finite dimensions and even dropping this rule, they cannot have a (co)unit.

\begin{prop}\label{prop:putgetB}
    PutGet B makes the comagma coassociative under the Put $\putt{}$:
    \begin{equation*}
    \tikzfigscale{1}{figs/coassput}
    \end{equation*}
\end{prop}
\begin{proof}
Given in Appendix \ref{proof:putgetB}.
\end{proof}

\begin{prop}\label{prop:putgetC}
    PutGet C makes the magma associative under the Get $\get{}$:
    \begin{equation*}
    \tikzfigscale{1}{figs/assput}
    \end{equation*}
\end{prop}
\begin{proof}
Given in Appendix \ref{proof:putgetC}.
\end{proof}

\begin{prop}\label{prop:putgetBC}
    Demanding PutGet B and C makes the magma and comagma Frobenius under the Put (and the Get):
    \begin{equation*}
    \tikzfigscale{1}{figs/frobput}
    \end{equation*}
\end{prop}
\begin{proof}
Given in Appendix \ref{proof:putgetBC}.
\end{proof}
    



Furthermore, there are conditions the magma and comagma inherit via reference to the (co)module structure alone.

\begin{defn}[Commutative] Put (Get) is commutative if
\begin{equation}\label{commuteget}
    \tikzfigscale{1}{figs/commuteget}
\end{equation}
\end{defn}
\begin{prop}\label{prop:commute}
    Commutativity of Put (Get), makes the magma (comagma) commutative under the Put (Get):
    \begin{equation*}
    \tikzfigscale{1}{figs/propcommute}
    \end{equation*}
\end{prop}
\begin{proof}
Given in Appendix \ref{proof:commute}.
\end{proof}


\begin{prop}\label{prop:ignorable}
    An ignorable Put (resp. Get) gives the magma (comagma) a unit (counit) under the Put (Get):
    \begin{equation*}
    \tikzfigscale{1}{figs/propunit}
    \end{equation*}
\end{prop}
\begin{proof}
Given in Appendix \ref{proof:ignorable}.
\end{proof}






\section{Quantum Measurements As Weak Update Structures}
Having confirmed that update structures generalise lenses, we now show that they generalise quantum measurements and their precursors - projector valued spectra. By generalising the process given in \cite{coecke_measurements} for building quantum measurements from projector valued spectra, we find that decoherence generates weak update structures from strong update structures. Projector valued spectra in $\fhilb$ are characterised by the following graphical conditions.
%In the transition from spectra to measurements we notice that the getput restriction in this special case \cite{hefford2020categories} defines a partially decohered system.
%First of all quantum measurements and projector valued spectra have $\putt{} = \get{}^{\dagger}$ and $\mix{} = \copyy{}^{\dagger} = \frob{}$.


\begin{defn}[Projector-Valued Spectrum] \cite{coecke_measurements}
The pair of morphisms $(\putt{},\frob{})$ in $\fhilb$ is a projector-valued spectrum if $\frob{}$ is a commutative $\dagger$-special Frobenius algebra and $\putt{}$ satisfies: 
\begin{equation}
    \tikzfigscale{1}{figs/pspectrum}
\end{equation}
These equations are paraphrased by asking that $\putt{}$ be $p$-idempotent, $p$-self-adjoint, and $p$-complete respectively.
\end{defn}
A projector valued spectrum carries only the data of a single interacting module $\putt{}$ and magma $\frob{}$, however the $\dagger$ can be used to construct a full update structure.
\begin{defn}[Dagger Update Structure]
$(\putt{},\frob{})$ is a $\dagger$-update structure if $(\putt{},\putt{}^{\dagger},\frob{},\copyy{})$ is an update structure.
\end{defn}
For a tuple $(\putt{},\putt{}^{\dagger},\frob{},\copyy{})$ built from a projector valued spectrum to be an update structure it must satisfy the PutGet and GetPut axioms. 
\begin{prop} Every projector-valued spectrum $(\putt{},\frob{})$ is a $\dagger$-update structure.
\end{prop}
\begin{proof}
By $p$-idempotency, $(\putt{},\putt{}^{\dagger},\frob{},\copyy{})$ is immediately a (co)magma module pair. The GetPut axiom holds, any projector valued spectrum is isometric with inverse equal to the adjoint.
\begin{equation}
    \tikzfigscale{1}{figs/getputprojector}
\end{equation}
Finally the PutGet axiom holds.
\begin{equation}
    \tikzfigscale{1}{figs/putgetprojector2}
\end{equation}
\end{proof}
Quantum measurements are built from projector valued spectra in $\fhilb$ via embedding into $\cpm{\fhilb}$ \cite{selinger} and subsequent application of the decoherence morphism $\deco{}$ \cite{coecke_measurements, bob_coecke_aleks_kissinger_picturing_2017}.
\begin{equation}
    \tikzfigscale{1}{figs/qmmeasure}
\end{equation}
We can consequently show that any quantum measurement is itself an update structure. First of all, for any $\dagger$-compact category $\cat{C}$ the functor $F$ from $\cat{C}$ to $\cpm{\cat{C}}$ which takes $f: A \rightarrow B$ to $f \otimes f^{*}: A \otimes A^{*} \rightarrow B \otimes B^{*}$, maps any update structure in $\cat{C}$ to an update structure in $\cpm{\cat{C}}$. 
%Applying decoherence to any strong update structure in CPM$(\mathbf{C})$ will generate a new weak update structure in the Karoubi envelope $\overbar{\textrm{CPM}(\mathbf{C})}$ of CPM$(\mathbf{C})$.
%\begin{prop}[Decohering an Update Mechanism]
%Given any omni-directional magma homomorphism $m$, 
%\begin{equation}
%    \tikzfigscale{1}{figs/omni}
%\end{equation}
%The update mechanism given by composing all morphisms with $m$
%\begin{equation}
%    \tikzfigscale{1}{figs/omni}
%\end{equation}
%defines a weak update structure. 
%\end{prop}
Secondly, we will show that for any such update structure with $\frob{}$ commutative $\dagger$-special Frobenius, decoherence generates a new weak update structure, which can furthermore be considered a weak update structure on classical objects in $\spl{\cpm{\cat{C}}}$ - the Karoubi envelope of $\cpm{\cat{C}}$. 
\begin{defn}[Karoubi Envelope]
The Karoubi envelope $\spl{\cat{C}}$ of a category $\cat{C}$ has as objects the pairs $(A,\pi)$ where $A \in \ob{\cat{C}}$ and $\pi: A \rightarrow A$ is an idempotent. The morphisms $f : (A ,\pi) \rightarrow (B,\sigma)$ are the morphisms $f:A \rightarrow B$ such that $\sigma \circ f = f = f \circ \pi$. 
\end{defn}
As studied in refs \cite{coecke_classicality, selinger_idempotents, Heunen_cp}, the object $(F(p),\deco{})$ represents a classical version of the object $p$, on which the only states and transformations permitted are those which are unaffected by decoherence $f \circ \deco{} = f = \deco{} \circ f$. Applying decoherence to an update structure then produces a new update structure for which the property read off is guaranteed to be classical. 
\begin{prop} \label{prop:decoupdate}
Given any weak update structure $(\putt{},\get{},\frob{},\copyy{})$ in a $\dagger$-compact category $\cat{C}$ on system $S$, and property $p$ with $\frob{}$ a commutative $\dagger$-special Frobenius algebra, composition with the decoherence map  
\begin{equation}
    \tikzfigscale{1}{figs/decohereupdate}
\end{equation}
generates a weak update structure on $F(S)$ and $F(p)$ which also appears as a weak update structure in $\spl{\cpm{\cat{C}}}$ on system $(F(S),\id{F(S)})$ and property $(F(p),\deco{})$.
\end{prop}
\begin{proof}
Given in Appendix \ref{proof:magmaupdate}
\end{proof}
\begin{corr}
Every quantum measurement $(\putt{},\copyy{})$ is a weak-$\dagger$ update structure.
\end{corr}
The GetPut axiom on a $\dagger$-update structure is isometricity, it naturally fails because decoherence disturbs a quantum system. Via a GetPut restriction as introduced in \cite{hefford2020categories} any such weak update structure on a fully quantum system $(F(S),\id{F(S)})$ can be used to construct a strong update structure on a measured, partially decohered, system $(S,\putt{} \circ \get{})$.

On top of being update structures, projector valued spectra carry some additional conditions, their Puts are commutative, ignorable, and in Appendix \ref{faithfulproj} we confirm they are faithful.  
\begin{defn}[Faithful]
A $\dagger{}$-update structure is faithful if 
\begin{equation}\label{faithful}
    \tikzfigscale{1}{figs/faithful}
\end{equation}
\end{defn}
%Operationally, faithfulness is the claim that any disctinct manipulation of a property gives a distint manipulation of the system. 
Conversely, the above conditions are enough to characterise projector valued spectra.

\begin{prop}
 A $\dagger$-update structure $(\putt{},\frob{})$ in $\cat{FHilb}$ is a Projector Valued spectrum if and only if it is faithful, commutative, and ignorable.
\end{prop}
\begin{proof}
Since we have already demonstrated the ``$\Rightarrow$" direction we only need to consider ``$\Leftarrow$". The results of section 3 imply that the magma of a faithful, commutative, ignorable $\dagger$-update is a commutative $\dagger$-special Frobenius algebra. The unit $\unit{}$ is the effect which makes $\putt{}$ ignorable, so $\putt{}$ is $p$-complete. The PutPut axiom is $p$-idempotency, and finally since $\putt{}$ is $p$-complete, the putget axiom implies that $\putt{}$ is $p$-self-adjoint. 
\begin{equation}
    \tikzfigscale{1}{figs/weakisselfadjoint}
\end{equation}
\end{proof}

%\begin{corr}[Other Examples of Decohering Update Structures]
%Make the point that to construct mixtures we needed the category to be compact closed, another nice justification for moving away from cartesian closure.
%\end{corr}

\section{A New Example: Morphisms as Properties}
We now give a new example of a strong update structure based on the ``pair of pants" monoid \cite{heunen2019categories}. $\dagger$-Compact categories come equipped with an evaluation morphism $\epsilon : S^{*} \otimes S \otimes S \rightarrow S$ and a composition morphism $\sigma : S^{*} \otimes S \otimes S^{*} \otimes S \rightarrow S^{*} \otimes S$ which satisfy PutPut. The evaluation takes as inputs a morphism and a state, and produces an output by applying the morphism to the state. We can use $\epsilon$ and $\sigma$ as $\putt{}$ and $\mix{}$ respectively, along with the dagger to construct an update structure for which systems are states, and properties are morphisms waiting to be applied to those states. 
\begin{prop}
The tuple $(\putt{},\get{},\mix{},\copyy{})$ in a $\dagger$-Compact category with invertible scalars defined by,
\begin{equation*}
    \tikzfigscale{1}{figs/compupdate}
\end{equation*}
is a strong update structure.
\end{prop}
\begin{proof}

PutPut and GetGet can be confirmed graphically, but also follow by definition of composition $\sigma$ as the adjunct to $\epsilon \circ (\epsilon \otimes I)$ in any symmetric closed monoidal category. PutGet is quick to verify 
\begin{equation}\label{pgcomp}
    \tikzfigscale{1}{figs/putgetcomp}
\end{equation}
as is GetPut
\begin{equation}\label{gpcomp}
    \tikzfigscale{1}{figs/getputcomp}
\end{equation}
%Note, correlators here will be quantum combs, being a monoid homomorphism is the condition that the comb is a functor.

%Since $\mix{}$ is the adjunct of $\putt{} \circ (\putt{} \otimes \id{})$, 
\end{proof}
This update structure is ignorable and faithful, its magma and co-magma are Frobenius, and special, but non-commutative.






\section{Conclusion}
In this article we have furthered our development of update structures. We originally introduced update structures with operational inspiration and we have now shown that very-well-behaved lenses, quantum observables and measurements and a slight alteration on the pair-of-pants monoid all live within the zoo of update structures. This offers a unifying perspective of two fields and elevates update structures to algebraic objects that deserve further investigation.

This work opens several lines of investigation. We have not discussed composition of update structures in this article, but there seems to be multiple interesting such notions. Each such notion would impose additional structure in order to be well-defined. Exploring these alternatives would provide further insight into those structures and contribute to a more featureful unification.

We also endeavour to expand the zoo of update structures with more exotic beasts. Perhaps such structures could allow for updates which behave neither quantumly nor classically and further the search for post-quantum phenomena.

A further goal would be to formally justify the axioms of update structures. Currently they are operationally well-chosen but it is not clear how necessary and sufficient they are, or whether other choices could lead to related and interesting structures. We touched upon this when we investigated alternative PutGet rules, but the full ramifications of these choices are not currently understood.


\subsubsection*{Acknowledgements}
With many thanks to Sean Tull for pointing out the connections to quantum observables and to Bob Coecke for helpful discussions.
This work was supported by University College London and the EPSRC [grant number EP/L015242/1].




\bibliographystyle{eptcs}
\bibliography{bibliography}

%\printbibliography 

\appendix

\section{Proofs}
\subsection{Proof of Proposition \ref{lensequiv}}\label{proof:lens}
\begin{proof}
Recalling that categories with finite products are cartesian monoidal, we rewrite the lens laws in the following suggestive graphical form.

\begin{equation*}
    \tikzfigscale{0.7}{figs/prop1/lawfullens}
\end{equation*}

The bijection identifies $p$ and $\putt{}$. $\copyy{}$ is $\delta_V$, the copy on $V$, and $\mix{}$ is $\pi_2$. $g$ and $\get{}$ follow the obvious type-matching strategy.

\begin{equation*}
    \tikzfigscale{1}{figs/prop1/struct2lensrules}
\end{equation*}

We verify one injection as follows:

\begin{equation*}
    \tikzfigscale{1}{figs/prop1/lensembed}
\end{equation*}

And the other (making use of the ignorability of $\get{}$ in the penultimate step):

\begin{equation*}
    \tikzfigscale{1}{figs/prop1/getinject}
\end{equation*}

From the substitutions on $\mix{}$ and $\get{}$, it immediately follows that the PutPut and GetPut laws are equivalent for both update structures and vwb lenses. Regarding PutGet, we have that PutGet for lenses implies PutGet for the corresponding update structure, and PutGet for an update structure implies PutGet for the corresponding lens:

\begin{equation*}
    \tikzfigscale{1}{figs/prop1/putgetlensequivalence}
\end{equation*}

It is worth noting that this correspondence makes use of the `left-delete' magma $\mix{} = \pi_2$ which is \emph{not} a monoid.
\end{proof}

\subsection{Proof of Proposition \ref{prop:putgetA}}\label{proof:putgetA}
\begin{proof}
\begin{enumerate}
\item In the presence of the GetPut law we immediately have that $S\simeq S\otimes p$. In $\fhilb$ this requires $p=I$ and in $\frel$ and $\fset$ either $p=I$, $p=\varnothing$ or $S=\varnothing$. Thus the update is rendered essentially trivial.
\item By looking at $(\get{}\otimes \id{p})\circ\get{}\circ \putt{}$ and $\get{}\circ\putt{}\circ(\putt{}\otimes\id{p})$ one can show
\begin{equation*}
    \tikzfigscale{1}{figs/putgeta1}
\end{equation*}
and if the (co)magma have (co)units then (assuming $S\neq \varnothing$ in $\fset$ or $\frel$), 
\begin{equation*}
    \tikzfigscale{1}{figs/putgeta3}
\end{equation*}
\end{enumerate}
\end{proof}

\subsection{Proof of Proposition \ref{prop:putgetB}}\label{proof:putgetB}
\begin{proof}
Starting with the left-hand side and applying PutGet B twice followed by GetGet and PutGet B in reverse recovers the right-hand side.
\end{proof}

\subsection{Proof of Proposition \ref{prop:putgetC}}\label{proof:putgetC}
\begin{proof}
Starting with the left-hand side and applying PutGet C twice followed PutPut and PutGet C in reverse recovers the right-hand side.
\end{proof}

\subsection{Proof of Proposition \ref{prop:putgetBC}}\label{proof:putgetBC}
\begin{proof}
Consider $\get{}\circ \putt{} \circ (\putt{}\otimes \id{p})$ and apply the following laws:
\begin{itemize}
\item PutGet B followed by PutPut, for the left-hand side
\item PutPut followed by PutGet B, for the centre
\item PutGet C followed by PutGet B, for the right-hand side
\end{itemize}
\end{proof}


\subsection{Proof of Proposition \ref{prop:commute}}\label{proof:commute}
\begin{proof}
The proposition for Put follows immediately from the PutPut axiom.
\begin{equation}
    \tikzfigscale{1}{figs/provecommute}
\end{equation}
and similarly GetGet implies the proposition for Get.
\end{proof}


\subsection{Proof of Proposition \ref{prop:ignorable}}\label{proof:ignorable}
\begin{proof}
Again the proposition for Put follows immediately from the PutPut axiom.
\begin{equation}
    \tikzfigscale{1}{figs/proveunit}
\end{equation}
and similarly for Get.
\end{proof}





\subsection{Proof of Proposition \ref{prop:decoupdate}}\label{proof:magmaupdate}
The decoherence map $\deco{}$ is an idempotent magma \& co-magma homomorphism in $\cpm{\cat{C}}$. We prove that any idempotent magma \& co-magma homomorphism $m$ in a category $\cat{D}$ defines a transformation from a strong update structure $(\putt{},\get{},\mix{},\copyy{})$ in $\cat{D}$ on objects $S$ and $p$ to a weak update structure in $\spl{\cat{D}}$ on system $(S,\id{S})$ and property $(p,m)$. 
\begin{proof}
Defining the new update structure by
\begin{equation}
    \tikzfigscale{1}{figs/magmaupdate}
\end{equation}
The proof that $(\putt{}',\get{}',\mix{}',\copyy{}')$ is a weak update follows similar steps to \cite{hefford2020categories} for correlated updates. Repeat Update:
\begin{equation}
    \tikzfigscale{1}{figs/magmarepeatupdate}
\end{equation}
PutPut:
\begin{equation}
    \tikzfigscale{1}{figs/magmaputput}
\end{equation}
The proof of GetGet is identical, leaving PutGet:
\begin{equation}
    \tikzfigscale{1}{figs/magmaputget}
\end{equation}

%The $m$ at the bottom of the picture means that PutGet does not hold in $\cat{D}$ on system $S$ and property $p$. Imagining $m$ as a generalisation of a projection, the new projected $\get{}$ and $\putt{}$ are valid update structures on precisely those properties which live within the image of the projector, I.E all of those states for which $m \circ \psi = \psi$. Formally $m$ is the identity on the property $(p,m)$ in $\spl{\cat{D}}$, each of $\putt{}'$, $\get{}'$, $\mix{}'$, and $\frob{}$ define morphisms in $\spl{\cat{D}}$ on system $(S,\id{S})$ and property $(p,m)$, and it is these morphisms which form a weak update structure.
As such $(\putt{}',\get{}',\mix{}',\copyy{}')$ is a weak update structure, furthermore each morphism is easily checked to be a morphism on the appropriate objects in $\spl{\cat{D}}$.
\end{proof}
So far we have come across two uses of this proposition, one in defining updates of correlated properties \cite{hefford2020categories}, and another here in defining updates of classical properties.


\subsection{Proof that Projector Valued Spectra are Faithful} \label{faithfulproj}

We define $f_{mnij}$ and $g_{mnij}$ by 
\begin{equation}
    \tikzfigscale{1}{figs/fmnij}
\end{equation}
In $\mathbf{FHilb}$ he have by enough states,

\begin{equation}
    \tikzfigscale{1}{figs/provefaithful}
\end{equation}

Now since $\putt{} \circ (\id{} \otimes \ket{i}) \equiv P_{i}$ are orthogonal projectors it follows that 
\begin{equation}
    \tikzfigscale{1}{figs/provefaithful2}
\end{equation}
and so for all m,n,i,k $f_{mnik} = g_{mnik}$ i.e. $f=g$.









\end{document}