
@InProceedings{	  10.1145/2628136.2628144,
  author	= {Marlow, Simon and Brandy, Louis and Coens, Jonathan and
		  Purdy, Jon},
  title		= {There is No Fork: An Abstraction for Efficient,
		  Concurrent, and Concise Data Access},
  year		= {2014},
  isbn		= {9781450328739},
  publisher	= {Association for Computing Machinery},
  address	= {New York, NY, USA},
  url		= {https://doi.org/10.1145/2628136.2628144},
  doi		= {10.1145/2628136.2628144},
  abstract	= {We describe a new programming idiom for concurrency, based
		  on Applicative Functors, where concurrency is implicit in
		  the Applicative &lt;*&gt; operator. The result is that
		  concurrent programs can be written in a natural applicative
		  style, and they retain a high degree of clarity and
		  modularity while executing with maximal concurrency. This
		  idiom is particularly useful for programming against
		  external data sources, where the application code is
		  written without the use of explicit concurrency constructs,
		  while the implementation is able to batch together multiple
		  requests for data from the same source, and fetch data from
		  multiple sources concurrently. Our abstraction uses a cache
		  to ensure that multiple requests for the same data return
		  the same result, which frees the programmer from having to
		  arrange to fetch data only once, which in turn leads to
		  greater modularity.While it is generally applicable, our
		  technique was designed with a particular application in
		  mind: an internal service at Facebook that identifies
		  particular types of content and takes actions based on it.
		  Our application has a large body of business logic that
		  fetches data from several different external sources. The
		  framework described in this paper enables the business
		  logic to execute efficiently by automatically fetching data
		  concurrently; we present some preliminary results.},
  booktitle	= {Proceedings of the 19th ACM SIGPLAN International
		  Conference on Functional Programming},
  pages		= {325–337},
  numpages	= {13},
  keywords	= {haskell, data-fetching, monad, distributed, concurrency,
		  applicative},
  location	= {Gothenburg, Sweden},
  series	= {ICFP '14}
}

@InProceedings{	  bahr11compositional,
  author	= {Bahr, Patrick and Hvitved, Tom},
  title		= {Compositional Data Types},
  year		= {2011},
  isbn		= {9781450308618},
  publisher	= {Association for Computing Machinery},
  address	= {New York, NY, USA},
  url		= {https://doi.org/10.1145/2036918.2036930},
  doi		= {10.1145/2036918.2036930},
  abstract	= {Building on Wouter Swierstra's Data types \`{a} la carte,
		  we present a comprehensive Haskell library of compositional
		  data types suitable for practical applications. In this
		  framework, data types and functions on them can be defined
		  in a modular fashion. We extend the existing work by
		  implementing a wide array of recursion schemes including
		  monadic computations. Above all, we generalise recursive
		  data types to contexts, which allow us to characterise a
		  special yet frequent kind of catamorphisms. The thus
		  established notion of term homomorphisms allows for
		  flexible reuse and enables short-cut fusion style
		  deforestation which yields considerable speedups. We
		  demonstrate our framework in the setting of compiler
		  construction, and moreover, we compare compositional data
		  types with generic programming techniques and show that
		  both are comparable in run-time performance and
		  expressivity while our approach allows for stricter types.
		  We substantiate this conclusion by lifting compositional
		  data types to recursive data types and generalised
		  algebraic data types. Lastly, we compare the run-time
		  performance of our techniques with traditional
		  implementations over algebraic data types. The results are
		  surprisingly good.},
  booktitle	= {Proceedings of the Seventh ACM SIGPLAN Workshop on Generic
		  Programming},
  pages		= {83–94},
  numpages	= {12},
  keywords	= {algebraic programming, reusability, deforestation, mutual
		  recursion},
  location	= {Tokyo, Japan},
  series	= {WGP '11}
}

@Misc{		  brunsfeld18tree,
  author	= {Brunsfeld, Max},
  title		= {tree-sitter/tree-sitter: v0.20.4},
  month		= jan,
  year		= 2018,
  publisher	= {Zenodo},
  version	= {v0.20.4},
  doi		= {10.5281/zenodo.5894991},
  url		= {https://doi.org/10.5281/zenodo.5894991}
}

@InProceedings{	  carette07finallytagless,
  author	= {Jacques Carette and Oleg Kiselyov and Chung{-}chieh Shan},
  editor	= {Zhong Shao},
  title		= {Finally Tagless, Partially Evaluated},
  booktitle	= {Programming Languages and Systems, 5th Asian Symposium,
		  {APLAS} 2007, Singapore, November 29-December 1, 2007,
		  Proceedings},
  series	= {Lecture Notes in Computer Science},
  volume	= {4807},
  pages		= {222--238},
  publisher	= {Springer},
  year		= {2007},
  url		= {https://doi.org/10.1007/978-3-540-76637-7\_15},
  doi		= {10.1007/978-3-540-76637-7\_15},
  timestamp	= {Tue, 14 May 2019 10:00:41 +0200},
  biburl	= {https://dblp.org/rec/conf/aplas/CaretteKS07.bib},
  bibsource	= {dblp computer science bibliography, https://dblp.org}
}

@Misc{		  creager21stackgraphs,
  title		= {Introducing stack graphs | The GitHub Blog},
  url		= {
		  https://github.blog/2021-12-09-introducing-stack-graphs/},
  journal	= {The GitHub Blog},
  author	= {Creager, Douglas},
  year		= {2021}
}

@Article{	  darais17abstracting,
  author	= {Darais, David and Labich, Nicholas and Nguyen, Ph\'{u}c C.
		  and Van Horn, David},
  title		= {Abstracting Definitional Interpreters (Functional Pearl)},
  year		= {2017},
  issue_date	= {September 2017},
  publisher	= {Association for Computing Machinery},
  address	= {New York, NY, USA},
  volume	= {1},
  number	= {ICFP},
  url		= {https://doi.org/10.1145/3110256},
  doi		= {10.1145/3110256},
  abstract	= {In this functional pearl, we examine the use of
		  definitional interpreters as a basis for abstract
		  interpretation of higher-order programming languages. As it
		  turns out, definitional interpreters, especially those
		  written in monadic style, can provide a nice basis for a
		  wide variety of collecting semantics, abstract
		  interpretations, symbolic executions, and their
		  intermixings. But the real insight of this story is a
		  replaying of an insight from Reynold's landmark paper,
		  Definitional Interpreters for Higher-Order Programming
		  Languages, in which he observes definitional interpreters
		  enable the defined-language to inherit properties of the
		  defining-language. We show the same holds true for
		  definitional abstract interpreters. Remarkably, we observe
		  that abstract definitional interpreters can inherit the
		  so-called “pushdown control flow” property, wherein
		  function calls and returns are precisely matched in the
		  abstract semantics, simply by virtue of the function call
		  mechanism of the defining-language. The first approaches to
		  achieve this property for higher-order languages appeared
		  within the last ten years, and have since been the subject
		  of many papers. These approaches start from a state-machine
		  semantics and uniformly involve significant technical
		  engineering to recover the precision of pushdown control
		  flow. In contrast, starting from a definitional
		  interpreter, the pushdown control flow property is inherent
		  in the meta-language and requires no further technical
		  mechanism to achieve.},
  journal	= {Proc. ACM Program. Lang.},
  month		= {aug},
  articleno	= {12},
  numpages	= {25},
  keywords	= {abstract interpreters, interpreters}
}

@InProceedings{	  eisenberg16visible,
  author	= "Eisenberg, Richard A. and Weirich, Stephanie and Ahmed,
		  Hamidhasan G.",
  editor	= "Thiemann, Peter",
  title		= "Visible Type Application",
  booktitle	= "Programming Languages and Systems",
  year		= "2016",
  publisher	= "Springer Berlin Heidelberg",
  address	= "Berlin, Heidelberg",
  pages		= "229--254",
  abstract	= "The Hindley-Milner (HM) type system automatically infers
		  the types at which polymorphic functions are used. In HM,
		  the inferred types are unambiguous, and every expression
		  has a principal type. Type annotations make HM compatible
		  with extensions where complete type inference is
		  impossible, such as higher-rank polymorphism and type-level
		  functions. However, programmers cannot use annotations to
		  explicitly provide type arguments to polymorphic functions,
		  as HM requires type instantiations to be inferred.",
  isbn		= "978-3-662-49498-1"
}

@InProceedings{	  finis13rwsdiff,
  author	= {Finis, Jan P. and Raiber, Martin and Augsten, Nikolaus and
		  Brunel, Robert and Kemper, Alfons and F\"{a}rber, Franz},
  title		= {RWS-Diff: Flexible and Efficient Change Detection in
		  Hierarchical Data},
  year		= {2013},
  isbn		= {9781450322638},
  publisher	= {Association for Computing Machinery},
  address	= {New York, NY, USA},
  url		= {https://doi.org/10.1145/2505515.2505763},
  doi		= {10.1145/2505515.2505763},
  booktitle	= {Proceedings of the 22nd ACM International Conference on
		  Information and Knowledge Management},
  pages		= {339–348},
  numpages	= {10},
  location	= {San Francisco, California, USA},
  series	= {CIKM '13}
}

@Misc{		  freersimple16,
  author	= {Dev, Allele and King, Alexis},
  title		= {freer-simple},
  year		= 2016,
  url		= {https://github.com/lexi-lambda/freer-simple}
}

@Misc{		  google08protocol,
  author	= {Google},
  title		= {Protocol Buffers},
  year		= 2008,
  url		= {https://developers.google.com/protocol-buffers}
}

@Misc{		  google14kube,
  author	= {Google},
  title		= {Kubernetes},
  year		= 2014,
  url		= {https://kubernetes.io}
}

@Article{	  haefliger08code,
  author	= {Haefliger, Stefan and von Krogh, Georg and Spaeth,
		  Sebastian},
  title		= {Code Reuse in Open Source Software},
  journal	= {Management Science},
  volume	= {54},
  number	= {1},
  pages		= {180-193},
  year		= {2008},
  doi		= {10.1287/mnsc.1070.0748},
  url		= { https://doi.org/10.1287/mnsc.1070.0748
		  
		  },
  eprint	= { https://doi.org/10.1287/mnsc.1070.0748
		  
		  },
  abstract	= { Code reuse is a form of knowledge reuse in software
		  development that is fundamental to innovation in many
		  fields. However, to date there has been no systematic
		  investigation of code reuse in open source software
		  projects. This study uses quantitative and qualitative data
		  gathered from a sample of six open source software projects
		  to explore two sets of research questions derived from the
		  literature on software reuse in firms and open source
		  software development. We find that code reuse is extensive
		  across the sample and that open source software developers,
		  much like developers in firms, apply tools that lower their
		  search costs for knowledge and code, assess the quality of
		  software components, and have incentives to reuse code.
		  Open source software developers reuse code because they
		  want to integrate functionality quickly, because they want
		  to write preferred code, because they operate under limited
		  resources in terms of time and skills, and because they can
		  mitigate development costs through code reuse. }
}

@InProceedings{	  horn10abstracting,
  author	= {Van Horn, David and Might, Matthew},
  title		= {Abstracting Abstract Machines},
  year		= {2010},
  isbn		= {9781605587943},
  publisher	= {Association for Computing Machinery},
  address	= {New York, NY, USA},
  url		= {https://doi.org/10.1145/1863543.1863553},
  doi		= {10.1145/1863543.1863553},
  abstract	= {We describe a derivational approach to abstract
		  interpretation that yields novel and transparently sound
		  static analyses when applied to well-established abstract
		  machines. To demonstrate the technique and support our
		  claim, we transform the CEK machine of Felleisen and
		  Friedman, a lazy variant of Krivine's machine, and the
		  stack-inspecting CM machine of Clements and Felleisen into
		  abstract interpretations of themselves. The resulting
		  analyses bound temporal ordering of program events; predict
		  return-flow and stack-inspection behavior; and approximate
		  the flow and evaluation of by-need parameters. For all of
		  these machines, we find that a series of well-known
		  concrete machine refactorings, plus a technique we call
		  store-allocated continuations, leads to machines that
		  abstract into static analyses simply by bounding their
		  stores. We demonstrate that the technique scales up
		  uniformly to allow static analysis of realistic language
		  features, including tail calls, conditionals, side effects,
		  exceptions, first-class continuations, and even garbage
		  collection.},
  booktitle	= {Proceedings of the 15th ACM SIGPLAN International
		  Conference on Functional Programming},
  pages		= {51–62},
  numpages	= {12},
  keywords	= {abstract machines, abstract interpretation},
  location	= {Baltimore, Maryland, USA},
  series	= {ICFP '10}
}

@InProceedings{	  jones02template,
  author	= {Sheard, Tim and Jones, Simon Peyton},
  title		= {Template Meta-Programming for Haskell},
  year		= {2002},
  isbn		= {1581136056},
  publisher	= {Association for Computing Machinery},
  address	= {New York, NY, USA},
  url		= {https://doi.org/10.1145/581690.581691},
  doi		= {10.1145/581690.581691},
  abstract	= {We propose a new extension to the purely functional
		  programming language Haskell that supports compile-time
		  meta-programming. The purpose of the system is to support
		  the algorithmic construction of programs at
		  compile-time.The ability to generate code at compile time
		  allows the programmer to implement such features as
		  polytypic programs, macro-like expansion, user directed
		  optimization (such as inlining), and the generation of
		  supporting data structures and functions from existing data
		  structures and functions.Our design is being implemented in
		  the Glasgow Haskell Compiler, ghc.},
  booktitle	= {Proceedings of the 2002 ACM SIGPLAN Workshop on Haskell},
  pages		= {1–16},
  numpages	= {16},
  keywords	= {templates, meta programming},
  location	= {Pittsburgh, Pennsylvania},
  series	= {Haskell '02}
}

@InProceedings{	  jones95functional,
  author	= "Jones, Mark P.",
  editor	= "Jeuring, Johan and Meijer, Erik",
  title		= "Functional programming with overloading and higher-order
		  polymorphism",
  booktitle	= "Advanced Functional Programming",
  year		= "1995",
  publisher	= "Springer Berlin Heidelberg",
  address	= "Berlin, Heidelberg",
  pages		= "97--136",
  abstract	= "The Hindley/Milner type system has been widely adopted as
		  a basis for statically typed functional languages. One of
		  the main reasons for this is that it provides an elegant
		  compromise between flexibility, allowing a single value to
		  be used in different ways, and practicality, freeing the
		  programmer from the need to supply explicit type
		  information. Focusing on practical applications rather than
		  implementation or theoretical details, these notes examine
		  a range of extensions that provide more flexible type
		  systems while retaining many of the properties that have
		  made the original Hindley/Milner system so popular. The
		  topics discussed, some old, but most quite recent, include
		  higher-order polymorphism and type and constructor class
		  overloading. Particular emphasis is placed on the use of
		  these features to promote modularity and reusability.",
  isbn		= "978-3-540-49270-2"
}

@InProceedings{	  kiselyov15freer,
  author	= {Kiselyov, Oleg and Ishii, Hiromi},
  title		= {Freer Monads, More Extensible Effects},
  year		= {2015},
  isbn		= {9781450338080},
  publisher	= {Association for Computing Machinery},
  address	= {New York, NY, USA},
  url		= {https://doi.org/10.1145/2804302.2804319},
  doi		= {10.1145/2804302.2804319},
  abstract	= { We present a rational reconstruction of extensible
		  effects, the recently proposed alternative to monad
		  transformers, as the confluence of efforts to make
		  effectful computations compose. Free monads and then
		  extensible effects emerge from the straightforward term
		  representation of an effectful computation, as more and
		  more boilerplate is abstracted away. The generalization
		  process further leads to freer monads, constructed without
		  the Functor constraint. The continuation exposed in freer
		  monads can then be represented as an efficient type-aligned
		  data structure. The end result is the algorithmically
		  efficient extensible effects library, which is not only
		  more comprehensible but also faster than earlier
		  implementations. As an illustration of the new library, we
		  show three surprisingly simple applications:
		  non-determinism with committed choice (LogicT), catching IO
		  exceptions in the presence of other effects, and the
		  semi-automatic management of file handles and other
		  resources through monadic regions. We extensively use and
		  promote the new sort of `laziness', which underlies the
		  left Kan extension: instead of performing an operation,
		  keep its operands and pretend it is done. },
  booktitle	= {Proceedings of the 2015 ACM SIGPLAN Symposium on Haskell},
  pages		= {94–105},
  numpages	= {12},
  keywords	= {effect handler, Kan extension, coroutine, type and effect
		  system, free monad, effect interaction, open union},
  location	= {Vancouver, BC, Canada},
  series	= {Haskell '15}
}

@InProceedings{	  lang74deterministic,
  author	= "Lang, Bernard",
  editor	= "Loeckx, Jacques",
  title		= "Deterministic Techniques for Efficient Non-Deterministic
		  Parsers",
  booktitle	= "Automata, Languages and Programming",
  year		= "1974",
  publisher	= "Springer Berlin Heidelberg",
  address	= "Berlin, Heidelberg",
  pages		= "255--269",
  abstract	= "A general study of parallel non-deterministic parsing and
		  translation {\`a} la Earley is developped formally, based
		  on non-deterministic pushdown acceptor-transducers. Several
		  results (camplexity and efficiency) are established, same
		  new and other previously proved only in special cases. As
		  an application, we show that for every family of
		  deterministic context-free pushdown parsers (e.g.
		  precedence, LR(k), LL(k), ...) there is a family of general
		  context-free parallel parsers that have the same efficiency
		  in most practical cases (e.g. analysis of programming
		  languages).",
  isbn		= "978-3-662-21545-6"
}

@InProceedings{	  magalhaes10generic,
  author	= {Magalhães, José and Dijkstra, Atze and Jeuring, Johan
		  and Löh, Andres},
  year		= {2010},
  month		= {11},
  pages		= {37-48},
  title		= {A Generic Deriving Mechanism for Haskell},
  volume	= {45},
  journal	= {Proceedings of the ACM SIGPLAN International Conference on
		  Functional Programming, ICFP},
  doi		= {10.1145/1863523.1863529}
}

@Article{	  marlow14fork,
  author	= {Marlow, Simon and Brandy, Louis and Coens, Jonathan and
		  Purdy, Jon},
  title		= {There is No Fork: An Abstraction for Efficient,
		  Concurrent, and Concise Data Access},
  year		= {2014},
  issue_date	= {September 2014},
  publisher	= {Association for Computing Machinery},
  address	= {New York, NY, USA},
  volume	= {49},
  number	= {9},
  issn		= {0362-1340},
  url		= {https://doi.org/10.1145/2692915.2628144},
  doi		= {10.1145/2692915.2628144},
  abstract	= {We describe a new programming idiom for concurrency, based
		  on Applicative Functors, where concurrency is implicit in
		  the Applicative &lt;*&gt; operator. The result is that
		  concurrent programs can be written in a natural applicative
		  style, and they retain a high degree of clarity and
		  modularity while executing with maximal concurrency. This
		  idiom is particularly useful for programming against
		  external data sources, where the application code is
		  written without the use of explicit concurrency constructs,
		  while the implementation is able to batch together multiple
		  requests for data from the same source, and fetch data from
		  multiple sources concurrently. Our abstraction uses a cache
		  to ensure that multiple requests for the same data return
		  the same result, which frees the programmer from having to
		  arrange to fetch data only once, which in turn leads to
		  greater modularity.While it is generally applicable, our
		  technique was designed with a particular application in
		  mind: an internal service at Facebook that identifies
		  particular types of content and takes actions based on it.
		  Our application has a large body of business logic that
		  fetches data from several different external sources. The
		  framework described in this paper enables the business
		  logic to execute efficiently by automatically fetching data
		  concurrently; we present some preliminary results.},
  journal	= {SIGPLAN Not.},
  month		= {aug},
  pages		= {325–337},
  numpages	= {13},
  keywords	= {applicative, monad, haskell, distributed, data-fetching,
		  concurrency}
}

@Misc{		  marlow15spam,
  title		= {Fighting spam with Haskell},
  url		= {https://engineering.fb.com/2015/06/26/security/fighting-spam-with-haskell/},
  journal	= {Engineering at Meta},
  author	= {Marlow, Simon},
  year		= {2015}
}

@InProceedings{	  meijer91bananas,
  author	= "Meijer, Erik and Fokkinga, Maarten and Paterson, Ross",
  editor	= "Hughes, John",
  title		= "Functional programming with bananas, lenses, envelopes and
		  barbed wire",
  booktitle	= "Functional Programming Languages and Computer
		  Architecture",
  year		= "1991",
  publisher	= "Springer Berlin Heidelberg",
  address	= "Berlin, Heidelberg",
  pages		= "124--144",
  abstract	= "We develop a calculus for lazy functional programming
		  based on recursion operators associated with data type
		  definitions. For these operators we derive various
		  algebraic laws that are useful in deriving and manipulating
		  programs. We shall show that all example functions in Bird
		  and Wadler's ``Introduction to Functional Programming'' can
		  be expressed using these operators.",
  isbn		= "978-3-540-47599-6"
}

@Article{	  myers86diff,
  author	= {Eugene W. Myers},
  title		= {An O(ND) Difference Algorithm and Its Variations},
  journal	= {Algorithmica},
  year		= {1986},
  volume	= {1},
  pages		= {251--266}
}

@Misc{		  nadeem20codegen,
  title		= {CodeGen: Semantic's improved language support system | The
		  GitHub Blog},
  url		= {https://github.blog/2020-08-04-codegen-semantics-improved-language-support-system/},
  journal	= {The GitHub Blog},
  author	= {Nadeem, Ayman},
  year		= {2020}
}

@Article{	  peytonjones02secrets,
  author	= {Peyton-Jones, Simon and Marlow, Simon},
  title		= {Secrets of the Glasgow Haskell Compiler Inliner},
  year		= {2002},
  issue_date	= {July 2002},
  publisher	= {Cambridge University Press},
  address	= {USA},
  volume	= {12},
  number	= {5},
  issn		= {0956-7968},
  url		= {https://doi.org/10.1017/S0956796802004331},
  doi		= {10.1017/S0956796802004331},
  abstract	= {Higher-order languages such as Haskell encourage the
		  programmer to build abstractions by composing functions. A
		  good compiler must inline many of these calls to recover an
		  efficiently executable program. In principle, inlining is
		  dead simple: just replace the call of a function by an
		  instance of its body. But any compiler-writer will tell you
		  that inlining is a black art, full of delicate compromises
		  that work together to give good performance without
		  unnecessary code bloat. The purpose of this paper is,
		  therefore, to articulate the key lessons we learned from a
		  full-scale “production” inliner, the one used in the
		  Glasgow Haskell compiler. We focus mainly on the
		  algorithmic aspects, but we also provide some indicative
		  measurements to substantiate the importance of various
		  aspects of the inliner.},
  journal	= {J. Funct. Program.},
  month		= {jul},
  pages		= {393–434},
  numpages	= {42}
}

@Article{	  pickering17profunctor,
  author	= {Pickering, Matthew and Gibbons, Jeremy and Wu, Nicolas},
  year		= {2017},
  month		= {03},
  pages		= {},
  title		= {Profunctor Optics: Modular Data Accessors},
  volume	= {1},
  journal	= {The Art, Science, and Engineering of Programming},
  doi		= {10.22152/programming-journal.org/2017/1/7}
}

@Article{	  plotkin01semantics,
  author	= {Plotkin, Gordon and Power, John},
  year		= {2001},
  month		= {07},
  pages		= {},
  title		= {Semantics for Algebraic Operations},
  volume	= {45},
  journal	= {Electronic Notes in Theoretical Computer Science},
  doi		= {10.1016/S1571-0661(04)80970-8}
}

@Misc{		  rix17changed,
  title		= {Quickly review changed methods and functions in your pull
		  requests | The GitHub Blog},
  url		= {https://github.blog/2017-07-26-quickly-review-changed-methods-and-functions-in-your-pull-requests/},
  journal	= {The GitHub Blog},
  author	= {Rix, Rob},
  year		= {2017}
}

@InProceedings{	  schrijvers19monad,
  author	= {Schrijvers, Tom and Piróg, Maciej and Wu, Nicolas and
		  Jaskelioff, Mauro},
  year		= {2019},
  month		= {08},
  pages		= {98-113},
  title		= {Monad transformers and modular algebraic effects: what
		  binds them together},
  isbn		= {978-1-4503-6813-1},
  doi		= {10.1145/3331545.3342595}
}

@Misc{		  servant14,
  author	= {Servant},
  year		= 2014,
  version	= {v0.19},
  url		= {https://github.com/haskell-servant/servant}
}

@Article{	  swierstra08data,
  title		= {Data types à la carte},
  volume	= {18},
  doi		= {10.1017/S0956796808006758},
  number	= {4},
  journal	= {Journal of Functional Programming},
  publisher	= {Cambridge University Press},
  author	= {Swierstra, Wouter},
  year		= {2008},
  pages		= {423–436}
}

@Book{		  tomita84efficient,
  place		= {Boston, MA},
  title		= {Efficient parsing for natural language: A fast algorithm
		  for practical systems},
  publisher	= {Kluwer Academic},
  author	= {Tomita, Masaru},
  year		= {1986}
}

@InProceedings{	  typeconstraintsunleashed,
  author	= {Orchard, Dominic and Schrijvers, Tom},
  editor	= {Blume, Matthias and Kobayashi, Naoki and Vidal,
		  Germ{\'a}n},
  title		= {Haskell Type Constraints Unleashed},
  booktitle	= {Functional and Logic Programming},
  year		= {2010},
  publisher	= {Springer Berlin Heidelberg},
  address	= {Berlin, Heidelberg},
  pages		= {56--71}
}

@Article{	  visser18scopes,
  author	= {{van Antwerpen}, Hendrik and Poulsen, Casper and Rouvoet,
		  Arjen and Visser, Eelco},
  year		= {2018},
  month		= {10},
  pages		= {1-30},
  title		= {Scopes as types},
  volume	= {2},
  journal	= {Proceedings of the ACM on Programming Languages},
  doi		= {10.1145/3276484}
}

@inproceedings{wu15fusion,
  author    = {Nicolas Wu and
               Tom Schrijvers},
  editor    = {Ralf Hinze and
               Janis Voigtl{\"{a}}nder},
  title     = {Fusion for Free - Efficient Algebraic Effect Handlers},
  booktitle = {Mathematics of Program Construction - 12th International Conference,
               2015.
               Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {9129},
  pages     = {302--322},
  publisher = {Springer},
  year      = {2015},
  url       = {https://doi.org/10.1007/978-3-319-19797-5\_15},
  doi       = {10.1007/978-3-319-19797-5\_15},
  timestamp = {Sat, 19 Oct 2019 20:22:56 +0200},
  biburl    = {https://dblp.org/rec/conf/mpc/WuS15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@InProceedings{	  wu2014effect,
  author	= {Wu, Nicolas and Schrijvers, Tom and Hinze, Ralf},
  title		= {Effect Handlers in Scope},
  year		= {2014},
  isbn		= {9781450330411},
  publisher	= {Association for Computing Machinery},
  address	= {New York, NY, USA},
  url		= {https://doi.org/10.1145/2633357.2633358},
  doi		= {10.1145/2633357.2633358},
  booktitle	= {Proceedings of the 2014 ACM SIGPLAN Symposium on Haskell},
  pages		= {1–12},
  numpages	= {12},
  keywords	= {monads, syntax, modularity, Haskell, effect handlers,
		  semantics},
  location	= {Gothenburg, Sweden},
  series	= {Haskell '14}
}
