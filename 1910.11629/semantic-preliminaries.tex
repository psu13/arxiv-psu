% !TEX root = runners-in-action.tex

\section{Algebraic effects, handlers, and runners}
\label{sect:runnersbyexample}

We begin with a short overview of the theory of algebraic effects and handlers, as well as
runners. To keep focus on how runners give rise to a programming
concept, we work naively in set theory. Nevertheless, we use
category-theoretic language as appropriate, to make it clear that there are no essential
obstacles to extending our work to other settings (we return to this point in \cref{sec:semantics-types}).

\subsection{Algebraic effects and handlers}
\label{sect:algebraiceffects}

There is by now no lack of material on the algebraic approach to structuring computational effects.
For an introductory treatment we refer to~\cite{Bauer:WhatIsAlgebraic}, while of course
also recommend the seminal papers by Plotkin and
Power~\cite{Plotkin:SemanticsForAlgOperations,Plotkin:NotionsOfComputation}. The brief
summary given here only recalls the essentials and introduces notation.

An \emph{(algebraic) signature} is given by a set $\sig$ of \emph{operation symbols},
and for each $\op \in \sig$ its \emph{operation signature}
%
$
  \op : A_\op \opto B_\op
$,
%
where  $A_\op$ and $B_\op$ are called the \emph{parameter} and \emph{arity} set.
A \emph{$\sig$-structure} $\M$ is given by a carrier set $\Mcarrier$, and for each
operation symbol $\op \in \sig$, a map $\op_{\M} : A_\op \times (B_\op \expto \Mcarrier) \to \Mcarrier$,
where~$\expto$ is set exponentiation. The \emph{free $\sig$-structure~$\Tree{\sig}{X}$}
over a set~$X$ is the set of well-founded trees generated inductively by
%
\begin{itemize}
\item $\retTree{x} \in \Tree{\sig}{X}$, for every $x \in X$, and
\item $\op(a, \kappa) \in \Tree{\sig}{X}$, for every $\op \in \sig$, $a \in A_\op$, and $\kappa : B_\op \to \Tree{\sig}{X}$.
\end{itemize}
%
We are abusing notation in a slight but standard way, by using $\op$ both as the
name of an operation and a tree-forming constructor.
%
The elements of $\Tree{\sig}{X}$ are called \emph{computation trees}: a leaf
$\retTree{x}$ represents a pure computation returning a value $x$, while
$\op(a, \kappa)$ represents an effectful computation that calls $\op$ with
parameter~$a$ and continuation~$\kappa$, which expects a result from~$B_\op$.

An \emph{algebraic theory $\Th = (\Thsig, \Theq)$} is given by a \emph{signature~$\Thsig$} and
a set of \emph{equations~$\Theq$}.
%
The equations $\Theq$ express computational behaviour via interactions between
operations, and
are written in a suitable formalism, e.g.,~\cite{Plotkin:HandlingEffects}. We
explain these by way of examples, as the precise details do not matter for our purposes.
Let $\Zero = \{\,\}$ be the empty set and $\One = \{\star\}$ the standard singleton.

\begin{example}
  \label{ex:state}
  Given a set $C$ of possible states, the theory of \emph{$C$-valued state} has two operations, whose
  somewhat unusual naming will become clear later on,
  %
  \begin{equation*}
    \siggetenv : \One \opto C,
    \qquad\qquad
    \sigsetenv : C \opto \One
  \end{equation*}
  %
  and the equations (where we elide appearances of $\star$):
  %
  \begin{gather*}
    \siggetenv (\lam{c} \sigsetenv(c, \kappa)) = \kappa,
    \qquad
    \sigsetenv (c, \siggetenv\, \kappa) = \sigsetenv(c, \kappa\, c), \\
    \sigsetenv (c, \sigsetenv(c', \kappa)) = \sigsetenv(c', \kappa).
  \end{gather*}
  %
  For example,
  the second equation states that reading state right after setting it to~$c$ gives precisely~$c$.
  The third equation states that $\sigsetenv$ overwrites the state.
\end{example}

\begin{example}
  \label{ex:exceptions}
  Given a set of exceptions $E$, the algebraic theory of \emph{$E$-many exceptions} is given by
  a single operation $\sigraise : E \opto \Zero$, and no equations.
\end{example}

A \emph{$\Th$-model}, also called a \emph{$\Th$-algebra}, is a $\Thsig$-structure which
satisfies the equations in $\Theq$. The \emph{free $\Th$-model} over a set~$X$ is constructed
as the quotient
%
\begin{equation*}
  \FreeAlg{\Th}{X} = \Tree{\Thsig}{X}/{\sim}
\end{equation*}
%
by the $\Thsig$-congruence $\sim$ generated by $\Theq$. Each $\op \in \Thsig$
is interpreted in the free model as the map
$(a, \kappa) \mapsto [\op(a, \kappa)]$, where $[{-}]$ is the $\sim$-equivalence class.

$\FreeAlg{\Th}{-}$ is the functor part of a \emph{monad} on sets, whose \emph{unit} at a
set~$X$ is
%
\begin{equation*}
  \xymatrix@C=3em@R=2em@M=0.5em{
    {X} \ar[r]^(0.35){\retTree{}}
    &
    {\Tree{\Thsig}{X}} \ar@{->>}[r]^{[{-}]}
    &
    {\FreeAlg{\Th}{X}.}
  }
\end{equation*}
%
The \emph{Kleisli extension} for this monad is then the operation which lifts any map \linebreak
$f : X \to \Tree{\Thsig}{Y}$ to the map $\lift{f} : \FreeAlg{\Thsig}{X} \to \FreeAlg{\Thsig}{Y}$,
given by
%
\begin{equation*}
  \lift{f}\,[\retTree{x}] \defeq f \, x,
  \qquad\qquad
  \lift{f}\,[\op(a, \kappa)] \defeq [\op(a, \lift{f} \circ \kappa)].
\end{equation*}
%
That is, $\lift{f}$ traverses a computation tree and replaces each leaf $\retTree{x}$
with $f\,x$.

The preceding construction of free models and the monad may be retro-fitted to an
algebraic signature~$\sig$, if we construe~$\sig$ as an algebraic theory with no
equations. In this case~$\sim$ is just equality, and so we may omit the quotient and the
pesky equivalence classes. Thus the carrier of the free $\sig$-model is the set of
well-founded trees $\Tree{\sig}{X}$, with the evident monad structure.

A fundamental insight of Plotkin and
Power~\cite{Plotkin:SemanticsForAlgOperations,Plotkin:NotionsOfComputation} was that many
computational effects may be adequately described by algebraic theories, with
the elements of free models corresponding to effectful computations. For example, the monads
induced by the theories from \cref{ex:state,ex:exceptions} are respectively isomorphic to the usual \emph{state monad}
$\St{C}\,X \defeq (C \Rightarrow X \times C)$ and the \emph{exceptions monad}
$\Exc{E}\,X \defeq X + E$.

Plotkin and Pretnar~\cite{Plotkin:HandlingEffects} further
observed that the universal property of free models may be used to model a
programming concept known as \emph{handlers}. Given a $\Th$-model $\M$ and a map
$f : X \to \Mcarrier$, the universal property of the free $\Th$-model gives us a
unique $\Th$-homomorphism $\freelift{f} : \FreeAlg{\Th}{X} \to \Mcarrier$ satisfying
%
\begin{equation*}
  \freelift{f} \, [\retTree{x}] = f\,x,
  \qquad\qquad
  \freelift{f} \, [\op(a, \kappa)] = \op_\M(a, \freelift{f} \circ \kappa).
\end{equation*}

A handler for a theory $\Th$ in a language such as \pl{Eff} amounts to a model 
$\M$ whose carrier $\Mcarrier$
is the carrier $\FreeAlg{\Th'}{Y}$ of the free model
for some other theory~$\Th'$, while the associated handling
construct is the induced $\Th$-homomorphism $\FreeAlg{\Th}{X} \to \FreeAlg{\Th'}{Y}$.
Thus handling transforms computations with effects~$\Th$ to computations with
effects~$\Th'$. There is however no restriction on how a handler implements an
operation, in particular, it may use its continuation in an arbitrary
fashion.
%
We shall put the universal property of free models to good use as well, while
making sure that the continuations are always used affinely.

\subsection{Runners}
\label{sect:purerunners}

Much like monads, handlers are useful for simulating computational effects, because they
allow us to transform $\Th$-computations to $\Th'$-computations. However, eventually there
has to be a ``top level'' where such transformations cease and actual computational
effects happen. For these we need another concept, known as
\emph{runners}~\cite{Uustalu:Runners}.
%
Runners are equivalent to the concept of
\emph{comodels}~\cite{Plotkin:TensorsOfModels,Power:Comodels}, which are ``just
models in the opposite category'', although one has to apply the motto
correctly by using powers and co-powers where seemingly exponentials and products would
do. 
Without getting into the intricacies, let us spell out the definition.

\begin{definition}
  A \emph{runner} $\R$ for a signature $\sig$ is given by a carrier set~$\Rcarrier$ together with, for
  each $\op \in \sig$, a
  \emph{co-operation~$\coop_{\R} : A_\op \to (\Rcarrier \expto B_\op \times \Rcarrier)$.}
\end{definition}

%
Runners are usually defined to have co-operations in the equivalent uncurried form
$\coop_\R : A_\op \times \Rcarrier \to B_\op \times \Rcarrier$, but that is less convenient for our purposes.

Runners may be defined more generally for theories $\Th$, rather than just signatures,
by requiring that the co-operations satisfy $\Theq$. We shall have no use for these,
although we expect no obstacles in incorporating them into our work.

A runner tells us what to do when an effectful computation reaches the top-level runtime
environment. Think of~$\Rcarrier$ as the set of configurations of the runtime environment. Given
the current configuration $c \in \Rcarrier$, the operation $\op(a, \kappa)$ is executed as the
corresponding co-operation $\coop_\R\,a\,c$ whose result $(b, c') \in B_\op \times \Rcarrier$ gives
the result of the operation $b$ and 
the next runtime configuration $c'$. The continuation $\kappa\,b$
then proceeds in runtime configuration~$c'$.

It is not too difficult to turn this idea into a mathematical model. For any
$X$, the co-operations induce a $\sig$-structure $\M$ with
$\Mcarrier \defeq \St{\Rcarrier} X = (\Rcarrier \expto X \times \Rcarrier)$ 
and operations $\op_\M : A_\op \times (B_\op \expto \St{\Rcarrier} X) \to \St{\Rcarrier} X$
given by
%
\begin{equation*}
  \op_\M (a, \kappa) \defeq \lam{c} \kappa\, (\pi_1 (\coop_\R\,a\,c))\, (\pi_2 (\coop_\R\,a\,c)).
\end{equation*}
%
We may then use the universal property of the free $\sig$-model to obtain a $\sig$-homomorphism
$\runh_X : \Tree{\sig}{X} \to \St{\Rcarrier} X$ satisfying the equations
%
\[
  \runh_X(\retTree{x}) = \lam{c} (x, c),
  \qquad\qquad
  \runh_X(\op(a, \kappa)) = \op_\M(a, \runh_X \circ \kappa).
\]
%
The map $\runh_X$ precisely captures the idea that a runner
\emph{runs computations} by transforming (static) computation trees into
state-passing maps. Note how in the above definition of $\op_\M$, the
continuation~$\kappa$ is used in a controlled way, as it appears precisely once
as the head of the outermost application. In terms of programming, this
corresponds to linear use in a tail-call position.

Runners are less ad-hoc than they may seem. First, notice that $\op_\M$ is just the
composition of the co-operation $\coop_\R$ with
the state monad's Kleisli extension of the continuation $\kappa$, and so is
the standard way of turning \emph{generic effects} into $\sig$-structures~\cite{Plotkin:AlgOperations}.
%
Second, the map $\runh_X$ is the component at $X$ of a monad morphism
$\runh : \Tree{\sig}{{-}} \to \St{\Rcarrier}$. Møgelberg \& Staton~\cite{Mogelberg:LinearUsageOfState}, as
well as Uustalu~\cite{Uustalu:Runners}, showed that the passage from a runner~$\R$ to the
corresponding monad morphism~$\runh$ forms a one-to-one correspondence between the former and the
latter.

As defined, runners are too restrictive a model of top-level computation, because the only
effect available to co-operations is state, but in practice the runtime
environment may also signal errors and perform other effects, by calling its own runtime
environment. We are led to the following generalisation.

\begin{definition}
  For a signature $\sig$ and monad $\T$, a \emph{$\T$-runner $\R$} for~$\sig$, 
  or just an \emph{effectful runner}, 
  is given by, for each $\op \in \sig$, a \emph{co-operation}
  $\coop_\R : A_\op \to \T B_\op$.
\end{definition}

The correspondence between runners and monad morphisms still holds.

\begin{proposition}
  \label{prop:monadmorphism}
  For a signature $\sig$ and a monad $\T$, the monad morphisms $\Tree{\sig}{{-}} \to \T$
  are in one-to-one correspondence with $\T$-runners for~$\sig$.
\end{proposition}

\begin{proof}
  This is an easy generalisation of the correspondence for 
  ordinary runners. Let us fix a signature $\sig$, and a monad $\T$ 
  with unit $\eta$ and Kleisli extension $\lift{{-}}$.

  Let $\R$ be a $\T$-runner for $\sig$. For any set $X$, $\R$ induces a $\sig$-structure
  $\M$ with $\Mcarrier \defeq \T X$ and 
  $\op_\M : A_\op \times (B_\op \expto \T X) \to \T X$ defined as
  %
  $
    \op_\M (a, \kappa) \defeq \lift{\kappa} (\coop_R\,a)
  $.
  %
  As before, the universal property of the free model $\Tree{\sig}{X}$ provides a unique
  $\sig$-homomorphism $\runh_X : \Tree{\sig}{X} \to \T X$, satisfying the equations
  %
  \begin{equation*}
    \runh_X (\retTree{x}) = \eta_X(x),
    \qquad\qquad
    \runh_X (\op(a, \kappa)) = \op_\M (a, \runh_X \circ \kappa).
  \end{equation*}
  %
  The maps $\runh_X$ collectively give us the desired monad morphism $\runh$ induced by $\R$.
  
  Conversely, given a monad morphism $\theta : \Tree{\sig}{{-}} \to \T$, we may recover a
  $\T$-runner~$\R$ for $\sig$ by defining the co-operations as
  $
    \coop_\R \, a \defeq \theta_{B_\op} (\op (a, \lam{b} \retTree{b}))
  $.
  It is not hard to check that we have described a one-to-one correspondence.
  \qed
\end{proof}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "runners-in-action"
%%% End:
