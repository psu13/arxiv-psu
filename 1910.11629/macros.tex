% !TEX root = runners-in-action.tex

% Any macro that is actually used should have a comment explaining what it is for.
% Please fight macro pollution and remove the macros that are not used.

\newcommand{\defeq}{\mathrel{\overset{\text{\tiny def}}{=}}} % Definitional equality

\newcommand{\pl}[1]{\textsc{#1}} % the name of a programming language

\newcommand{\lambdacoop}{\lambda_{\mathsf{coop}}} % the name of the calculus

% BNF grammars
\newcommand{\bnfis}{\mathrel{\;{:}{:}{=}\ }}
\newcommand{\bnfor}{\mathrel{\;\big|\ \ }}

%%%%% Semantic concepts

%%% Signatures

\newcommand{\sig}{\Sigma} % a signature

\newcommand{\Tree}[2]{\mathrm{Tree}_{#1}\left(#2\right)} % The tree algebra for an operation signature
\newcommand{\retTree}[1]{\mathsf{return}\,#1} % the inclusion of generators into trees

%%% Theories
\newcommand{\eq}{\mathrm{Eq}} % a set of equations

\newcommand{\Th}{\mathcal{T}} % a generic algebraic theory
\newcommand{\Thsig}{\sig_\Th} % the underlying signature of a generic algebraic theory
\newcommand{\Theq}{\eq_\Th} % the equations of a generic algebraic theory

\newcommand{\ThUU}[2]{\mathcal{U}_{#1, #2}} % User theory
\newcommand{\UU}[2]{\mathsf{U}_{#1, #2}} % User monad

\newcommand{\ThKK}[4]{\mathcal{K}_{#2, #3, #4, #1}} % The kernel theory
\newcommand{\KK}[4]{\mathsf{K}_{#2, #3, #4, #1}} % the kernel monad

\newcommand{\UUskel}{\skel{\mathsf{U}}} % the skeletal user monad
\newcommand{\KKskel}[1]{\skel{\mathsf{K}}_{#1}} % the skeletal kernel monad

\newcommand{\Runner}[4]{\mathsf{Runner}_{#1, #2, #3}\, #4} % the set of all runners
\newcommand{\RunnerSkel}[1]{\skel{\mathsf{Runner}}\,#1} % the set of all skeletal runners

\newcommand{\FreeAlg}[2]{\mathrm{Free}_{#1}\left(#2\right)} % Free algebra for a signature generated by a set
\newcommand{\lift}[1]{#1^\dagger} % the Kleisli lifting of a map
\newcommand{\freelift}[1]{#1^\ddagger} % the lifting of a map induced by the free model property

\newcommand{\M}{\mathcal{M}} % a generic model for a theory
\newcommand{\Mcarrier}{\vert \mathcal{M} \vert} % the carrier of a generic model

\newcommand{\T}{T} % A generic monad
\newcommand{\St}[1]{\mathsf{St}_{#1}} % the state monad
\newcommand{\Exc}[1]{\mathsf{Exc}_{#1}} % the exception monad

\newcommand{\R}{\mathcal{R}} % a generic runner
\newcommand{\Rcarrier}{\vert\R\vert} % the carrier of a generic runner
\newcommand{\iRcarrier}[1]{\vert\R_{#1}\vert} % indeced carrier of a generic runner
\newcommand{\runh}{\mathsf{r}} % the map induced by runner

% UNUSED % \newcommand{\Mtotal}{\hat{\mathcal{M}}}

\newcommand{\expto}{\Rightarrow} % set exponentiation
\newcommand{\lam}[1]{\lambda #1 \,.\,} % lambda abstraction

\newcommand{\One}{\mathbb{1}} % singleton set as denotation of unit type
\newcommand{\Zero}{\mathbb{0}} % empty set as denotation of empty type


\newcommand{\op}{\mathsf{op}} % a generic operation symbol
\newcommand{\coop}{\mathsf{\overline{op}}} % a generic co-operation
\newcommand{\opto}{\leadsto} % the wiggly arrow for operation signature
\newcommand{\tysigop}[3]{#1 \opto #2 \mathbin{!} #3} % the full signature of an operation

\newcommand{\sigraise}{\mathsf{raise}} % the exception raising operation (semantic operation)
\newcommand{\sigkill}{\mathsf{kill}} % the signal sending operation (semantic operation)
\newcommand{\siggetenv}{\mathsf{getenv}} % read state (semantic operation)
\newcommand{\sigsetenv}{\mathsf{setenv}} % set state (semantic opeation)

%%%%% Types


\newcommand{\at}{\mathbin{@}} % the @ sign, with proper spacing
\newcommand{\atkernel}{\mathbin{\!\lightning\!}} % the ligthning sign, with proper spacing
\newcommand{\atuser}{\mathbin{!}} % the ! sign, with proper spacing


%% Value types
\newcommand{\tybase}{\mathsf{b}} % a base type
\newcommand{\tyunit}{\mathsf{unit}} % the unit ground type
\newcommand{\tyempty}{\mathsf{empty}} % the empty ground type
\newcommand{\typrod}[2]{#1 \times #2} % product type
\newcommand{\tysum}[2]{#1 + #2} % sum type
\newcommand{\tyfun}[2]{#1 \to #2} % user function type
\newcommand{\tyfunK}[2]{#1 \to #2} % kernel function type
\newcommand{\tyrunner}[4]{#1 \Rightarrow (#2, #3, #4)} % runner type

%% User and kernel types

\newcommand{\Ueff}{\mathcal{U}} % generic user type effects
\newcommand{\Veff}{\mathcal{V}} % another generic user type effects
\newcommand{\Keff}{\mathcal{K}} % generic kernel type effects
\newcommand{\Leff}{\mathcal{L}} % another generic kernel type effects

\newcommand{\uty}[1]{\overline{#1}} % generic user type
\newcommand{\kty}[1]{\overline{\overline{#1}}} % generic kernel type

\newcommand{\tyuser}[2]{#1 \atuser #2} % user type
\newcommand{\tykernel}[2]{#1 \atkernel #2} % kernel type

%% Skeletal types

\newcommand{\skel}[1]{{#1}^{\mathsf{s}}} % tag on a name of skeletal type
\newcommand{\skeleton}[1]{{#1}^{\mathsf{s}}} % the operation of taking the skeleton of a type

\newcommand{\tyrunnerskel}[1]{\mathsf{runner}\,C} % skeletal runner type
\newcommand{\tyfunskel}[2]{#1 \to #2} % skeletal user function space
\newcommand{\tyfunKskel}[2]{#1 \to #2} % skeletal kernel function space

\newcommand{\tyuserskel}[1]{#1{!}} % skeletal user type
\newcommand{\tykernelskel}[2]{#1 \atkernel #2} % skeletal kernel type

%%%%% Display of source code in math mode

\newcommand{\Ops}{\mathcal{O}} % the set of all operation names
\newcommand{\Sigs}{\mathcal{S}} % the set of all signal names
\newcommand{\Excs}{\mathcal{E}} % the set of all exception names

\newcommand{\tm}[1]{\mathsf{#1}} % the source code font (keep this in sync with coop.tex)
\newcommand{\tmkw}[1]{\tm{\color{keywordColor}#1}} % source code keyword, colored (keep this in sync with coop.tex)

\newcommand{\tmconst}[1]{\tm{#1}}
\newcommand{\tmunit}{()} % the element of the unit type
\newcommand{\tmpair}[2]{( #1 , #2 )} % ordered pair
\newcommand{\tminl}[2][]{\tmkw{inl}_{#1}\,#2} % left injection
\newcommand{\tminr}[2][]{\tmkw{inr}_{#1}\,#2} % right injection
\newcommand{\tmfun}[2]{{\mathop{\tmkw{fun}}}\; (#1) \mapsto #2} % user function abstraction
\newcommand{\tmfunK}[2]{{\mathop{\tmkw{funK}}}\; (#1) \mapsto #2} % kernel function abstraction
\newcommand{\tmapp}[2]{#1\,#2} % application

\newcommand{\tmrunner}[2]{\{#1\}_{#2}} % runner

\newcommand{\tmreturn}[2][]{\tmkw{return}_{#1}\, #2} % pure computation
\newcommand{\tmlet}[4][]{\tmkw{let}_{#1}\; #2 = #3 \;\tmkw{in}\; #4} % let-binding
\newcommand{\tmtry}[2]{\tmkw{try}\; #1 \; \tmkw{with}\; #2}
\newcommand{\tmkernel}[3]{\tmkw{kernel} \; #1 \at #2 \;\tmkw{finally} \; #3}
\newcommand{\tmuser}[2]{\tmkw{user} \; #1 \; \tmkw{with} \; #2}
\newcommand{\tmrun}[4]{\tmkw{using} \; #1 \at #2 \; \tmkw{run} \; #3 \; \tmkw{finally} \; #4}

\newcommand{\tmop}[5]{\tm{#1}_{#2}(#3, #4, #5)} % operation call
\newcommand{\tmgeneff}[2]{\tm{#1}\; #2} % generic operation call
\newcommand{\tmcont}[2]{(#1 \,.\, #2)} % a continuation
\newcommand{\tmexccont}[3]{(#1_{#2})_{#2 \in #3}} % exception continuations

\newcommand{\tmexcept}[3]{\tmreturn{#1} \mapsto #2, #3} % the body of an exception handler
\newcommand{\tmfinally}[4]{\{\tmreturn{#1} \mapsto #2, #3, #4\}} % the body of a finally clause

\newcommand{\tmmatch}[3][]{\tmkw{match}\;#2\;\tmkw{with}\;\{#3\}_{#1}} % match statement

\newcommand{\tmraise}[2][]{\tmkw{raise}_{#1}\,#2} % raise an exception
\newcommand{\tmkill}[2][]{\tmkw{kill}_{#1}\,#2} % send a signal

\newcommand{\tmgetenv}[2][]{\tmkw{getenv}_{#1}#2} % get current environment
\newcommand{\tmsetenv}[2]{\tmkw{setenv}(#1, #2)} % set the current environment

%%% Typing rules

\newcommand{\types}{\vdash} % typing judgement
\newcommand{\typesskel}{\vdash^{\!\mathsf{s}}} % skeletal typing judgement
\newcommand{\of}{\mathinner{:}} % the colon in a typing judgement

\newcommand{\vj}[3]{#1 \vdash #2 : #3} % value typing
\newcommand{\cj}[5]{#1 \vdash^{\kern -1.25ex #2} #3 : #4 \mathrel{!} #5} % user computation typing
\newcommand{\kj}[7]{#1 \vdash^{\kern -1.25ex #2} #3 : #4 \mathrel{!} #5 \mathrel{\lightning} #6 \at #7} % kernel computation typing

\newcommand{\subty}[2]{#1 \sqsubseteq #2} % subtyping relation (old macro)
\newcommand{\sub}{\sqsubseteq} % subtyping relation

\newcommand{\mkrule}[3]{\frac{#1}{#3}{\textsc{#2}}} % temporary, until we sort out proof package.

\newcommand{\coopinfer}[3]{\inferrule*[Lab={\color{rulenameColor}#1}]{#2}{#3}}

%%% Denotational semantics

\newcommand{\sem}[1]{[\![\![#1]\!]\!]} % semantic bracket
\newcommand{\skelsem}[1]{[\![#1]\!]} % skeletal semantic bracket

\newcommand{\subexpto}{\Rrightarrow} % the exponential in the subset fibration

\newcommand{\Set}{\mathrm{Set}} % the category of sets
\newcommand{\Cpo}{\mathrm{Cpo}} % the category of $\omega$-cpos
\newcommand{\Sub}{\mathrm{Sub}} % the subobjects

\newcommand{\cond}[3]{\mathsf{if}\;#1\;\mathsf{then}\;#2\;\mathsf{else}\;#3} % single line conditional

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "runners-in-action"
%%% End:
