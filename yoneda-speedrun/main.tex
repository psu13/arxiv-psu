%!TEX root = yoneda-speedrun.tex

\section{The Big Picture}

The Yoneda Lemma is a basic and beloved result in category theory. In most treatments it
shows up fairly early in the books and lecture notes on the subject. Its statement is
deceivingly compact because its content is buried inside layers of abstraction and
notation that have been built up while working through the conceptual basis of category
theory. For me the hard part of understanding this result was unwrapping the abstraction
ladder.

I am going to do the following dumb thing: I am going to state the result at the top to
give us the target. Then I will define the only the pieces we need to make that result
make sense as fast as possible, so all of the material is contained in a single small
document for easy reference. In the spirit of video game speedruns, it will be only what
is absolutely necessary, and it will skip a lot of interesting material that you should
really talk about before completing the cateogry theory ``game'', but which we will ignore
for the purposes of speed.

Note that I am not a mathematician or a category theory expert. I'm just a guy trying to
figure out the notation. So everything in this document is probably wrong.

\section{Statement of the Lemma}

The Lemma is usually stated in some form similar this:

\begin{lemma}[Yoneda]\label{yoneda} Let $\CC$ be a locally small category. Let $X$ be an
object of $\CC$, and let $F: \CC \to \Set$ be a functor from $\CC$ to the category $\Set$.
Then there is an invertible mapping between the set of natural transformations from
$\Arrows(X, -)$ to $F$ and the elements of $FX$ and this mapping is natural in both $F$
and $X$.
\end{lemma}
\goodbreak
\noindent
To make sense of this we need to look into the various parts of the statement:
\begin{itemize}
\item Categories
\item Functors
\item Natural transformations
\item Functor categories
\item Catgories and sets.
\end{itemize}
\noindent
So that's the path that we will take, and when we get to the end we'll state the result
again in various other ways.

\section{Categories}

Categories have a deliciously multi-part definition.

\begin{defn}
\label{category}
A {\it category} $\CC$ consists of:
%
\begin{itemize}
\item 
A collection of {\it objects} that we will denote with upper case letters $X, Y, Z, ...$,
and so on.  
We call this collection $\objc$. Traditionally people write just $\CC$ to mean $\objc$
when the context makes clear what is going on.
\item
A collection of {\it arrows} denoted with lower case letters $f, g, h, ...$, and so on.
Other names for {\it arrows} include {\it mappings} or {\it functions} or {\it morphims}.
We will call this collection $\Arrows(\CC)$. \end{itemize}%
The objects and arrows of a category satisfy the following conditions:
\begin{itemize}
\item
Each arrow $f$ maps one object $A \in \objc$ to another object $B \in \objc$ and we denote
this by writing $f: A \to B$. $A$ is called the {\it domain} of $f$ and $B$ the {\it
codomain}.
\item
For each pair of arrows $f:A \to B$ and $g : B \to C$ we can form a new arrow $g \circ f:
A \to C$ called the {\it composition} of $f$ and $g$. This is also sometimes written $gf$.
\item
For each $A \in \objc$ there is a function $1_A: A \to A$, called the {\it identity} at
$A$ that maps $A$ to itself. Sometimes this object is also written as $\id_A$.
\end{itemize}
\goodbreak\noindent Finally, we have the last two rules:

\begin{itemize}
\item For any $f: A \to B$ we have that $1_B \circ f$ and $f \circ 1_A$ are both equal to
$f$. 
\item Given $f: A \to B$, $g: B \to C$, $h: C\to D$ we have that $(h \circ g) \circ f = h
\circ (g \circ f)$, or alternatively $(hg)f$ = $h(gf)$. What this also means is that we
can always just write $hgf$ if we want. \end{itemize}%
\end{defn}%
\noindent
We will call the collection of all arrows from $A$ to $B$ $\Arrows_{\CC}(A, B)$. We will
usually write $\Arrows(A,B)$ when it's clear what category $A$ and $B$ come from. People
also write $\Hom(A, B)$ or $\Hom_{\CC}(A,B)$, or $\ihom(A, B)$ or just $\CC(A,B)$ to mean
$\Arrows(A,B)$. Here ``$\Hom$'' stands for homomorphism, which is a word that often means
mappings that preserve some kind of structure.

For these short notes I think the only specific category that we will run into is
$\cat{Set}$, where the objects are sets and the arrows are mappings between sets.

Speaking of sets, the definition of categories we were careful about not calling anything
a {\it set}. This is because some categories involve collections of things that are too
``large'' to be called sets and not get into set theory trouble. Here are two more short
definitions about this that we will need.

\begin{defn}
A category $\CC$ is called {\it small} if $\Arrows(\CC)$ is a set.
\end{defn}

\begin{defn}
A category $\CC$ is called {\it locally small} if $\Arrows_{\CC}(A,B)$ is a set for every
$A, B \in \CC$. \end{defn}%
\noindent
For the rest of this note we will only deal with locally small categories, since in the
the setup for the Lemma, we are given a category $\CC$ that is locally small.

Finally, one more notion that we'll need later is the idea of an {\it isomorphism}.

\begin{defn}
An arrow $f: X \to Y$ in a category $\CC$ is an {\it isomorphism} if there exists an arrow
$g: B \to A$ such that $gf = 1_X$ and $fg = 1_Y$. We say that the objects $X$ and $Y$ are
{\it isomorphic} to each other whenever there exists an isomorphism between them. If two
objects in a category are isomorphic to each other we write $X \iso Y$.
\end{defn}
\noindent
Note that in the category $\cat{Set}$ the isomorphisms are exactly the invertible mappings
between sets.

\section{Functors}

As we navigate our way from basic categories up to the statement of the lemma we will
travel through multiple layers conceptual abstraction. Functors are the first step up this
ladder.

Functors are the {\it arrows between categories}. That is, if you were to define the
category where the objects were all categories of some kind then the arrows would be
functors.

\goodbreak
\begin{defn}
Given two categories $\CC$ and $\DD$ a {\it functor} $F : \CC \to \DD$ is defined by two
sets of parallel rules. First:
\begin{itemize}
\item For each object $X \in \CC$ we assign an object $F(X) \in \DD$.
\item For each arrow $f: X \to Y$ in $\CC$ we assign an arrow $F(f): F(X) \to F(Y)$ in
$\DD$.
\end{itemize}
\noindent
So $F$ maps objects in $\CC$ to objects in $\DD$ and also arrows in $\CC$ to arrows in
$\DD$ such that the domains and codomains match up the right way. That is, the domain of
$F(f)$ is $F$ applied to the domain of $f$, and the codomain of $F(f)$ is $F$ applied to
the codomain of $f$. In addition the following must be true:
\begin{itemize}
\item If $f:X \to Y$ and $g: Y \to Z$ are arrows in $\CC$ then $F(g \circ f) = F(g) \circ
F(f)$ (or $F(gf) = F(g)F(f)$).
\item For every $X \in \CC$ it is the case that $F(1_X) = 1_{F(X)}$.
\end{itemize}

\end{defn}
\noindent
So, a functor consists of two mappings, one on objects and one on arrows. And, these
mappings preserve all of the structure of a category, namely domains and codomains,
composition, and identities.

If $F: \CC \to \DD$ is a functor from a category $\CC$ to another category $\DD$ and an
object $X \in \CC$ we may write $F X$ to mean $F(X)$. This is analogous to the more
compact notation for composition of arrows above.

Functors are notationally confusing because we are using one letter to denote two
mappings. So if $F: \CC \to \DD$ and $X \in \CC$ then $F(X)$ is the functor applied to the
object, which will be an object in $\DD$. On the other hand, if $f : A \to B$ is an arrow
in $\CC$ then $F(f)$ is an arrow in $\DD$. This seems obvious from the definition but in
proofs and calculations the notations will often shift back and forth without enough
context and can be very confusing.

\section{Natural Transformations}

Natural transformations are the next step up the ladder. If functors are arrows between
categories, then natural transformations are arrows between functors.
\begin{defn}
Let $\CC$ and $\DD$ be categories, and let $F$ and $G$ be functors $\CC \to \DD$. To
define a \emph{natural transformation} $\alpha$ from $F$ to $G$, we assign to each object
$X$ of $\CC$, an arrow $\alpha_X:FX\to GX$ in $\DD$, called the \emph{component} of
$\alpha$ at $X$. In addition, for each arrow $f:X\to Y$ of $\CC$, the following diagram
has to commute:
  $$
  \begin{tikzcd}
   FX \ar{r}{Ff} \ar{d}{\alpha_X} & FY \ar{d}{\alpha_{Y}} \\
   GX \ar{r}{Gf} & GY
  \end{tikzcd}
  $$
\end{defn}
\noindent
This is the first commutative diagram that I've tossed up. There is no magic here. The
idea is that you get the same result no matter which way you travel through the diagram.
So here $\alpha_Y \circ F$ and $G \circ \alpha_X$ must be equal.

We denote natural transformations as double arrows, $\alpha: F \fto G$, to distinguish
them in diagrams from functors (which are denoted by single arrows):
 $$
 \begin{tikzcd}[column sep=large]
  \CC \ar[bend left,""{below,name=F}]{r}{F} \ar[bend right,""{above,name=G}]{r}[swap]{G} & \DD
  \ar[Rightarrow,from=F,to=G,"\,\alpha"]
 \end{tikzcd}
 $$

You might wonder to yourself: what makes natural transformations ``natural''? The answer
appears to be related to the fact that you can construct them from {\it only} what is
given to you in the categories at hand. The natural transformation takes the action of $F$
on $\CC$ and lines it up exactly with the action of $G$ on $\CC$. No other assumptions or
conditions are needed. In this sense they define a relationship between functors that is
just sitting there in the world no matter what, and thus ``natural''. Another apt way of
putting this is that natural transformations give a canonical way of mapping between the
images of two functors.

As with arrows, it will be useful to define what an isomorphism means in the context of
natural transformations:

\begin{defn}
A {\it natural isomorphism} is a natural transformation $\alpha: F \fto G$ in which every
component $\alpha_X$ is an isomorphism. In this case, the natural isomorphism may be
depicted as $\alpha: F \iso G$.
\end{defn}
\goodbreak
\noindent
In addition we'll use this notation:

\begin{defn}
Let $\CC$ and $\DD$ be categories, and let $F$ and $G$ be functors $\CC \to \DD$. Then
we'll write $\Nat(F, G)$ for the set of all natural transformations from $F$ to $G$.
\end{defn}
\noindent
You will also see people write $\Hom(F, G)$ or $\CC(F, G)$ for this, which overloads
$\Hom$ to work on both categories and functors.

\section{Functor Categories}

We are almost there, but there are two more steps up the abstraction ladder. We have in
our one hand objects called functors, and we have in our other hand the natural
transformations. So the next obvious thing is to make a category out of them.

\begin{defn}
 Let $\CC$ and $\DD$ be categories. The \emph{functor category} between $\CC$ and $\DD$ is
 constructed as follows:
 \begin{itemize}
  \item Objects are functors $F: \CC \to \DD$;
  \item Morphisms are natural transformations $\alpha:F\fto G$.
 \end{itemize}
\end{defn}
\noindent
Right now you should be wondering to yourself: ``wait, does this definition actually
work?'' I have brazenly claimed without any justification that the it's OK to use the
natural transformations as arrows. Luckily it's fairly clear that this works out if you
just do everything component-wise. So if we have all of these things: 
\begin{itemize}
\item Three functors, $F: \CC \to \DD$ and $G: \CC \to \DD$ and $H:\CC \to \DD$.

\item Two natural transformations $\alpha: F \fto G$ and $\beta: G \fto H$

\item One object $X \in \CC$.
\end{itemize}
\noindent
Then you can define $(\beta \circ \alpha)(X) = \beta(X) \circ \alpha(X)$ and you get the
right behavior. Similarly, the identity transformation $1_F$ can be defined
component-wise: $(1_F)(X) = 1_{F(X)}$.

There are a lot of standard notations for this object, none of which I really like. The
most popular seems to be $[\CC, \DD]$, but you also see $\DD^{\CC}$, and various  
abbreviations like $\mathop{\mathit{Fun}}(\CC,\DD)$ or $\mathop{\mathit{Func}}(\CC,\DD)$,
or $\mathop{\mathit{Funct}}(\CC,\DD)$. I think we should just spell it out and use
$\Fun(\CC,\DD)$. So there.

\section{Represented Functors}

The last conceptual step that we need is a way to construct {\it functors} from {\it
objects}. The following definition is a natural way to do this.

\begin{defn}
Given a locally small category $\CC$ and an object $X \in \CC$ we define a functor
$$
\Arrows(X,-) : \CC \to \Set
$$
using the following assignments:
\begin{itemize}
\item A mapping from $\CC \to \Set$ that assigns to each $Y in \Objects(\CC)$ the set
$\Arrows(X,Y)$
\item A mapping from $\Arrows(\CC) \to \Arrows(\Set) $ that assigns to each arrow $f: A
\to B$ the function defined by mapping each $g: X \to A$ the arrow $f\circ g$.
\end{itemize}
\noindent
Some texts call a functor defined this way the functor {\it represented} by $X$, which
will make sense when we get back to the Lemma.
\end{defn}
\noindent
The definition for objects here is pretty clear. But the one for arrows maybe needs some
thought. Given an arrow $f: A \to B$, it should be the case that $\Arrows(X,-)$ applied to
$f$ is an arrow from $\Arrows(X,A) \to \Arrows(X,B)$. Since $\CC$ is locally small $f \in
\Arrows(\Set)$. Now, if $g: X \to A$ we have that $(f \circ g): X \to B$ is the arrow we
want. This mapping on $f$ is called the {\it post-composition} mapping, since it composes
$f$ {\it after} $g$. As an overloaded abuse of notation we will also write $\Arrows(X,
-)(f) = \Arrows(X,f) = f \circ -$. Note how the placeholder symbols mean completely
different things on each side of this formula. Some people write $f_*$ for $f \circ -$,
but that doesn't seem as fun.

Other notations for this functor include just $\CC(X,-)$, $\Hom(X, -)$, $\Hom_{\CC}(X,
-)$, $H^X$ and $h^X$. In my notational convention we probably should have written this as
$\Arrows_{\CC}(X, -)$. Some people also call this kind of functor a {\it hom-functor}.

Finally, we can use the above definition to characterize an important relationship between
objects and functors:

\begin{defn}
 Let $\cat{C}$ be a category. A functor $F:\cat{C}\to\Set$ is called \emph{representable}
 if it is naturally isomorphic to the functor $\Hom_\cat{C}(X,-):\cat{C}\to\Set$ for some
 object $X$ of $\cat{C}$. In that case we call $X$ the \emph{representing object}. 
\end{defn}
\noindent
This definition is not directly used in the Yoneda Lemma but has close ties to it, as both
have to do with natural isomorphisms between functors and objects. This idea is what is
used to study ``universal`` properties in category theory, which is important and also
something I'm completely ignoring right now.

With all this in hand you should be able to go back to the statement of the result at the
top and make sense of what it is talking about. I'm going to take one tangent and then get
back to that.

\section{Opposites and Duals}

This section is the one optional side quest that I'm including because it comes up in
comparing different versions of the Lemma. Duality in mathematics comes up in a lot of
different ways. Covering it all is way beyond the scope of these notes. But the following
definition is a basic part of category theory so it's worth including.

\begin{defn}
Let $\CC$ be a category. Then we write $\CCop$ for the {\it opposite} or {\it dual}
category of $\CC$, and define it as follows:
\begin{itemize}
\item The objects of $\CCop$ are the same as the objects of $\CC$.
\item $\Arrows(\CCop)$ is defined by taking each arrow $f :X \to Y$ in $\Arrows(\CC)$ and
flipping their direction, so we put $f': Y \to X$ into $\Arrows(\CCop)$. In particular for
$X, Y \in \Objects(\CC)$ we have $\Arrows_{\CC}(A, B) = \Arrows_{\CCop}(B, A)$ (or $\CC(A,
B) = \CCop(B, A)$.
\item Composition of arrows is the same, but with the arguments reversed.
\end{itemize}
\end{defn}
\noindent
The {\it principle of duality} then says, informally, that every categorical definition,
theorem and proof has a dual, obtained by reversing all the arrows.

You will have noticed that some of the statements of the Lemma refer to $\CCop$ and some
do not. These results are all basically equivalent, except for how the arrows go.

The opposite category also leads to some terminology for functors that you will see used a
lot:

\begin{defn}
Given categories $\CC$ and $\DD$ a {\it contravariant} functor from $\CC$ to $\DD$ is a
functor $F: \CCop \to \DD$ where:
\begin{itemize}
\item $F(X) \in \Objects(\DD)$ for each $X \in \objc$.
\item For each arrow $f \in \Arrows(\CC)$ an arrow $F(X): Y \to X$.
\end{itemize}
\goodbreak
\noindent
In addition
\begin{itemize}
\item For any two arrows $f, g \in \Arrows(\CC)$ where $g \circ f$ is defined we have
$F(f) \circ F(g) = F(g \circ f)$.
\item For each $X \in \Objects(\CC)$ we have $1_{F(X)} = F(1_X)$
\end{itemize}

\end{defn}
\noindent
Note how the arrows go backwards when they need to. With this terminology in mind, we call
regular functors from $\CC \to \DD$ {\it covariant}.


\section{The Full Stack}

\section{Notes}

Category theory loves overloaded notation, so I've done it too. Here is a list of some
examples.

No two writers seem to agree on what basic notations to use for basic concepts. So I've
made up my own shit too.

\section{Who I Stole From}

\small
\begin{itemize}
\item \url{https://arxiv.org/abs/1912.10642}

\item \url{https://math.jhu.edu/~eriehl/context/}

\item \url{https://arxiv.org/abs/1612.09375}

\item \url{https://www.logicmatters.net/2018/01/29/category-theory-a-gentle-introduction/}

\item \url{http://pi.math.cornell.edu/~dmehrle/notes/partiii/cattheory_partiii_notes.pdf}

\item \url{http://www.julia-goedecke.de/pdf/CategoryTheoryNotes.pdf}

\end{itemize}

And of course, a bit from

\url{https://en.wikipedia.org/wiki/Categories_for_the_Working_Mathematician}